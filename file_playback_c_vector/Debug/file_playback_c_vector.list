
file_playback_c_vector.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .myAudioFiles 00007a12  08005000  08005000  00015000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00003768  0800ca14  0800ca14  0001ca14  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000f4  0801017c  0801017c  0002017c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  08010270  08010270  00030010  2**0
                  CONTENTS
  5 .ARM          00000000  08010270  08010270  00030010  2**0
                  CONTENTS
  6 .preinit_array 00000000  08010270  08010270  00030010  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  08010270  08010270  00020270  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .fini_array   00000004  08010274  08010274  00020274  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .data         00000010  20000000  08010278  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .ccmram       00000000  10000000  10000000  00030010  2**0
                  CONTENTS
 11 .bss          00000100  20000010  20000010  00030010  2**2
                  ALLOC
 12 ._user_heap_stack 00000600  20000110  20000110  00030010  2**0
                  ALLOC
 13 .ARM.attributes 00000030  00000000  00000000  00030010  2**0
                  CONTENTS, READONLY
 14 .comment      00000043  00000000  00000000  00030040  2**0
                  CONTENTS, READONLY
 15 .debug_info   0000b9c5  00000000  00000000  00030083  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 00002684  00000000  00000000  0003ba48  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 00000c98  00000000  00000000  0003e0d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  000235d6  00000000  00000000  0003ed68  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   0000e943  00000000  00000000  0006233e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000d0106  00000000  00000000  00070c81  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_rnglists 00000947  00000000  00000000  00140d87  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_frame  0000320c  00000000  00000000  001416d0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 00000066  00000000  00000000  001448dc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0800ca14 <__do_global_dtors_aux>:
 800ca14:	b510      	push	{r4, lr}
 800ca16:	4c05      	ldr	r4, [pc, #20]	; (800ca2c <__do_global_dtors_aux+0x18>)
 800ca18:	7823      	ldrb	r3, [r4, #0]
 800ca1a:	b933      	cbnz	r3, 800ca2a <__do_global_dtors_aux+0x16>
 800ca1c:	4b04      	ldr	r3, [pc, #16]	; (800ca30 <__do_global_dtors_aux+0x1c>)
 800ca1e:	b113      	cbz	r3, 800ca26 <__do_global_dtors_aux+0x12>
 800ca20:	4804      	ldr	r0, [pc, #16]	; (800ca34 <__do_global_dtors_aux+0x20>)
 800ca22:	f3af 8000 	nop.w
 800ca26:	2301      	movs	r3, #1
 800ca28:	7023      	strb	r3, [r4, #0]
 800ca2a:	bd10      	pop	{r4, pc}
 800ca2c:	20000010 	.word	0x20000010
 800ca30:	00000000 	.word	0x00000000
 800ca34:	08010164 	.word	0x08010164

0800ca38 <frame_dummy>:
 800ca38:	b508      	push	{r3, lr}
 800ca3a:	4b03      	ldr	r3, [pc, #12]	; (800ca48 <frame_dummy+0x10>)
 800ca3c:	b11b      	cbz	r3, 800ca46 <frame_dummy+0xe>
 800ca3e:	4903      	ldr	r1, [pc, #12]	; (800ca4c <frame_dummy+0x14>)
 800ca40:	4803      	ldr	r0, [pc, #12]	; (800ca50 <frame_dummy+0x18>)
 800ca42:	f3af 8000 	nop.w
 800ca46:	bd08      	pop	{r3, pc}
 800ca48:	00000000 	.word	0x00000000
 800ca4c:	20000014 	.word	0x20000014
 800ca50:	08010164 	.word	0x08010164

0800ca54 <ADPCM_Decode>:
  * @brief  ADPCM_Decode.
  * @param code: a byte containing a 4-bit ADPCM sample. 
  * @retval : 16-bit ADPCM sample
  */
int16_t ADPCM_Decode(uint8_t code)
{
 800ca54:	b480      	push	{r7}
 800ca56:	b085      	sub	sp, #20
 800ca58:	af00      	add	r7, sp, #0
 800ca5a:	4603      	mov	r3, r0
 800ca5c:	71fb      	strb	r3, [r7, #7]
  static int16_t  index = 0;
  static int32_t predsample = 0;
  uint16_t step=0;
 800ca5e:	2300      	movs	r3, #0
 800ca60:	817b      	strh	r3, [r7, #10]
  int32_t diffq=0;
 800ca62:	2300      	movs	r3, #0
 800ca64:	60fb      	str	r3, [r7, #12]
  
  step = StepSizeTable[index];
 800ca66:	4b3b      	ldr	r3, [pc, #236]	; (800cb54 <ADPCM_Decode+0x100>)
 800ca68:	f9b3 3000 	ldrsh.w	r3, [r3]
 800ca6c:	461a      	mov	r2, r3
 800ca6e:	4b3a      	ldr	r3, [pc, #232]	; (800cb58 <ADPCM_Decode+0x104>)
 800ca70:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800ca74:	817b      	strh	r3, [r7, #10]

  /* 2. inverse code into diff */
  diffq = step>> 3;
 800ca76:	897b      	ldrh	r3, [r7, #10]
 800ca78:	08db      	lsrs	r3, r3, #3
 800ca7a:	b29b      	uxth	r3, r3
 800ca7c:	60fb      	str	r3, [r7, #12]
  if (code&4)
 800ca7e:	79fb      	ldrb	r3, [r7, #7]
 800ca80:	f003 0304 	and.w	r3, r3, #4
 800ca84:	2b00      	cmp	r3, #0
 800ca86:	d003      	beq.n	800ca90 <ADPCM_Decode+0x3c>
  {
    diffq += step;
 800ca88:	897b      	ldrh	r3, [r7, #10]
 800ca8a:	68fa      	ldr	r2, [r7, #12]
 800ca8c:	4413      	add	r3, r2
 800ca8e:	60fb      	str	r3, [r7, #12]
  }
  
  if (code&2)
 800ca90:	79fb      	ldrb	r3, [r7, #7]
 800ca92:	f003 0302 	and.w	r3, r3, #2
 800ca96:	2b00      	cmp	r3, #0
 800ca98:	d006      	beq.n	800caa8 <ADPCM_Decode+0x54>
  {
    diffq += step>>1;
 800ca9a:	897b      	ldrh	r3, [r7, #10]
 800ca9c:	085b      	lsrs	r3, r3, #1
 800ca9e:	b29b      	uxth	r3, r3
 800caa0:	461a      	mov	r2, r3
 800caa2:	68fb      	ldr	r3, [r7, #12]
 800caa4:	4413      	add	r3, r2
 800caa6:	60fb      	str	r3, [r7, #12]
  }
  
  if (code&1)
 800caa8:	79fb      	ldrb	r3, [r7, #7]
 800caaa:	f003 0301 	and.w	r3, r3, #1
 800caae:	2b00      	cmp	r3, #0
 800cab0:	d006      	beq.n	800cac0 <ADPCM_Decode+0x6c>
  {
    diffq += step>>2;
 800cab2:	897b      	ldrh	r3, [r7, #10]
 800cab4:	089b      	lsrs	r3, r3, #2
 800cab6:	b29b      	uxth	r3, r3
 800cab8:	461a      	mov	r2, r3
 800caba:	68fb      	ldr	r3, [r7, #12]
 800cabc:	4413      	add	r3, r2
 800cabe:	60fb      	str	r3, [r7, #12]
  }

  /* 3. add diff to predicted sample*/
  if (code&8)
 800cac0:	79fb      	ldrb	r3, [r7, #7]
 800cac2:	f003 0308 	and.w	r3, r3, #8
 800cac6:	2b00      	cmp	r3, #0
 800cac8:	d006      	beq.n	800cad8 <ADPCM_Decode+0x84>
  {
    predsample -= diffq;
 800caca:	4b24      	ldr	r3, [pc, #144]	; (800cb5c <ADPCM_Decode+0x108>)
 800cacc:	681a      	ldr	r2, [r3, #0]
 800cace:	68fb      	ldr	r3, [r7, #12]
 800cad0:	1ad3      	subs	r3, r2, r3
 800cad2:	4a22      	ldr	r2, [pc, #136]	; (800cb5c <ADPCM_Decode+0x108>)
 800cad4:	6013      	str	r3, [r2, #0]
 800cad6:	e005      	b.n	800cae4 <ADPCM_Decode+0x90>
  }
  else
  {
    predsample += diffq;
 800cad8:	4b20      	ldr	r3, [pc, #128]	; (800cb5c <ADPCM_Decode+0x108>)
 800cada:	681a      	ldr	r2, [r3, #0]
 800cadc:	68fb      	ldr	r3, [r7, #12]
 800cade:	4413      	add	r3, r2
 800cae0:	4a1e      	ldr	r2, [pc, #120]	; (800cb5c <ADPCM_Decode+0x108>)
 800cae2:	6013      	str	r3, [r2, #0]
  }
  
  /* check for overflow*/
  if (predsample > 32767)
 800cae4:	4b1d      	ldr	r3, [pc, #116]	; (800cb5c <ADPCM_Decode+0x108>)
 800cae6:	681b      	ldr	r3, [r3, #0]
 800cae8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800caec:	db04      	blt.n	800caf8 <ADPCM_Decode+0xa4>
  {
    predsample = 32767;
 800caee:	4b1b      	ldr	r3, [pc, #108]	; (800cb5c <ADPCM_Decode+0x108>)
 800caf0:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800caf4:	601a      	str	r2, [r3, #0]
 800caf6:	e007      	b.n	800cb08 <ADPCM_Decode+0xb4>
  }
  else if (predsample < -32768)
 800caf8:	4b18      	ldr	r3, [pc, #96]	; (800cb5c <ADPCM_Decode+0x108>)
 800cafa:	681b      	ldr	r3, [r3, #0]
 800cafc:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 800cb00:	da02      	bge.n	800cb08 <ADPCM_Decode+0xb4>
  {
    predsample = -32768;
 800cb02:	4b16      	ldr	r3, [pc, #88]	; (800cb5c <ADPCM_Decode+0x108>)
 800cb04:	4a16      	ldr	r2, [pc, #88]	; (800cb60 <ADPCM_Decode+0x10c>)
 800cb06:	601a      	str	r2, [r3, #0]
  }

  /* 4. find new quantizer step size */
  index += IndexTable [code];
 800cb08:	79fb      	ldrb	r3, [r7, #7]
 800cb0a:	4a16      	ldr	r2, [pc, #88]	; (800cb64 <ADPCM_Decode+0x110>)
 800cb0c:	56d3      	ldrsb	r3, [r2, r3]
 800cb0e:	b29a      	uxth	r2, r3
 800cb10:	4b10      	ldr	r3, [pc, #64]	; (800cb54 <ADPCM_Decode+0x100>)
 800cb12:	f9b3 3000 	ldrsh.w	r3, [r3]
 800cb16:	b29b      	uxth	r3, r3
 800cb18:	4413      	add	r3, r2
 800cb1a:	b29b      	uxth	r3, r3
 800cb1c:	b21a      	sxth	r2, r3
 800cb1e:	4b0d      	ldr	r3, [pc, #52]	; (800cb54 <ADPCM_Decode+0x100>)
 800cb20:	801a      	strh	r2, [r3, #0]
  /* check for overflow*/
  if (index < 0)
 800cb22:	4b0c      	ldr	r3, [pc, #48]	; (800cb54 <ADPCM_Decode+0x100>)
 800cb24:	f9b3 3000 	ldrsh.w	r3, [r3]
 800cb28:	2b00      	cmp	r3, #0
 800cb2a:	da02      	bge.n	800cb32 <ADPCM_Decode+0xde>
  {
    index = 0;
 800cb2c:	4b09      	ldr	r3, [pc, #36]	; (800cb54 <ADPCM_Decode+0x100>)
 800cb2e:	2200      	movs	r2, #0
 800cb30:	801a      	strh	r2, [r3, #0]
  }
  if (index > 88)
 800cb32:	4b08      	ldr	r3, [pc, #32]	; (800cb54 <ADPCM_Decode+0x100>)
 800cb34:	f9b3 3000 	ldrsh.w	r3, [r3]
 800cb38:	2b58      	cmp	r3, #88	; 0x58
 800cb3a:	dd02      	ble.n	800cb42 <ADPCM_Decode+0xee>
  {
    index = 88;
 800cb3c:	4b05      	ldr	r3, [pc, #20]	; (800cb54 <ADPCM_Decode+0x100>)
 800cb3e:	2258      	movs	r2, #88	; 0x58
 800cb40:	801a      	strh	r2, [r3, #0]
  
  /* 5. save predict sample and index for next iteration */
  /* done! static variables */
  
  /* 6. return new speech sample*/
  return ((int16_t)predsample);
 800cb42:	4b06      	ldr	r3, [pc, #24]	; (800cb5c <ADPCM_Decode+0x108>)
 800cb44:	681b      	ldr	r3, [r3, #0]
 800cb46:	b21b      	sxth	r3, r3
}
 800cb48:	4618      	mov	r0, r3
 800cb4a:	3714      	adds	r7, #20
 800cb4c:	46bd      	mov	sp, r7
 800cb4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb52:	4770      	bx	lr
 800cb54:	2000002c 	.word	0x2000002c
 800cb58:	0801017c 	.word	0x0801017c
 800cb5c:	20000030 	.word	0x20000030
 800cb60:	ffff8000 	.word	0xffff8000
 800cb64:	08010230 	.word	0x08010230

0800cb68 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 800cb68:	b480      	push	{r7}
 800cb6a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800cb6c:	4b04      	ldr	r3, [pc, #16]	; (800cb80 <__NVIC_GetPriorityGrouping+0x18>)
 800cb6e:	68db      	ldr	r3, [r3, #12]
 800cb70:	0a1b      	lsrs	r3, r3, #8
 800cb72:	f003 0307 	and.w	r3, r3, #7
}
 800cb76:	4618      	mov	r0, r3
 800cb78:	46bd      	mov	sp, r7
 800cb7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb7e:	4770      	bx	lr
 800cb80:	e000ed00 	.word	0xe000ed00

0800cb84 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800cb84:	b480      	push	{r7}
 800cb86:	b083      	sub	sp, #12
 800cb88:	af00      	add	r7, sp, #0
 800cb8a:	4603      	mov	r3, r0
 800cb8c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800cb8e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800cb92:	2b00      	cmp	r3, #0
 800cb94:	db0b      	blt.n	800cbae <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800cb96:	79fb      	ldrb	r3, [r7, #7]
 800cb98:	f003 021f 	and.w	r2, r3, #31
 800cb9c:	4907      	ldr	r1, [pc, #28]	; (800cbbc <__NVIC_EnableIRQ+0x38>)
 800cb9e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800cba2:	095b      	lsrs	r3, r3, #5
 800cba4:	2001      	movs	r0, #1
 800cba6:	fa00 f202 	lsl.w	r2, r0, r2
 800cbaa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 800cbae:	bf00      	nop
 800cbb0:	370c      	adds	r7, #12
 800cbb2:	46bd      	mov	sp, r7
 800cbb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbb8:	4770      	bx	lr
 800cbba:	bf00      	nop
 800cbbc:	e000e100 	.word	0xe000e100

0800cbc0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800cbc0:	b480      	push	{r7}
 800cbc2:	b083      	sub	sp, #12
 800cbc4:	af00      	add	r7, sp, #0
 800cbc6:	4603      	mov	r3, r0
 800cbc8:	6039      	str	r1, [r7, #0]
 800cbca:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800cbcc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800cbd0:	2b00      	cmp	r3, #0
 800cbd2:	db0a      	blt.n	800cbea <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800cbd4:	683b      	ldr	r3, [r7, #0]
 800cbd6:	b2da      	uxtb	r2, r3
 800cbd8:	490c      	ldr	r1, [pc, #48]	; (800cc0c <__NVIC_SetPriority+0x4c>)
 800cbda:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800cbde:	0112      	lsls	r2, r2, #4
 800cbe0:	b2d2      	uxtb	r2, r2
 800cbe2:	440b      	add	r3, r1
 800cbe4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 800cbe8:	e00a      	b.n	800cc00 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800cbea:	683b      	ldr	r3, [r7, #0]
 800cbec:	b2da      	uxtb	r2, r3
 800cbee:	4908      	ldr	r1, [pc, #32]	; (800cc10 <__NVIC_SetPriority+0x50>)
 800cbf0:	79fb      	ldrb	r3, [r7, #7]
 800cbf2:	f003 030f 	and.w	r3, r3, #15
 800cbf6:	3b04      	subs	r3, #4
 800cbf8:	0112      	lsls	r2, r2, #4
 800cbfa:	b2d2      	uxtb	r2, r2
 800cbfc:	440b      	add	r3, r1
 800cbfe:	761a      	strb	r2, [r3, #24]
}
 800cc00:	bf00      	nop
 800cc02:	370c      	adds	r7, #12
 800cc04:	46bd      	mov	sp, r7
 800cc06:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc0a:	4770      	bx	lr
 800cc0c:	e000e100 	.word	0xe000e100
 800cc10:	e000ed00 	.word	0xe000ed00

0800cc14 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800cc14:	b480      	push	{r7}
 800cc16:	b089      	sub	sp, #36	; 0x24
 800cc18:	af00      	add	r7, sp, #0
 800cc1a:	60f8      	str	r0, [r7, #12]
 800cc1c:	60b9      	str	r1, [r7, #8]
 800cc1e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800cc20:	68fb      	ldr	r3, [r7, #12]
 800cc22:	f003 0307 	and.w	r3, r3, #7
 800cc26:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800cc28:	69fb      	ldr	r3, [r7, #28]
 800cc2a:	f1c3 0307 	rsb	r3, r3, #7
 800cc2e:	2b04      	cmp	r3, #4
 800cc30:	bf28      	it	cs
 800cc32:	2304      	movcs	r3, #4
 800cc34:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800cc36:	69fb      	ldr	r3, [r7, #28]
 800cc38:	3304      	adds	r3, #4
 800cc3a:	2b06      	cmp	r3, #6
 800cc3c:	d902      	bls.n	800cc44 <NVIC_EncodePriority+0x30>
 800cc3e:	69fb      	ldr	r3, [r7, #28]
 800cc40:	3b03      	subs	r3, #3
 800cc42:	e000      	b.n	800cc46 <NVIC_EncodePriority+0x32>
 800cc44:	2300      	movs	r3, #0
 800cc46:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800cc48:	f04f 32ff 	mov.w	r2, #4294967295
 800cc4c:	69bb      	ldr	r3, [r7, #24]
 800cc4e:	fa02 f303 	lsl.w	r3, r2, r3
 800cc52:	43da      	mvns	r2, r3
 800cc54:	68bb      	ldr	r3, [r7, #8]
 800cc56:	401a      	ands	r2, r3
 800cc58:	697b      	ldr	r3, [r7, #20]
 800cc5a:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800cc5c:	f04f 31ff 	mov.w	r1, #4294967295
 800cc60:	697b      	ldr	r3, [r7, #20]
 800cc62:	fa01 f303 	lsl.w	r3, r1, r3
 800cc66:	43d9      	mvns	r1, r3
 800cc68:	687b      	ldr	r3, [r7, #4]
 800cc6a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800cc6c:	4313      	orrs	r3, r2
         );
}
 800cc6e:	4618      	mov	r0, r3
 800cc70:	3724      	adds	r7, #36	; 0x24
 800cc72:	46bd      	mov	sp, r7
 800cc74:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc78:	4770      	bx	lr

0800cc7a <LL_I2C_EnableClockStretching>:
  * @rmtoll CR1          NOSTRETCH     LL_I2C_EnableClockStretching
  * @param  I2Cx I2C Instance.
  * @retval None
  */
__STATIC_INLINE void LL_I2C_EnableClockStretching(I2C_TypeDef *I2Cx)
{
 800cc7a:	b480      	push	{r7}
 800cc7c:	b083      	sub	sp, #12
 800cc7e:	af00      	add	r7, sp, #0
 800cc80:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
 800cc82:	687b      	ldr	r3, [r7, #4]
 800cc84:	681b      	ldr	r3, [r3, #0]
 800cc86:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800cc8a:	687b      	ldr	r3, [r7, #4]
 800cc8c:	601a      	str	r2, [r3, #0]
}
 800cc8e:	bf00      	nop
 800cc90:	370c      	adds	r7, #12
 800cc92:	46bd      	mov	sp, r7
 800cc94:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc98:	4770      	bx	lr

0800cc9a <LL_I2C_DisableGeneralCall>:
  * @rmtoll CR1          ENGC          LL_I2C_DisableGeneralCall
  * @param  I2Cx I2C Instance.
  * @retval None
  */
__STATIC_INLINE void LL_I2C_DisableGeneralCall(I2C_TypeDef *I2Cx)
{
 800cc9a:	b480      	push	{r7}
 800cc9c:	b083      	sub	sp, #12
 800cc9e:	af00      	add	r7, sp, #0
 800cca0:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(I2Cx->CR1, I2C_CR1_ENGC);
 800cca2:	687b      	ldr	r3, [r7, #4]
 800cca4:	681b      	ldr	r3, [r3, #0]
 800cca6:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 800ccaa:	687b      	ldr	r3, [r7, #4]
 800ccac:	601a      	str	r2, [r3, #0]
}
 800ccae:	bf00      	nop
 800ccb0:	370c      	adds	r7, #12
 800ccb2:	46bd      	mov	sp, r7
 800ccb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ccb8:	4770      	bx	lr

0800ccba <LL_I2C_SetOwnAddress2>:
  * @param  I2Cx I2C Instance.
  * @param  OwnAddress2 This parameter must be a value between Min_Data=0 and Max_Data=0x7F.
  * @retval None
  */
__STATIC_INLINE void LL_I2C_SetOwnAddress2(I2C_TypeDef *I2Cx, uint32_t OwnAddress2)
{
 800ccba:	b480      	push	{r7}
 800ccbc:	b083      	sub	sp, #12
 800ccbe:	af00      	add	r7, sp, #0
 800ccc0:	6078      	str	r0, [r7, #4]
 800ccc2:	6039      	str	r1, [r7, #0]
  MODIFY_REG(I2Cx->OAR2, I2C_OAR2_ADD2, OwnAddress2);
 800ccc4:	687b      	ldr	r3, [r7, #4]
 800ccc6:	68db      	ldr	r3, [r3, #12]
 800ccc8:	f023 02fe 	bic.w	r2, r3, #254	; 0xfe
 800cccc:	683b      	ldr	r3, [r7, #0]
 800ccce:	431a      	orrs	r2, r3
 800ccd0:	687b      	ldr	r3, [r7, #4]
 800ccd2:	60da      	str	r2, [r3, #12]
}
 800ccd4:	bf00      	nop
 800ccd6:	370c      	adds	r7, #12
 800ccd8:	46bd      	mov	sp, r7
 800ccda:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ccde:	4770      	bx	lr

0800cce0 <LL_I2C_DisableOwnAddress2>:
  * @rmtoll OAR2         ENDUAL        LL_I2C_DisableOwnAddress2
  * @param  I2Cx I2C Instance.
  * @retval None
  */
__STATIC_INLINE void LL_I2C_DisableOwnAddress2(I2C_TypeDef *I2Cx)
{
 800cce0:	b480      	push	{r7}
 800cce2:	b083      	sub	sp, #12
 800cce4:	af00      	add	r7, sp, #0
 800cce6:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(I2Cx->OAR2, I2C_OAR2_ENDUAL);
 800cce8:	687b      	ldr	r3, [r7, #4]
 800ccea:	68db      	ldr	r3, [r3, #12]
 800ccec:	f023 0201 	bic.w	r2, r3, #1
 800ccf0:	687b      	ldr	r3, [r7, #4]
 800ccf2:	60da      	str	r2, [r3, #12]
}
 800ccf4:	bf00      	nop
 800ccf6:	370c      	adds	r7, #12
 800ccf8:	46bd      	mov	sp, r7
 800ccfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ccfe:	4770      	bx	lr

0800cd00 <LL_RCC_HSE_Enable>:
  * @brief  Enable HSE crystal oscillator (HSE ON)
  * @rmtoll CR           HSEON         LL_RCC_HSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_Enable(void)
{
 800cd00:	b480      	push	{r7}
 800cd02:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 800cd04:	4b05      	ldr	r3, [pc, #20]	; (800cd1c <LL_RCC_HSE_Enable+0x1c>)
 800cd06:	681b      	ldr	r3, [r3, #0]
 800cd08:	4a04      	ldr	r2, [pc, #16]	; (800cd1c <LL_RCC_HSE_Enable+0x1c>)
 800cd0a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800cd0e:	6013      	str	r3, [r2, #0]
}
 800cd10:	bf00      	nop
 800cd12:	46bd      	mov	sp, r7
 800cd14:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd18:	4770      	bx	lr
 800cd1a:	bf00      	nop
 800cd1c:	40023800 	.word	0x40023800

0800cd20 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
 800cd20:	b480      	push	{r7}
 800cd22:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
 800cd24:	4b07      	ldr	r3, [pc, #28]	; (800cd44 <LL_RCC_HSE_IsReady+0x24>)
 800cd26:	681b      	ldr	r3, [r3, #0]
 800cd28:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800cd2c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800cd30:	bf0c      	ite	eq
 800cd32:	2301      	moveq	r3, #1
 800cd34:	2300      	movne	r3, #0
 800cd36:	b2db      	uxtb	r3, r3
}
 800cd38:	4618      	mov	r0, r3
 800cd3a:	46bd      	mov	sp, r7
 800cd3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd40:	4770      	bx	lr
 800cd42:	bf00      	nop
 800cd44:	40023800 	.word	0x40023800

0800cd48 <LL_RCC_SetSysClkSource>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
{
 800cd48:	b480      	push	{r7}
 800cd4a:	b083      	sub	sp, #12
 800cd4c:	af00      	add	r7, sp, #0
 800cd4e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 800cd50:	4b06      	ldr	r3, [pc, #24]	; (800cd6c <LL_RCC_SetSysClkSource+0x24>)
 800cd52:	689b      	ldr	r3, [r3, #8]
 800cd54:	f023 0203 	bic.w	r2, r3, #3
 800cd58:	4904      	ldr	r1, [pc, #16]	; (800cd6c <LL_RCC_SetSysClkSource+0x24>)
 800cd5a:	687b      	ldr	r3, [r7, #4]
 800cd5c:	4313      	orrs	r3, r2
 800cd5e:	608b      	str	r3, [r1, #8]
}
 800cd60:	bf00      	nop
 800cd62:	370c      	adds	r7, #12
 800cd64:	46bd      	mov	sp, r7
 800cd66:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd6a:	4770      	bx	lr
 800cd6c:	40023800 	.word	0x40023800

0800cd70 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_PLLR (*)
  *
  *         (*) value not defined in all devices.
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
 800cd70:	b480      	push	{r7}
 800cd72:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800cd74:	4b04      	ldr	r3, [pc, #16]	; (800cd88 <LL_RCC_GetSysClkSource+0x18>)
 800cd76:	689b      	ldr	r3, [r3, #8]
 800cd78:	f003 030c 	and.w	r3, r3, #12
}
 800cd7c:	4618      	mov	r0, r3
 800cd7e:	46bd      	mov	sp, r7
 800cd80:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd84:	4770      	bx	lr
 800cd86:	bf00      	nop
 800cd88:	40023800 	.word	0x40023800

0800cd8c <LL_RCC_SetAHBPrescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAHBPrescaler(uint32_t Prescaler)
{
 800cd8c:	b480      	push	{r7}
 800cd8e:	b083      	sub	sp, #12
 800cd90:	af00      	add	r7, sp, #0
 800cd92:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 800cd94:	4b06      	ldr	r3, [pc, #24]	; (800cdb0 <LL_RCC_SetAHBPrescaler+0x24>)
 800cd96:	689b      	ldr	r3, [r3, #8]
 800cd98:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800cd9c:	4904      	ldr	r1, [pc, #16]	; (800cdb0 <LL_RCC_SetAHBPrescaler+0x24>)
 800cd9e:	687b      	ldr	r3, [r7, #4]
 800cda0:	4313      	orrs	r3, r2
 800cda2:	608b      	str	r3, [r1, #8]
}
 800cda4:	bf00      	nop
 800cda6:	370c      	adds	r7, #12
 800cda8:	46bd      	mov	sp, r7
 800cdaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdae:	4770      	bx	lr
 800cdb0:	40023800 	.word	0x40023800

0800cdb4 <LL_RCC_SetAPB1Prescaler>:
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAPB1Prescaler(uint32_t Prescaler)
{
 800cdb4:	b480      	push	{r7}
 800cdb6:	b083      	sub	sp, #12
 800cdb8:	af00      	add	r7, sp, #0
 800cdba:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 800cdbc:	4b06      	ldr	r3, [pc, #24]	; (800cdd8 <LL_RCC_SetAPB1Prescaler+0x24>)
 800cdbe:	689b      	ldr	r3, [r3, #8]
 800cdc0:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 800cdc4:	4904      	ldr	r1, [pc, #16]	; (800cdd8 <LL_RCC_SetAPB1Prescaler+0x24>)
 800cdc6:	687b      	ldr	r3, [r7, #4]
 800cdc8:	4313      	orrs	r3, r2
 800cdca:	608b      	str	r3, [r1, #8]
}
 800cdcc:	bf00      	nop
 800cdce:	370c      	adds	r7, #12
 800cdd0:	46bd      	mov	sp, r7
 800cdd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdd6:	4770      	bx	lr
 800cdd8:	40023800 	.word	0x40023800

0800cddc <LL_RCC_SetAPB2Prescaler>:
  *         @arg @ref LL_RCC_APB2_DIV_8
  *         @arg @ref LL_RCC_APB2_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAPB2Prescaler(uint32_t Prescaler)
{
 800cddc:	b480      	push	{r7}
 800cdde:	b083      	sub	sp, #12
 800cde0:	af00      	add	r7, sp, #0
 800cde2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 800cde4:	4b06      	ldr	r3, [pc, #24]	; (800ce00 <LL_RCC_SetAPB2Prescaler+0x24>)
 800cde6:	689b      	ldr	r3, [r3, #8]
 800cde8:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 800cdec:	4904      	ldr	r1, [pc, #16]	; (800ce00 <LL_RCC_SetAPB2Prescaler+0x24>)
 800cdee:	687b      	ldr	r3, [r7, #4]
 800cdf0:	4313      	orrs	r3, r2
 800cdf2:	608b      	str	r3, [r1, #8]
}
 800cdf4:	bf00      	nop
 800cdf6:	370c      	adds	r7, #12
 800cdf8:	46bd      	mov	sp, r7
 800cdfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdfe:	4770      	bx	lr
 800ce00:	40023800 	.word	0x40023800

0800ce04 <LL_RCC_PLL_Enable>:
  * @brief  Enable PLL
  * @rmtoll CR           PLLON         LL_RCC_PLL_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_Enable(void)
{
 800ce04:	b480      	push	{r7}
 800ce06:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 800ce08:	4b05      	ldr	r3, [pc, #20]	; (800ce20 <LL_RCC_PLL_Enable+0x1c>)
 800ce0a:	681b      	ldr	r3, [r3, #0]
 800ce0c:	4a04      	ldr	r2, [pc, #16]	; (800ce20 <LL_RCC_PLL_Enable+0x1c>)
 800ce0e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800ce12:	6013      	str	r3, [r2, #0]
}
 800ce14:	bf00      	nop
 800ce16:	46bd      	mov	sp, r7
 800ce18:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce1c:	4770      	bx	lr
 800ce1e:	bf00      	nop
 800ce20:	40023800 	.word	0x40023800

0800ce24 <LL_RCC_PLL_IsReady>:
  * @brief  Check if PLL Ready
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
 800ce24:	b480      	push	{r7}
 800ce26:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 800ce28:	4b07      	ldr	r3, [pc, #28]	; (800ce48 <LL_RCC_PLL_IsReady+0x24>)
 800ce2a:	681b      	ldr	r3, [r3, #0]
 800ce2c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800ce30:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800ce34:	bf0c      	ite	eq
 800ce36:	2301      	moveq	r3, #1
 800ce38:	2300      	movne	r3, #0
 800ce3a:	b2db      	uxtb	r3, r3
}
 800ce3c:	4618      	mov	r0, r3
 800ce3e:	46bd      	mov	sp, r7
 800ce40:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce44:	4770      	bx	lr
 800ce46:	bf00      	nop
 800ce48:	40023800 	.word	0x40023800

0800ce4c <LL_RCC_PLL_ConfigDomain_SYS>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP_R)
{
 800ce4c:	b480      	push	{r7}
 800ce4e:	b085      	sub	sp, #20
 800ce50:	af00      	add	r7, sp, #0
 800ce52:	60f8      	str	r0, [r7, #12]
 800ce54:	60b9      	str	r1, [r7, #8]
 800ce56:	607a      	str	r2, [r7, #4]
 800ce58:	603b      	str	r3, [r7, #0]
  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN,
 800ce5a:	4b0d      	ldr	r3, [pc, #52]	; (800ce90 <LL_RCC_PLL_ConfigDomain_SYS+0x44>)
 800ce5c:	685a      	ldr	r2, [r3, #4]
 800ce5e:	4b0d      	ldr	r3, [pc, #52]	; (800ce94 <LL_RCC_PLL_ConfigDomain_SYS+0x48>)
 800ce60:	4013      	ands	r3, r2
 800ce62:	68f9      	ldr	r1, [r7, #12]
 800ce64:	68ba      	ldr	r2, [r7, #8]
 800ce66:	4311      	orrs	r1, r2
 800ce68:	687a      	ldr	r2, [r7, #4]
 800ce6a:	0192      	lsls	r2, r2, #6
 800ce6c:	430a      	orrs	r2, r1
 800ce6e:	4908      	ldr	r1, [pc, #32]	; (800ce90 <LL_RCC_PLL_ConfigDomain_SYS+0x44>)
 800ce70:	4313      	orrs	r3, r2
 800ce72:	604b      	str	r3, [r1, #4]
             Source | PLLM | PLLN << RCC_PLLCFGR_PLLN_Pos);
  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, PLLP_R);
 800ce74:	4b06      	ldr	r3, [pc, #24]	; (800ce90 <LL_RCC_PLL_ConfigDomain_SYS+0x44>)
 800ce76:	685b      	ldr	r3, [r3, #4]
 800ce78:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 800ce7c:	4904      	ldr	r1, [pc, #16]	; (800ce90 <LL_RCC_PLL_ConfigDomain_SYS+0x44>)
 800ce7e:	683b      	ldr	r3, [r7, #0]
 800ce80:	4313      	orrs	r3, r2
 800ce82:	604b      	str	r3, [r1, #4]
#if defined(RCC_PLLR_SYSCLK_SUPPORT)
  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLR, PLLP_R);
#endif /* RCC_PLLR_SYSCLK_SUPPORT */
}
 800ce84:	bf00      	nop
 800ce86:	3714      	adds	r7, #20
 800ce88:	46bd      	mov	sp, r7
 800ce8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce8e:	4770      	bx	lr
 800ce90:	40023800 	.word	0x40023800
 800ce94:	ffbf8000 	.word	0xffbf8000

0800ce98 <LL_RCC_PLLI2S_Enable>:
  * @brief  Enable PLLI2S
  * @rmtoll CR           PLLI2SON     LL_RCC_PLLI2S_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLLI2S_Enable(void)
{
 800ce98:	b480      	push	{r7}
 800ce9a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLI2SON);
 800ce9c:	4b05      	ldr	r3, [pc, #20]	; (800ceb4 <LL_RCC_PLLI2S_Enable+0x1c>)
 800ce9e:	681b      	ldr	r3, [r3, #0]
 800cea0:	4a04      	ldr	r2, [pc, #16]	; (800ceb4 <LL_RCC_PLLI2S_Enable+0x1c>)
 800cea2:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800cea6:	6013      	str	r3, [r2, #0]
}
 800cea8:	bf00      	nop
 800ceaa:	46bd      	mov	sp, r7
 800ceac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ceb0:	4770      	bx	lr
 800ceb2:	bf00      	nop
 800ceb4:	40023800 	.word	0x40023800

0800ceb8 <LL_RCC_PLLI2S_IsReady>:
  * @brief  Check if PLLI2S Ready
  * @rmtoll CR           PLLI2SRDY    LL_RCC_PLLI2S_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLLI2S_IsReady(void)
{
 800ceb8:	b480      	push	{r7}
 800ceba:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) == (RCC_CR_PLLI2SRDY));
 800cebc:	4b07      	ldr	r3, [pc, #28]	; (800cedc <LL_RCC_PLLI2S_IsReady+0x24>)
 800cebe:	681b      	ldr	r3, [r3, #0]
 800cec0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800cec4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800cec8:	bf0c      	ite	eq
 800ceca:	2301      	moveq	r3, #1
 800cecc:	2300      	movne	r3, #0
 800cece:	b2db      	uxtb	r3, r3
}
 800ced0:	4618      	mov	r0, r3
 800ced2:	46bd      	mov	sp, r7
 800ced4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ced8:	4770      	bx	lr
 800ceda:	bf00      	nop
 800cedc:	40023800 	.word	0x40023800

0800cee0 <LL_RCC_PLLI2S_ConfigDomain_I2S>:
  *         @arg @ref LL_RCC_PLLI2SR_DIV_6
  *         @arg @ref LL_RCC_PLLI2SR_DIV_7
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLLI2S_ConfigDomain_I2S(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLR)
{
 800cee0:	b480      	push	{r7}
 800cee2:	b087      	sub	sp, #28
 800cee4:	af00      	add	r7, sp, #0
 800cee6:	60f8      	str	r0, [r7, #12]
 800cee8:	60b9      	str	r1, [r7, #8]
 800ceea:	607a      	str	r2, [r7, #4]
 800ceec:	603b      	str	r3, [r7, #0]
  __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&RCC->PLLCFGR) + (Source & 0x80U)));
 800ceee:	68fb      	ldr	r3, [r7, #12]
 800cef0:	f003 0280 	and.w	r2, r3, #128	; 0x80
 800cef4:	4b13      	ldr	r3, [pc, #76]	; (800cf44 <LL_RCC_PLLI2S_ConfigDomain_I2S+0x64>)
 800cef6:	4413      	add	r3, r2
 800cef8:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*pReg, RCC_PLLCFGR_PLLSRC, (Source & (~0x80U)));
 800cefa:	697b      	ldr	r3, [r7, #20]
 800cefc:	681b      	ldr	r3, [r3, #0]
 800cefe:	f423 0280 	bic.w	r2, r3, #4194304	; 0x400000
 800cf02:	68fb      	ldr	r3, [r7, #12]
 800cf04:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800cf08:	431a      	orrs	r2, r3
 800cf0a:	697b      	ldr	r3, [r7, #20]
 800cf0c:	601a      	str	r2, [r3, #0]
#if defined(RCC_PLLI2SCFGR_PLLI2SM)
  MODIFY_REG(RCC->PLLI2SCFGR, RCC_PLLI2SCFGR_PLLI2SM, PLLM);
#else
  MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLM, PLLM);
 800cf0e:	4b0e      	ldr	r3, [pc, #56]	; (800cf48 <LL_RCC_PLLI2S_ConfigDomain_I2S+0x68>)
 800cf10:	685b      	ldr	r3, [r3, #4]
 800cf12:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
 800cf16:	490c      	ldr	r1, [pc, #48]	; (800cf48 <LL_RCC_PLLI2S_ConfigDomain_I2S+0x68>)
 800cf18:	68bb      	ldr	r3, [r7, #8]
 800cf1a:	4313      	orrs	r3, r2
 800cf1c:	604b      	str	r3, [r1, #4]
#endif /* RCC_PLLI2SCFGR_PLLI2SM */
  MODIFY_REG(RCC->PLLI2SCFGR, RCC_PLLI2SCFGR_PLLI2SN | RCC_PLLI2SCFGR_PLLI2SR, PLLN << RCC_PLLI2SCFGR_PLLI2SN_Pos | PLLR);
 800cf1e:	4b0a      	ldr	r3, [pc, #40]	; (800cf48 <LL_RCC_PLLI2S_ConfigDomain_I2S+0x68>)
 800cf20:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800cf24:	4b09      	ldr	r3, [pc, #36]	; (800cf4c <LL_RCC_PLLI2S_ConfigDomain_I2S+0x6c>)
 800cf26:	4013      	ands	r3, r2
 800cf28:	687a      	ldr	r2, [r7, #4]
 800cf2a:	0191      	lsls	r1, r2, #6
 800cf2c:	683a      	ldr	r2, [r7, #0]
 800cf2e:	430a      	orrs	r2, r1
 800cf30:	4905      	ldr	r1, [pc, #20]	; (800cf48 <LL_RCC_PLLI2S_ConfigDomain_I2S+0x68>)
 800cf32:	4313      	orrs	r3, r2
 800cf34:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
}
 800cf38:	bf00      	nop
 800cf3a:	371c      	adds	r7, #28
 800cf3c:	46bd      	mov	sp, r7
 800cf3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf42:	4770      	bx	lr
 800cf44:	40023804 	.word	0x40023804
 800cf48:	40023800 	.word	0x40023800
 800cf4c:	8fff803f 	.word	0x8fff803f

0800cf50 <LL_AHB1_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
 800cf50:	b480      	push	{r7}
 800cf52:	b085      	sub	sp, #20
 800cf54:	af00      	add	r7, sp, #0
 800cf56:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 800cf58:	4b08      	ldr	r3, [pc, #32]	; (800cf7c <LL_AHB1_GRP1_EnableClock+0x2c>)
 800cf5a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800cf5c:	4907      	ldr	r1, [pc, #28]	; (800cf7c <LL_AHB1_GRP1_EnableClock+0x2c>)
 800cf5e:	687b      	ldr	r3, [r7, #4]
 800cf60:	4313      	orrs	r3, r2
 800cf62:	630b      	str	r3, [r1, #48]	; 0x30
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 800cf64:	4b05      	ldr	r3, [pc, #20]	; (800cf7c <LL_AHB1_GRP1_EnableClock+0x2c>)
 800cf66:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800cf68:	687b      	ldr	r3, [r7, #4]
 800cf6a:	4013      	ands	r3, r2
 800cf6c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800cf6e:	68fb      	ldr	r3, [r7, #12]
}
 800cf70:	bf00      	nop
 800cf72:	3714      	adds	r7, #20
 800cf74:	46bd      	mov	sp, r7
 800cf76:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf7a:	4770      	bx	lr
 800cf7c:	40023800 	.word	0x40023800

0800cf80 <LL_APB1_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
 800cf80:	b480      	push	{r7}
 800cf82:	b085      	sub	sp, #20
 800cf84:	af00      	add	r7, sp, #0
 800cf86:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
 800cf88:	4b08      	ldr	r3, [pc, #32]	; (800cfac <LL_APB1_GRP1_EnableClock+0x2c>)
 800cf8a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cf8c:	4907      	ldr	r1, [pc, #28]	; (800cfac <LL_APB1_GRP1_EnableClock+0x2c>)
 800cf8e:	687b      	ldr	r3, [r7, #4]
 800cf90:	4313      	orrs	r3, r2
 800cf92:	640b      	str	r3, [r1, #64]	; 0x40
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 800cf94:	4b05      	ldr	r3, [pc, #20]	; (800cfac <LL_APB1_GRP1_EnableClock+0x2c>)
 800cf96:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cf98:	687b      	ldr	r3, [r7, #4]
 800cf9a:	4013      	ands	r3, r2
 800cf9c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800cf9e:	68fb      	ldr	r3, [r7, #12]
}
 800cfa0:	bf00      	nop
 800cfa2:	3714      	adds	r7, #20
 800cfa4:	46bd      	mov	sp, r7
 800cfa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfaa:	4770      	bx	lr
 800cfac:	40023800 	.word	0x40023800

0800cfb0 <LL_FLASH_SetLatency>:
  *         @arg @ref LL_FLASH_LATENCY_14
  *         @arg @ref LL_FLASH_LATENCY_15
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_SetLatency(uint32_t Latency)
{
 800cfb0:	b480      	push	{r7}
 800cfb2:	b083      	sub	sp, #12
 800cfb4:	af00      	add	r7, sp, #0
 800cfb6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 800cfb8:	4b06      	ldr	r3, [pc, #24]	; (800cfd4 <LL_FLASH_SetLatency+0x24>)
 800cfba:	681b      	ldr	r3, [r3, #0]
 800cfbc:	f023 0207 	bic.w	r2, r3, #7
 800cfc0:	4904      	ldr	r1, [pc, #16]	; (800cfd4 <LL_FLASH_SetLatency+0x24>)
 800cfc2:	687b      	ldr	r3, [r7, #4]
 800cfc4:	4313      	orrs	r3, r2
 800cfc6:	600b      	str	r3, [r1, #0]
}
 800cfc8:	bf00      	nop
 800cfca:	370c      	adds	r7, #12
 800cfcc:	46bd      	mov	sp, r7
 800cfce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfd2:	4770      	bx	lr
 800cfd4:	40023c00 	.word	0x40023c00

0800cfd8 <LL_FLASH_GetLatency>:
  *         @arg @ref LL_FLASH_LATENCY_13
  *         @arg @ref LL_FLASH_LATENCY_14
  *         @arg @ref LL_FLASH_LATENCY_15
  */
__STATIC_INLINE uint32_t LL_FLASH_GetLatency(void)
{
 800cfd8:	b480      	push	{r7}
 800cfda:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 800cfdc:	4b04      	ldr	r3, [pc, #16]	; (800cff0 <LL_FLASH_GetLatency+0x18>)
 800cfde:	681b      	ldr	r3, [r3, #0]
 800cfe0:	f003 0307 	and.w	r3, r3, #7
}
 800cfe4:	4618      	mov	r0, r3
 800cfe6:	46bd      	mov	sp, r7
 800cfe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfec:	4770      	bx	lr
 800cfee:	bf00      	nop
 800cff0:	40023c00 	.word	0x40023c00

0800cff4 <LL_PWR_SetRegulVoltageScaling>:
  *         @arg @ref LL_PWR_REGU_VOLTAGE_SCALE3
  *         (*) LL_PWR_REGU_VOLTAGE_SCALE1 is not available for STM32F401xx devices
  * @retval None
  */
__STATIC_INLINE void LL_PWR_SetRegulVoltageScaling(uint32_t VoltageScaling)
{
 800cff4:	b480      	push	{r7}
 800cff6:	b083      	sub	sp, #12
 800cff8:	af00      	add	r7, sp, #0
 800cffa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(PWR->CR, PWR_CR_VOS, VoltageScaling);
 800cffc:	4b06      	ldr	r3, [pc, #24]	; (800d018 <LL_PWR_SetRegulVoltageScaling+0x24>)
 800cffe:	681b      	ldr	r3, [r3, #0]
 800d000:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
 800d004:	4904      	ldr	r1, [pc, #16]	; (800d018 <LL_PWR_SetRegulVoltageScaling+0x24>)
 800d006:	687b      	ldr	r3, [r7, #4]
 800d008:	4313      	orrs	r3, r2
 800d00a:	600b      	str	r3, [r1, #0]
}
 800d00c:	bf00      	nop
 800d00e:	370c      	adds	r7, #12
 800d010:	46bd      	mov	sp, r7
 800d012:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d016:	4770      	bx	lr
 800d018:	40007000 	.word	0x40007000

0800d01c <LL_PWR_IsActiveFlag_VOS>:
  * @brief  Indicate whether the Regulator is ready in the selected voltage range or if its output voltage is still changing to the required voltage level
  * @rmtoll CSR   VOS       LL_PWR_IsActiveFlag_VOS
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_PWR_IsActiveFlag_VOS(void)
{
 800d01c:	b480      	push	{r7}
 800d01e:	af00      	add	r7, sp, #0
  return (READ_BIT(PWR->CSR, LL_PWR_CSR_VOS) == (LL_PWR_CSR_VOS));
 800d020:	4b07      	ldr	r3, [pc, #28]	; (800d040 <LL_PWR_IsActiveFlag_VOS+0x24>)
 800d022:	685b      	ldr	r3, [r3, #4]
 800d024:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800d028:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800d02c:	bf0c      	ite	eq
 800d02e:	2301      	moveq	r3, #1
 800d030:	2300      	movne	r3, #0
 800d032:	b2db      	uxtb	r3, r3
}
 800d034:	4618      	mov	r0, r3
 800d036:	46bd      	mov	sp, r7
 800d038:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d03c:	4770      	bx	lr
 800d03e:	bf00      	nop
 800d040:	40007000 	.word	0x40007000

0800d044 <LL_TIM_EnableCounter>:
  * @rmtoll CR1          CEN           LL_TIM_EnableCounter
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_EnableCounter(TIM_TypeDef *TIMx)
{
 800d044:	b480      	push	{r7}
 800d046:	b083      	sub	sp, #12
 800d048:	af00      	add	r7, sp, #0
 800d04a:	6078      	str	r0, [r7, #4]
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 800d04c:	687b      	ldr	r3, [r7, #4]
 800d04e:	681b      	ldr	r3, [r3, #0]
 800d050:	f043 0201 	orr.w	r2, r3, #1
 800d054:	687b      	ldr	r3, [r7, #4]
 800d056:	601a      	str	r2, [r3, #0]
}
 800d058:	bf00      	nop
 800d05a:	370c      	adds	r7, #12
 800d05c:	46bd      	mov	sp, r7
 800d05e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d062:	4770      	bx	lr

0800d064 <LL_TIM_DisableARRPreload>:
  * @rmtoll CR1          ARPE          LL_TIM_DisableARRPreload
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_DisableARRPreload(TIM_TypeDef *TIMx)
{
 800d064:	b480      	push	{r7}
 800d066:	b083      	sub	sp, #12
 800d068:	af00      	add	r7, sp, #0
 800d06a:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
 800d06c:	687b      	ldr	r3, [r7, #4]
 800d06e:	681b      	ldr	r3, [r3, #0]
 800d070:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800d074:	687b      	ldr	r3, [r7, #4]
 800d076:	601a      	str	r2, [r3, #0]
}
 800d078:	bf00      	nop
 800d07a:	370c      	adds	r7, #12
 800d07c:	46bd      	mov	sp, r7
 800d07e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d082:	4770      	bx	lr

0800d084 <LL_TIM_OC_DisableFast>:
  *         @arg @ref LL_TIM_CHANNEL_CH3
  *         @arg @ref LL_TIM_CHANNEL_CH4
  * @retval None
  */
__STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
{
 800d084:	b480      	push	{r7}
 800d086:	b085      	sub	sp, #20
 800d088:	af00      	add	r7, sp, #0
 800d08a:	6078      	str	r0, [r7, #4]
 800d08c:	6039      	str	r1, [r7, #0]
  uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
 800d08e:	683b      	ldr	r3, [r7, #0]
 800d090:	2b01      	cmp	r3, #1
 800d092:	d01c      	beq.n	800d0ce <LL_TIM_OC_DisableFast+0x4a>
 800d094:	683b      	ldr	r3, [r7, #0]
 800d096:	2b04      	cmp	r3, #4
 800d098:	d017      	beq.n	800d0ca <LL_TIM_OC_DisableFast+0x46>
 800d09a:	683b      	ldr	r3, [r7, #0]
 800d09c:	2b10      	cmp	r3, #16
 800d09e:	d012      	beq.n	800d0c6 <LL_TIM_OC_DisableFast+0x42>
 800d0a0:	683b      	ldr	r3, [r7, #0]
 800d0a2:	2b40      	cmp	r3, #64	; 0x40
 800d0a4:	d00d      	beq.n	800d0c2 <LL_TIM_OC_DisableFast+0x3e>
 800d0a6:	683b      	ldr	r3, [r7, #0]
 800d0a8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d0ac:	d007      	beq.n	800d0be <LL_TIM_OC_DisableFast+0x3a>
 800d0ae:	683b      	ldr	r3, [r7, #0]
 800d0b0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800d0b4:	d101      	bne.n	800d0ba <LL_TIM_OC_DisableFast+0x36>
 800d0b6:	2305      	movs	r3, #5
 800d0b8:	e00a      	b.n	800d0d0 <LL_TIM_OC_DisableFast+0x4c>
 800d0ba:	2306      	movs	r3, #6
 800d0bc:	e008      	b.n	800d0d0 <LL_TIM_OC_DisableFast+0x4c>
 800d0be:	2304      	movs	r3, #4
 800d0c0:	e006      	b.n	800d0d0 <LL_TIM_OC_DisableFast+0x4c>
 800d0c2:	2303      	movs	r3, #3
 800d0c4:	e004      	b.n	800d0d0 <LL_TIM_OC_DisableFast+0x4c>
 800d0c6:	2302      	movs	r3, #2
 800d0c8:	e002      	b.n	800d0d0 <LL_TIM_OC_DisableFast+0x4c>
 800d0ca:	2301      	movs	r3, #1
 800d0cc:	e000      	b.n	800d0d0 <LL_TIM_OC_DisableFast+0x4c>
 800d0ce:	2300      	movs	r3, #0
 800d0d0:	73fb      	strb	r3, [r7, #15]
  __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 800d0d2:	687b      	ldr	r3, [r7, #4]
 800d0d4:	3318      	adds	r3, #24
 800d0d6:	4619      	mov	r1, r3
 800d0d8:	7bfb      	ldrb	r3, [r7, #15]
 800d0da:	4a0b      	ldr	r2, [pc, #44]	; (800d108 <LL_TIM_OC_DisableFast+0x84>)
 800d0dc:	5cd3      	ldrb	r3, [r2, r3]
 800d0de:	440b      	add	r3, r1
 800d0e0:	60bb      	str	r3, [r7, #8]
  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
 800d0e2:	68bb      	ldr	r3, [r7, #8]
 800d0e4:	681a      	ldr	r2, [r3, #0]
 800d0e6:	7bfb      	ldrb	r3, [r7, #15]
 800d0e8:	4908      	ldr	r1, [pc, #32]	; (800d10c <LL_TIM_OC_DisableFast+0x88>)
 800d0ea:	5ccb      	ldrb	r3, [r1, r3]
 800d0ec:	4619      	mov	r1, r3
 800d0ee:	2304      	movs	r3, #4
 800d0f0:	408b      	lsls	r3, r1
 800d0f2:	43db      	mvns	r3, r3
 800d0f4:	401a      	ands	r2, r3
 800d0f6:	68bb      	ldr	r3, [r7, #8]
 800d0f8:	601a      	str	r2, [r3, #0]

}
 800d0fa:	bf00      	nop
 800d0fc:	3714      	adds	r7, #20
 800d0fe:	46bd      	mov	sp, r7
 800d100:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d104:	4770      	bx	lr
 800d106:	bf00      	nop
 800d108:	08010240 	.word	0x08010240
 800d10c:	08010248 	.word	0x08010248

0800d110 <LL_TIM_OC_EnablePreload>:
  *         @arg @ref LL_TIM_CHANNEL_CH3
  *         @arg @ref LL_TIM_CHANNEL_CH4
  * @retval None
  */
__STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
{
 800d110:	b480      	push	{r7}
 800d112:	b085      	sub	sp, #20
 800d114:	af00      	add	r7, sp, #0
 800d116:	6078      	str	r0, [r7, #4]
 800d118:	6039      	str	r1, [r7, #0]
  uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
 800d11a:	683b      	ldr	r3, [r7, #0]
 800d11c:	2b01      	cmp	r3, #1
 800d11e:	d01c      	beq.n	800d15a <LL_TIM_OC_EnablePreload+0x4a>
 800d120:	683b      	ldr	r3, [r7, #0]
 800d122:	2b04      	cmp	r3, #4
 800d124:	d017      	beq.n	800d156 <LL_TIM_OC_EnablePreload+0x46>
 800d126:	683b      	ldr	r3, [r7, #0]
 800d128:	2b10      	cmp	r3, #16
 800d12a:	d012      	beq.n	800d152 <LL_TIM_OC_EnablePreload+0x42>
 800d12c:	683b      	ldr	r3, [r7, #0]
 800d12e:	2b40      	cmp	r3, #64	; 0x40
 800d130:	d00d      	beq.n	800d14e <LL_TIM_OC_EnablePreload+0x3e>
 800d132:	683b      	ldr	r3, [r7, #0]
 800d134:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d138:	d007      	beq.n	800d14a <LL_TIM_OC_EnablePreload+0x3a>
 800d13a:	683b      	ldr	r3, [r7, #0]
 800d13c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800d140:	d101      	bne.n	800d146 <LL_TIM_OC_EnablePreload+0x36>
 800d142:	2305      	movs	r3, #5
 800d144:	e00a      	b.n	800d15c <LL_TIM_OC_EnablePreload+0x4c>
 800d146:	2306      	movs	r3, #6
 800d148:	e008      	b.n	800d15c <LL_TIM_OC_EnablePreload+0x4c>
 800d14a:	2304      	movs	r3, #4
 800d14c:	e006      	b.n	800d15c <LL_TIM_OC_EnablePreload+0x4c>
 800d14e:	2303      	movs	r3, #3
 800d150:	e004      	b.n	800d15c <LL_TIM_OC_EnablePreload+0x4c>
 800d152:	2302      	movs	r3, #2
 800d154:	e002      	b.n	800d15c <LL_TIM_OC_EnablePreload+0x4c>
 800d156:	2301      	movs	r3, #1
 800d158:	e000      	b.n	800d15c <LL_TIM_OC_EnablePreload+0x4c>
 800d15a:	2300      	movs	r3, #0
 800d15c:	73fb      	strb	r3, [r7, #15]
  __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 800d15e:	687b      	ldr	r3, [r7, #4]
 800d160:	3318      	adds	r3, #24
 800d162:	4619      	mov	r1, r3
 800d164:	7bfb      	ldrb	r3, [r7, #15]
 800d166:	4a0a      	ldr	r2, [pc, #40]	; (800d190 <LL_TIM_OC_EnablePreload+0x80>)
 800d168:	5cd3      	ldrb	r3, [r2, r3]
 800d16a:	440b      	add	r3, r1
 800d16c:	60bb      	str	r3, [r7, #8]
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 800d16e:	68bb      	ldr	r3, [r7, #8]
 800d170:	681a      	ldr	r2, [r3, #0]
 800d172:	7bfb      	ldrb	r3, [r7, #15]
 800d174:	4907      	ldr	r1, [pc, #28]	; (800d194 <LL_TIM_OC_EnablePreload+0x84>)
 800d176:	5ccb      	ldrb	r3, [r1, r3]
 800d178:	4619      	mov	r1, r3
 800d17a:	2308      	movs	r3, #8
 800d17c:	408b      	lsls	r3, r1
 800d17e:	431a      	orrs	r2, r3
 800d180:	68bb      	ldr	r3, [r7, #8]
 800d182:	601a      	str	r2, [r3, #0]
}
 800d184:	bf00      	nop
 800d186:	3714      	adds	r7, #20
 800d188:	46bd      	mov	sp, r7
 800d18a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d18e:	4770      	bx	lr
 800d190:	08010240 	.word	0x08010240
 800d194:	08010248 	.word	0x08010248

0800d198 <LL_TIM_SetClockSource>:
  *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
  *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
{
 800d198:	b480      	push	{r7}
 800d19a:	b083      	sub	sp, #12
 800d19c:	af00      	add	r7, sp, #0
 800d19e:	6078      	str	r0, [r7, #4]
 800d1a0:	6039      	str	r1, [r7, #0]
  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
 800d1a2:	687b      	ldr	r3, [r7, #4]
 800d1a4:	689b      	ldr	r3, [r3, #8]
 800d1a6:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800d1aa:	f023 0307 	bic.w	r3, r3, #7
 800d1ae:	683a      	ldr	r2, [r7, #0]
 800d1b0:	431a      	orrs	r2, r3
 800d1b2:	687b      	ldr	r3, [r7, #4]
 800d1b4:	609a      	str	r2, [r3, #8]
}
 800d1b6:	bf00      	nop
 800d1b8:	370c      	adds	r7, #12
 800d1ba:	46bd      	mov	sp, r7
 800d1bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1c0:	4770      	bx	lr

0800d1c2 <LL_TIM_SetTriggerOutput>:
  *         @arg @ref LL_TIM_TRGO_OC3REF
  *         @arg @ref LL_TIM_TRGO_OC4REF
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
{
 800d1c2:	b480      	push	{r7}
 800d1c4:	b083      	sub	sp, #12
 800d1c6:	af00      	add	r7, sp, #0
 800d1c8:	6078      	str	r0, [r7, #4]
 800d1ca:	6039      	str	r1, [r7, #0]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800d1cc:	687b      	ldr	r3, [r7, #4]
 800d1ce:	685b      	ldr	r3, [r3, #4]
 800d1d0:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 800d1d4:	683b      	ldr	r3, [r7, #0]
 800d1d6:	431a      	orrs	r2, r3
 800d1d8:	687b      	ldr	r3, [r7, #4]
 800d1da:	605a      	str	r2, [r3, #4]
}
 800d1dc:	bf00      	nop
 800d1de:	370c      	adds	r7, #12
 800d1e0:	46bd      	mov	sp, r7
 800d1e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1e6:	4770      	bx	lr

0800d1e8 <LL_TIM_DisableMasterSlaveMode>:
  * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
{
 800d1e8:	b480      	push	{r7}
 800d1ea:	b083      	sub	sp, #12
 800d1ec:	af00      	add	r7, sp, #0
 800d1ee:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
 800d1f0:	687b      	ldr	r3, [r7, #4]
 800d1f2:	689b      	ldr	r3, [r3, #8]
 800d1f4:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800d1f8:	687b      	ldr	r3, [r7, #4]
 800d1fa:	609a      	str	r2, [r3, #8]
}
 800d1fc:	bf00      	nop
 800d1fe:	370c      	adds	r7, #12
 800d200:	46bd      	mov	sp, r7
 800d202:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d206:	4770      	bx	lr

0800d208 <LL_TIM_EnableIT_UPDATE>:
  * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
{
 800d208:	b480      	push	{r7}
 800d20a:	b083      	sub	sp, #12
 800d20c:	af00      	add	r7, sp, #0
 800d20e:	6078      	str	r0, [r7, #4]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 800d210:	687b      	ldr	r3, [r7, #4]
 800d212:	68db      	ldr	r3, [r3, #12]
 800d214:	f043 0201 	orr.w	r2, r3, #1
 800d218:	687b      	ldr	r3, [r7, #4]
 800d21a:	60da      	str	r2, [r3, #12]
}
 800d21c:	bf00      	nop
 800d21e:	370c      	adds	r7, #12
 800d220:	46bd      	mov	sp, r7
 800d222:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d226:	4770      	bx	lr

0800d228 <LL_GPIO_ResetOutputPin>:
  *         @arg @ref LL_GPIO_PIN_15
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
 800d228:	b480      	push	{r7}
 800d22a:	b083      	sub	sp, #12
 800d22c:	af00      	add	r7, sp, #0
 800d22e:	6078      	str	r0, [r7, #4]
 800d230:	6039      	str	r1, [r7, #0]
  WRITE_REG(GPIOx->BSRR, (PinMask << 16));
 800d232:	683b      	ldr	r3, [r7, #0]
 800d234:	041a      	lsls	r2, r3, #16
 800d236:	687b      	ldr	r3, [r7, #4]
 800d238:	619a      	str	r2, [r3, #24]
}
 800d23a:	bf00      	nop
 800d23c:	370c      	adds	r7, #12
 800d23e:	46bd      	mov	sp, r7
 800d240:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d244:	4770      	bx	lr
	...

0800d248 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800d248:	b580      	push	{r7, lr}
 800d24a:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800d24c:	f000 fce6 	bl	800dc1c <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800d250:	f000 f82e 	bl	800d2b0 <SystemClock_Config>

/* Configure the peripherals common clocks */
  PeriphCommonClock_Config();
 800d254:	f000 f87c 	bl	800d350 <PeriphCommonClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800d258:	f000 f9de 	bl	800d618 <MX_GPIO_Init>
  MX_DMA_Init();
 800d25c:	f000 f9cc 	bl	800d5f8 <MX_DMA_Init>
  MX_I2C1_Init();
 800d260:	f000 f8b6 	bl	800d3d0 <MX_I2C1_Init>
  MX_I2S3_Init();
 800d264:	f000 f90c 	bl	800d480 <MX_I2S3_Init>
  MX_DAC_Init();
 800d268:	f000 f888 	bl	800d37c <MX_DAC_Init>
  MX_TIM3_Init();
 800d26c:	f000 f936 	bl	800d4dc <MX_TIM3_Init>
  /* USER CODE BEGIN 2 */
  LoadAudioFiles();
 800d270:	f000 fa08 	bl	800d684 <LoadAudioFiles>
#ifdef USE_DAC
	HAL_DAC_Start(&hdac1, DAC_CHANNEL_1);
	HAL_DAC_SetValue(&hdac1, DAC_CHANNEL_1, DAC_ALIGN_12B_R, 0x7FF);
#endif
	// capture/compare registers (CC1 PWM duty 50%)
	TIM3->CCR1 = DEFAULT_STARTUP_VAL;
 800d274:	4b0d      	ldr	r3, [pc, #52]	; (800d2ac <main+0x64>)
 800d276:	2280      	movs	r2, #128	; 0x80
 800d278:	635a      	str	r2, [r3, #52]	; 0x34
	TIM3->CCR2 = DEFAULT_STARTUP_VAL;
 800d27a:	4b0c      	ldr	r3, [pc, #48]	; (800d2ac <main+0x64>)
 800d27c:	2280      	movs	r2, #128	; 0x80
 800d27e:	639a      	str	r2, [r3, #56]	; 0x38
	LL_TIM_EnableIT_UPDATE(TIM3);
 800d280:	480a      	ldr	r0, [pc, #40]	; (800d2ac <main+0x64>)
 800d282:	f7ff ffc1 	bl	800d208 <LL_TIM_EnableIT_UPDATE>
	TIM3->CCER |= TIM_CCER_CC2E | TIM_CCER_CC1E;
 800d286:	4b09      	ldr	r3, [pc, #36]	; (800d2ac <main+0x64>)
 800d288:	6a1b      	ldr	r3, [r3, #32]
 800d28a:	4a08      	ldr	r2, [pc, #32]	; (800d2ac <main+0x64>)
 800d28c:	f043 0311 	orr.w	r3, r3, #17
 800d290:	6213      	str	r3, [r2, #32]
	LL_TIM_EnableCounter(TIM3);
 800d292:	4806      	ldr	r0, [pc, #24]	; (800d2ac <main+0x64>)
 800d294:	f7ff fed6 	bl	800d044 <LL_TIM_EnableCounter>
//			/* Disable the TIM3 Interrupt */
//			NVIC_EnableIRQ(TIM3_IRQn);
//			// stop the timer
//			LL_TIM_EnableCounter(TIM3);
//		}
		NVIC_EnableIRQ(TIM3_IRQn); //trying these three instructions
 800d298:	201d      	movs	r0, #29
 800d29a:	f7ff fc73 	bl	800cb84 <__NVIC_EnableIRQ>
		LL_TIM_EnableCounter(TIM3);
 800d29e:	4803      	ldr	r0, [pc, #12]	; (800d2ac <main+0x64>)
 800d2a0:	f7ff fed0 	bl	800d044 <LL_TIM_EnableCounter>
		HAL_Delay(100);
 800d2a4:	2064      	movs	r0, #100	; 0x64
 800d2a6:	f000 fd2b 	bl	800dd00 <HAL_Delay>
		NVIC_EnableIRQ(TIM3_IRQn); //trying these three instructions
 800d2aa:	e7f5      	b.n	800d298 <main+0x50>
 800d2ac:	40000400 	.word	0x40000400

0800d2b0 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800d2b0:	b580      	push	{r7, lr}
 800d2b2:	af00      	add	r7, sp, #0
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
 800d2b4:	2002      	movs	r0, #2
 800d2b6:	f7ff fe7b 	bl	800cfb0 <LL_FLASH_SetLatency>
  while(LL_FLASH_GetLatency()!= LL_FLASH_LATENCY_2)
 800d2ba:	bf00      	nop
 800d2bc:	f7ff fe8c 	bl	800cfd8 <LL_FLASH_GetLatency>
 800d2c0:	4603      	mov	r3, r0
 800d2c2:	2b02      	cmp	r3, #2
 800d2c4:	d1fa      	bne.n	800d2bc <SystemClock_Config+0xc>
  {
  }
  LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);
 800d2c6:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800d2ca:	f7ff fe93 	bl	800cff4 <LL_PWR_SetRegulVoltageScaling>
  LL_RCC_HSE_Enable();
 800d2ce:	f7ff fd17 	bl	800cd00 <LL_RCC_HSE_Enable>

   /* Wait till HSE is ready */
  while(LL_RCC_HSE_IsReady() != 1)
 800d2d2:	bf00      	nop
 800d2d4:	f7ff fd24 	bl	800cd20 <LL_RCC_HSE_IsReady>
 800d2d8:	4603      	mov	r3, r0
 800d2da:	2b01      	cmp	r3, #1
 800d2dc:	d1fa      	bne.n	800d2d4 <SystemClock_Config+0x24>
  {

  }
  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, LL_RCC_PLLM_DIV_4, 64, LL_RCC_PLLP_DIV_2);
 800d2de:	2300      	movs	r3, #0
 800d2e0:	2240      	movs	r2, #64	; 0x40
 800d2e2:	2104      	movs	r1, #4
 800d2e4:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800d2e8:	f7ff fdb0 	bl	800ce4c <LL_RCC_PLL_ConfigDomain_SYS>
  LL_RCC_PLL_Enable();
 800d2ec:	f7ff fd8a 	bl	800ce04 <LL_RCC_PLL_Enable>

   /* Wait till PLL is ready */
  while(LL_RCC_PLL_IsReady() != 1)
 800d2f0:	bf00      	nop
 800d2f2:	f7ff fd97 	bl	800ce24 <LL_RCC_PLL_IsReady>
 800d2f6:	4603      	mov	r3, r0
 800d2f8:	2b01      	cmp	r3, #1
 800d2fa:	d1fa      	bne.n	800d2f2 <SystemClock_Config+0x42>
  {

  }
  while (LL_PWR_IsActiveFlag_VOS() == 0)
 800d2fc:	bf00      	nop
 800d2fe:	f7ff fe8d 	bl	800d01c <LL_PWR_IsActiveFlag_VOS>
 800d302:	4603      	mov	r3, r0
 800d304:	2b00      	cmp	r3, #0
 800d306:	d0fa      	beq.n	800d2fe <SystemClock_Config+0x4e>
  {
  }
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
 800d308:	2000      	movs	r0, #0
 800d30a:	f7ff fd3f 	bl	800cd8c <LL_RCC_SetAHBPrescaler>
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_2);
 800d30e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800d312:	f7ff fd4f 	bl	800cdb4 <LL_RCC_SetAPB1Prescaler>
  LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_2);
 800d316:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800d31a:	f7ff fd5f 	bl	800cddc <LL_RCC_SetAPB2Prescaler>
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
 800d31e:	2002      	movs	r0, #2
 800d320:	f7ff fd12 	bl	800cd48 <LL_RCC_SetSysClkSource>

   /* Wait till System clock is ready */
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
 800d324:	bf00      	nop
 800d326:	f7ff fd23 	bl	800cd70 <LL_RCC_GetSysClkSource>
 800d32a:	4603      	mov	r3, r0
 800d32c:	2b08      	cmp	r3, #8
 800d32e:	d1fa      	bne.n	800d326 <SystemClock_Config+0x76>
  {

  }
  LL_SetSystemCoreClock(64000000);
 800d330:	4806      	ldr	r0, [pc, #24]	; (800d34c <SystemClock_Config+0x9c>)
 800d332:	f002 fedb 	bl	80100ec <LL_SetSystemCoreClock>

   /* Update the time base */
  if (HAL_InitTick (TICK_INT_PRIORITY) != HAL_OK)
 800d336:	2000      	movs	r0, #0
 800d338:	f000 fc92 	bl	800dc60 <HAL_InitTick>
 800d33c:	4603      	mov	r3, r0
 800d33e:	2b00      	cmp	r3, #0
 800d340:	d001      	beq.n	800d346 <SystemClock_Config+0x96>
  {
    Error_Handler();
 800d342:	f000 f9b1 	bl	800d6a8 <Error_Handler>
  }
}
 800d346:	bf00      	nop
 800d348:	bd80      	pop	{r7, pc}
 800d34a:	bf00      	nop
 800d34c:	03d09000 	.word	0x03d09000

0800d350 <PeriphCommonClock_Config>:
/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
 800d350:	b580      	push	{r7, lr}
 800d352:	af00      	add	r7, sp, #0
  LL_RCC_PLLI2S_ConfigDomain_I2S(LL_RCC_PLLSOURCE_HSE, LL_RCC_PLLI2SM_DIV_4, 50, LL_RCC_PLLI2SR_DIV_2);
 800d354:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 800d358:	2232      	movs	r2, #50	; 0x32
 800d35a:	2104      	movs	r1, #4
 800d35c:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800d360:	f7ff fdbe 	bl	800cee0 <LL_RCC_PLLI2S_ConfigDomain_I2S>
  LL_RCC_PLLI2S_Enable();
 800d364:	f7ff fd98 	bl	800ce98 <LL_RCC_PLLI2S_Enable>

   /* Wait till PLL is ready */
  while(LL_RCC_PLLI2S_IsReady() != 1)
 800d368:	bf00      	nop
 800d36a:	f7ff fda5 	bl	800ceb8 <LL_RCC_PLLI2S_IsReady>
 800d36e:	4603      	mov	r3, r0
 800d370:	2b01      	cmp	r3, #1
 800d372:	d1fa      	bne.n	800d36a <PeriphCommonClock_Config+0x1a>
  {

  }
}
 800d374:	bf00      	nop
 800d376:	bf00      	nop
 800d378:	bd80      	pop	{r7, pc}
	...

0800d37c <MX_DAC_Init>:
  * @brief DAC Initialization Function
  * @param None
  * @retval None
  */
static void MX_DAC_Init(void)
{
 800d37c:	b580      	push	{r7, lr}
 800d37e:	b082      	sub	sp, #8
 800d380:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN DAC_Init 0 */

  /* USER CODE END DAC_Init 0 */

  DAC_ChannelConfTypeDef sConfig = {0};
 800d382:	463b      	mov	r3, r7
 800d384:	2200      	movs	r2, #0
 800d386:	601a      	str	r2, [r3, #0]
 800d388:	605a      	str	r2, [r3, #4]

  /* USER CODE END DAC_Init 1 */

  /** DAC Initialization
  */
  hdac.Instance = DAC;
 800d38a:	4b0f      	ldr	r3, [pc, #60]	; (800d3c8 <MX_DAC_Init+0x4c>)
 800d38c:	4a0f      	ldr	r2, [pc, #60]	; (800d3cc <MX_DAC_Init+0x50>)
 800d38e:	601a      	str	r2, [r3, #0]
  if (HAL_DAC_Init(&hdac) != HAL_OK)
 800d390:	480d      	ldr	r0, [pc, #52]	; (800d3c8 <MX_DAC_Init+0x4c>)
 800d392:	f000 fdea 	bl	800df6a <HAL_DAC_Init>
 800d396:	4603      	mov	r3, r0
 800d398:	2b00      	cmp	r3, #0
 800d39a:	d001      	beq.n	800d3a0 <MX_DAC_Init+0x24>
  {
    Error_Handler();
 800d39c:	f000 f984 	bl	800d6a8 <Error_Handler>
  }

  /** DAC channel OUT1 config
  */
  sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
 800d3a0:	2300      	movs	r3, #0
 800d3a2:	603b      	str	r3, [r7, #0]
  sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
 800d3a4:	2300      	movs	r3, #0
 800d3a6:	607b      	str	r3, [r7, #4]
  if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 800d3a8:	463b      	mov	r3, r7
 800d3aa:	2200      	movs	r2, #0
 800d3ac:	4619      	mov	r1, r3
 800d3ae:	4806      	ldr	r0, [pc, #24]	; (800d3c8 <MX_DAC_Init+0x4c>)
 800d3b0:	f000 fdfd 	bl	800dfae <HAL_DAC_ConfigChannel>
 800d3b4:	4603      	mov	r3, r0
 800d3b6:	2b00      	cmp	r3, #0
 800d3b8:	d001      	beq.n	800d3be <MX_DAC_Init+0x42>
  {
    Error_Handler();
 800d3ba:	f000 f975 	bl	800d6a8 <Error_Handler>
  }
  /* USER CODE BEGIN DAC_Init 2 */

  /* USER CODE END DAC_Init 2 */

}
 800d3be:	bf00      	nop
 800d3c0:	3708      	adds	r7, #8
 800d3c2:	46bd      	mov	sp, r7
 800d3c4:	bd80      	pop	{r7, pc}
 800d3c6:	bf00      	nop
 800d3c8:	20000034 	.word	0x20000034
 800d3cc:	40007400 	.word	0x40007400

0800d3d0 <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
 800d3d0:	b580      	push	{r7, lr}
 800d3d2:	b08c      	sub	sp, #48	; 0x30
 800d3d4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  LL_I2C_InitTypeDef I2C_InitStruct = {0};
 800d3d6:	f107 0318 	add.w	r3, r7, #24
 800d3da:	2200      	movs	r2, #0
 800d3dc:	601a      	str	r2, [r3, #0]
 800d3de:	605a      	str	r2, [r3, #4]
 800d3e0:	609a      	str	r2, [r3, #8]
 800d3e2:	60da      	str	r2, [r3, #12]
 800d3e4:	611a      	str	r2, [r3, #16]
 800d3e6:	615a      	str	r2, [r3, #20]

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 800d3e8:	463b      	mov	r3, r7
 800d3ea:	2200      	movs	r2, #0
 800d3ec:	601a      	str	r2, [r3, #0]
 800d3ee:	605a      	str	r2, [r3, #4]
 800d3f0:	609a      	str	r2, [r3, #8]
 800d3f2:	60da      	str	r2, [r3, #12]
 800d3f4:	611a      	str	r2, [r3, #16]
 800d3f6:	615a      	str	r2, [r3, #20]

  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);
 800d3f8:	2002      	movs	r0, #2
 800d3fa:	f7ff fda9 	bl	800cf50 <LL_AHB1_GRP1_EnableClock>
  /**I2C1 GPIO Configuration
  PB6   ------> I2C1_SCL
  PB9   ------> I2C1_SDA
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_6|LL_GPIO_PIN_9;
 800d3fe:	f44f 7310 	mov.w	r3, #576	; 0x240
 800d402:	603b      	str	r3, [r7, #0]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 800d404:	2302      	movs	r3, #2
 800d406:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 800d408:	2303      	movs	r3, #3
 800d40a:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
 800d40c:	2301      	movs	r3, #1
 800d40e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 800d410:	2300      	movs	r3, #0
 800d412:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_4;
 800d414:	2304      	movs	r3, #4
 800d416:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800d418:	463b      	mov	r3, r7
 800d41a:	4619      	mov	r1, r3
 800d41c:	4815      	ldr	r0, [pc, #84]	; (800d474 <MX_I2C1_Init+0xa4>)
 800d41e:	f002 f89e 	bl	800f55e <LL_GPIO_Init>

  /* Peripheral clock enable */
  LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_I2C1);
 800d422:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800d426:	f7ff fdab 	bl	800cf80 <LL_APB1_GRP1_EnableClock>

  /* USER CODE END I2C1_Init 1 */

  /** I2C Initialization
  */
  LL_I2C_DisableOwnAddress2(I2C1);
 800d42a:	4813      	ldr	r0, [pc, #76]	; (800d478 <MX_I2C1_Init+0xa8>)
 800d42c:	f7ff fc58 	bl	800cce0 <LL_I2C_DisableOwnAddress2>
  LL_I2C_DisableGeneralCall(I2C1);
 800d430:	4811      	ldr	r0, [pc, #68]	; (800d478 <MX_I2C1_Init+0xa8>)
 800d432:	f7ff fc32 	bl	800cc9a <LL_I2C_DisableGeneralCall>
  LL_I2C_EnableClockStretching(I2C1);
 800d436:	4810      	ldr	r0, [pc, #64]	; (800d478 <MX_I2C1_Init+0xa8>)
 800d438:	f7ff fc1f 	bl	800cc7a <LL_I2C_EnableClockStretching>
  I2C_InitStruct.PeripheralMode = LL_I2C_MODE_I2C;
 800d43c:	2300      	movs	r3, #0
 800d43e:	61bb      	str	r3, [r7, #24]
  I2C_InitStruct.ClockSpeed = 100000;
 800d440:	4b0e      	ldr	r3, [pc, #56]	; (800d47c <MX_I2C1_Init+0xac>)
 800d442:	61fb      	str	r3, [r7, #28]
  I2C_InitStruct.DutyCycle = LL_I2C_DUTYCYCLE_2;
 800d444:	2300      	movs	r3, #0
 800d446:	623b      	str	r3, [r7, #32]
  I2C_InitStruct.OwnAddress1 = 0;
 800d448:	2300      	movs	r3, #0
 800d44a:	627b      	str	r3, [r7, #36]	; 0x24
  I2C_InitStruct.TypeAcknowledge = LL_I2C_ACK;
 800d44c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800d450:	62bb      	str	r3, [r7, #40]	; 0x28
  I2C_InitStruct.OwnAddrSize = LL_I2C_OWNADDRESS1_7BIT;
 800d452:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800d456:	62fb      	str	r3, [r7, #44]	; 0x2c
  LL_I2C_Init(I2C1, &I2C_InitStruct);
 800d458:	f107 0318 	add.w	r3, r7, #24
 800d45c:	4619      	mov	r1, r3
 800d45e:	4806      	ldr	r0, [pc, #24]	; (800d478 <MX_I2C1_Init+0xa8>)
 800d460:	f002 f9e6 	bl	800f830 <LL_I2C_Init>
  LL_I2C_SetOwnAddress2(I2C1, 0);
 800d464:	2100      	movs	r1, #0
 800d466:	4804      	ldr	r0, [pc, #16]	; (800d478 <MX_I2C1_Init+0xa8>)
 800d468:	f7ff fc27 	bl	800ccba <LL_I2C_SetOwnAddress2>
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 800d46c:	bf00      	nop
 800d46e:	3730      	adds	r7, #48	; 0x30
 800d470:	46bd      	mov	sp, r7
 800d472:	bd80      	pop	{r7, pc}
 800d474:	40020400 	.word	0x40020400
 800d478:	40005400 	.word	0x40005400
 800d47c:	000186a0 	.word	0x000186a0

0800d480 <MX_I2S3_Init>:
  * @brief I2S3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2S3_Init(void)
{
 800d480:	b580      	push	{r7, lr}
 800d482:	af00      	add	r7, sp, #0
  /* USER CODE END I2S3_Init 0 */

  /* USER CODE BEGIN I2S3_Init 1 */

  /* USER CODE END I2S3_Init 1 */
  hi2s3.Instance = SPI3;
 800d484:	4b13      	ldr	r3, [pc, #76]	; (800d4d4 <MX_I2S3_Init+0x54>)
 800d486:	4a14      	ldr	r2, [pc, #80]	; (800d4d8 <MX_I2S3_Init+0x58>)
 800d488:	601a      	str	r2, [r3, #0]
  hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
 800d48a:	4b12      	ldr	r3, [pc, #72]	; (800d4d4 <MX_I2S3_Init+0x54>)
 800d48c:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d490:	605a      	str	r2, [r3, #4]
  hi2s3.Init.Standard = I2S_STANDARD_PHILIPS;
 800d492:	4b10      	ldr	r3, [pc, #64]	; (800d4d4 <MX_I2S3_Init+0x54>)
 800d494:	2200      	movs	r2, #0
 800d496:	609a      	str	r2, [r3, #8]
  hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
 800d498:	4b0e      	ldr	r3, [pc, #56]	; (800d4d4 <MX_I2S3_Init+0x54>)
 800d49a:	2200      	movs	r2, #0
 800d49c:	60da      	str	r2, [r3, #12]
  hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
 800d49e:	4b0d      	ldr	r3, [pc, #52]	; (800d4d4 <MX_I2S3_Init+0x54>)
 800d4a0:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d4a4:	611a      	str	r2, [r3, #16]
  hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_48K;
 800d4a6:	4b0b      	ldr	r3, [pc, #44]	; (800d4d4 <MX_I2S3_Init+0x54>)
 800d4a8:	f64b 3280 	movw	r2, #48000	; 0xbb80
 800d4ac:	615a      	str	r2, [r3, #20]
  hi2s3.Init.CPOL = I2S_CPOL_LOW;
 800d4ae:	4b09      	ldr	r3, [pc, #36]	; (800d4d4 <MX_I2S3_Init+0x54>)
 800d4b0:	2200      	movs	r2, #0
 800d4b2:	619a      	str	r2, [r3, #24]
  hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
 800d4b4:	4b07      	ldr	r3, [pc, #28]	; (800d4d4 <MX_I2S3_Init+0x54>)
 800d4b6:	2200      	movs	r2, #0
 800d4b8:	61da      	str	r2, [r3, #28]
  hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
 800d4ba:	4b06      	ldr	r3, [pc, #24]	; (800d4d4 <MX_I2S3_Init+0x54>)
 800d4bc:	2200      	movs	r2, #0
 800d4be:	621a      	str	r2, [r3, #32]
  if (HAL_I2S_Init(&hi2s3) != HAL_OK)
 800d4c0:	4804      	ldr	r0, [pc, #16]	; (800d4d4 <MX_I2S3_Init+0x54>)
 800d4c2:	f001 fa49 	bl	800e958 <HAL_I2S_Init>
 800d4c6:	4603      	mov	r3, r0
 800d4c8:	2b00      	cmp	r3, #0
 800d4ca:	d001      	beq.n	800d4d0 <MX_I2S3_Init+0x50>
  {
    Error_Handler();
 800d4cc:	f000 f8ec 	bl	800d6a8 <Error_Handler>
  }
  /* USER CODE BEGIN I2S3_Init 2 */

  /* USER CODE END I2S3_Init 2 */

}
 800d4d0:	bf00      	nop
 800d4d2:	bd80      	pop	{r7, pc}
 800d4d4:	20000048 	.word	0x20000048
 800d4d8:	40003c00 	.word	0x40003c00

0800d4dc <MX_TIM3_Init>:
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{
 800d4dc:	b580      	push	{r7, lr}
 800d4de:	b094      	sub	sp, #80	; 0x50
 800d4e0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  LL_TIM_InitTypeDef TIM_InitStruct = {0};
 800d4e2:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800d4e6:	2200      	movs	r2, #0
 800d4e8:	601a      	str	r2, [r3, #0]
 800d4ea:	605a      	str	r2, [r3, #4]
 800d4ec:	609a      	str	r2, [r3, #8]
 800d4ee:	60da      	str	r2, [r3, #12]
 800d4f0:	611a      	str	r2, [r3, #16]
  LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
 800d4f2:	f107 031c 	add.w	r3, r7, #28
 800d4f6:	2220      	movs	r2, #32
 800d4f8:	2100      	movs	r1, #0
 800d4fa:	4618      	mov	r0, r3
 800d4fc:	f002 fe06 	bl	801010c <memset>

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 800d500:	1d3b      	adds	r3, r7, #4
 800d502:	2200      	movs	r2, #0
 800d504:	601a      	str	r2, [r3, #0]
 800d506:	605a      	str	r2, [r3, #4]
 800d508:	609a      	str	r2, [r3, #8]
 800d50a:	60da      	str	r2, [r3, #12]
 800d50c:	611a      	str	r2, [r3, #16]
 800d50e:	615a      	str	r2, [r3, #20]

  /* Peripheral clock enable */
  LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM3);
 800d510:	2002      	movs	r0, #2
 800d512:	f7ff fd35 	bl	800cf80 <LL_APB1_GRP1_EnableClock>

  /* TIM3 interrupt Init */
  NVIC_SetPriority(TIM3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
 800d516:	f7ff fb27 	bl	800cb68 <__NVIC_GetPriorityGrouping>
 800d51a:	4603      	mov	r3, r0
 800d51c:	2200      	movs	r2, #0
 800d51e:	2100      	movs	r1, #0
 800d520:	4618      	mov	r0, r3
 800d522:	f7ff fb77 	bl	800cc14 <NVIC_EncodePriority>
 800d526:	4603      	mov	r3, r0
 800d528:	4619      	mov	r1, r3
 800d52a:	201d      	movs	r0, #29
 800d52c:	f7ff fb48 	bl	800cbc0 <__NVIC_SetPriority>
  NVIC_EnableIRQ(TIM3_IRQn);
 800d530:	201d      	movs	r0, #29
 800d532:	f7ff fb27 	bl	800cb84 <__NVIC_EnableIRQ>

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  TIM_InitStruct.Prescaler = 1;
 800d536:	2301      	movs	r3, #1
 800d538:	87bb      	strh	r3, [r7, #60]	; 0x3c
  TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
 800d53a:	2300      	movs	r3, #0
 800d53c:	643b      	str	r3, [r7, #64]	; 0x40
  TIM_InitStruct.Autoreload = 255;
 800d53e:	23ff      	movs	r3, #255	; 0xff
 800d540:	647b      	str	r3, [r7, #68]	; 0x44
  TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
 800d542:	2300      	movs	r3, #0
 800d544:	64bb      	str	r3, [r7, #72]	; 0x48
  LL_TIM_Init(TIM3, &TIM_InitStruct);
 800d546:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800d54a:	4619      	mov	r1, r3
 800d54c:	4828      	ldr	r0, [pc, #160]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d54e:	f002 fb4d 	bl	800fbec <LL_TIM_Init>
  LL_TIM_DisableARRPreload(TIM3);
 800d552:	4827      	ldr	r0, [pc, #156]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d554:	f7ff fd86 	bl	800d064 <LL_TIM_DisableARRPreload>
  LL_TIM_SetClockSource(TIM3, LL_TIM_CLOCKSOURCE_INTERNAL);
 800d558:	2100      	movs	r1, #0
 800d55a:	4825      	ldr	r0, [pc, #148]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d55c:	f7ff fe1c 	bl	800d198 <LL_TIM_SetClockSource>
  LL_TIM_OC_EnablePreload(TIM3, LL_TIM_CHANNEL_CH1);
 800d560:	2101      	movs	r1, #1
 800d562:	4823      	ldr	r0, [pc, #140]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d564:	f7ff fdd4 	bl	800d110 <LL_TIM_OC_EnablePreload>
  TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM1;
 800d568:	2360      	movs	r3, #96	; 0x60
 800d56a:	61fb      	str	r3, [r7, #28]
  TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
 800d56c:	2300      	movs	r3, #0
 800d56e:	623b      	str	r3, [r7, #32]
  TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
 800d570:	2300      	movs	r3, #0
 800d572:	627b      	str	r3, [r7, #36]	; 0x24
  TIM_OC_InitStruct.CompareValue = 0;
 800d574:	2300      	movs	r3, #0
 800d576:	62bb      	str	r3, [r7, #40]	; 0x28
  TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
 800d578:	2300      	movs	r3, #0
 800d57a:	62fb      	str	r3, [r7, #44]	; 0x2c
  LL_TIM_OC_Init(TIM3, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
 800d57c:	f107 031c 	add.w	r3, r7, #28
 800d580:	461a      	mov	r2, r3
 800d582:	2101      	movs	r1, #1
 800d584:	481a      	ldr	r0, [pc, #104]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d586:	f002 fbcb 	bl	800fd20 <LL_TIM_OC_Init>
  LL_TIM_OC_DisableFast(TIM3, LL_TIM_CHANNEL_CH1);
 800d58a:	2101      	movs	r1, #1
 800d58c:	4818      	ldr	r0, [pc, #96]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d58e:	f7ff fd79 	bl	800d084 <LL_TIM_OC_DisableFast>
  LL_TIM_OC_EnablePreload(TIM3, LL_TIM_CHANNEL_CH2);
 800d592:	2110      	movs	r1, #16
 800d594:	4816      	ldr	r0, [pc, #88]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d596:	f7ff fdbb 	bl	800d110 <LL_TIM_OC_EnablePreload>
  LL_TIM_OC_Init(TIM3, LL_TIM_CHANNEL_CH2, &TIM_OC_InitStruct);
 800d59a:	f107 031c 	add.w	r3, r7, #28
 800d59e:	461a      	mov	r2, r3
 800d5a0:	2110      	movs	r1, #16
 800d5a2:	4813      	ldr	r0, [pc, #76]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d5a4:	f002 fbbc 	bl	800fd20 <LL_TIM_OC_Init>
  LL_TIM_OC_DisableFast(TIM3, LL_TIM_CHANNEL_CH2);
 800d5a8:	2110      	movs	r1, #16
 800d5aa:	4811      	ldr	r0, [pc, #68]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d5ac:	f7ff fd6a 	bl	800d084 <LL_TIM_OC_DisableFast>
  LL_TIM_SetTriggerOutput(TIM3, LL_TIM_TRGO_RESET);
 800d5b0:	2100      	movs	r1, #0
 800d5b2:	480f      	ldr	r0, [pc, #60]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d5b4:	f7ff fe05 	bl	800d1c2 <LL_TIM_SetTriggerOutput>
  LL_TIM_DisableMasterSlaveMode(TIM3);
 800d5b8:	480d      	ldr	r0, [pc, #52]	; (800d5f0 <MX_TIM3_Init+0x114>)
 800d5ba:	f7ff fe15 	bl	800d1e8 <LL_TIM_DisableMasterSlaveMode>
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);
 800d5be:	2002      	movs	r0, #2
 800d5c0:	f7ff fcc6 	bl	800cf50 <LL_AHB1_GRP1_EnableClock>
  /**TIM3 GPIO Configuration
  PB4   ------> TIM3_CH1
  PB5   ------> TIM3_CH2
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_4|LL_GPIO_PIN_5;
 800d5c4:	2330      	movs	r3, #48	; 0x30
 800d5c6:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 800d5c8:	2302      	movs	r3, #2
 800d5ca:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 800d5cc:	2300      	movs	r3, #0
 800d5ce:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 800d5d0:	2300      	movs	r3, #0
 800d5d2:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 800d5d4:	2300      	movs	r3, #0
 800d5d6:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_2;
 800d5d8:	2302      	movs	r3, #2
 800d5da:	61bb      	str	r3, [r7, #24]
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800d5dc:	1d3b      	adds	r3, r7, #4
 800d5de:	4619      	mov	r1, r3
 800d5e0:	4804      	ldr	r0, [pc, #16]	; (800d5f4 <MX_TIM3_Init+0x118>)
 800d5e2:	f001 ffbc 	bl	800f55e <LL_GPIO_Init>

}
 800d5e6:	bf00      	nop
 800d5e8:	3750      	adds	r7, #80	; 0x50
 800d5ea:	46bd      	mov	sp, r7
 800d5ec:	bd80      	pop	{r7, pc}
 800d5ee:	bf00      	nop
 800d5f0:	40000400 	.word	0x40000400
 800d5f4:	40020400 	.word	0x40020400

0800d5f8 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{
 800d5f8:	b580      	push	{r7, lr}
 800d5fa:	af00      	add	r7, sp, #0

  /* Init with LL driver */
  /* DMA controller clock enable */
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);
 800d5fc:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800d600:	f7ff fca6 	bl	800cf50 <LL_AHB1_GRP1_EnableClock>

  /* DMA interrupt init */
  /* DMA1_Stream5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 0, 0);
 800d604:	2200      	movs	r2, #0
 800d606:	2100      	movs	r1, #0
 800d608:	2010      	movs	r0, #16
 800d60a:	f000 fc78 	bl	800defe <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn);
 800d60e:	2010      	movs	r0, #16
 800d610:	f000 fc91 	bl	800df36 <HAL_NVIC_EnableIRQ>

}
 800d614:	bf00      	nop
 800d616:	bd80      	pop	{r7, pc}

0800d618 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 800d618:	b580      	push	{r7, lr}
 800d61a:	b086      	sub	sp, #24
 800d61c:	af00      	add	r7, sp, #0
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 800d61e:	463b      	mov	r3, r7
 800d620:	2200      	movs	r2, #0
 800d622:	601a      	str	r2, [r3, #0]
 800d624:	605a      	str	r2, [r3, #4]
 800d626:	609a      	str	r2, [r3, #8]
 800d628:	60da      	str	r2, [r3, #12]
 800d62a:	611a      	str	r2, [r3, #16]
 800d62c:	615a      	str	r2, [r3, #20]
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOH);
 800d62e:	2080      	movs	r0, #128	; 0x80
 800d630:	f7ff fc8e 	bl	800cf50 <LL_AHB1_GRP1_EnableClock>
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
 800d634:	2001      	movs	r0, #1
 800d636:	f7ff fc8b 	bl	800cf50 <LL_AHB1_GRP1_EnableClock>
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOD);
 800d63a:	2008      	movs	r0, #8
 800d63c:	f7ff fc88 	bl	800cf50 <LL_AHB1_GRP1_EnableClock>
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
 800d640:	2004      	movs	r0, #4
 800d642:	f7ff fc85 	bl	800cf50 <LL_AHB1_GRP1_EnableClock>
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);
 800d646:	2002      	movs	r0, #2
 800d648:	f7ff fc82 	bl	800cf50 <LL_AHB1_GRP1_EnableClock>

  /**/
  LL_GPIO_ResetOutputPin(GPIOD, LL_GPIO_PIN_12|LL_GPIO_PIN_13|LL_GPIO_PIN_14|LL_GPIO_PIN_15
 800d64c:	f24f 0110 	movw	r1, #61456	; 0xf010
 800d650:	480b      	ldr	r0, [pc, #44]	; (800d680 <MX_GPIO_Init+0x68>)
 800d652:	f7ff fde9 	bl	800d228 <LL_GPIO_ResetOutputPin>
                          |LL_GPIO_PIN_4);

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_12|LL_GPIO_PIN_13|LL_GPIO_PIN_14|LL_GPIO_PIN_15
 800d656:	f24f 0310 	movw	r3, #61456	; 0xf010
 800d65a:	603b      	str	r3, [r7, #0]
                          |LL_GPIO_PIN_4;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 800d65c:	2301      	movs	r3, #1
 800d65e:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 800d660:	2300      	movs	r3, #0
 800d662:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 800d664:	2300      	movs	r3, #0
 800d666:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 800d668:	2300      	movs	r3, #0
 800d66a:	613b      	str	r3, [r7, #16]
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800d66c:	463b      	mov	r3, r7
 800d66e:	4619      	mov	r1, r3
 800d670:	4803      	ldr	r0, [pc, #12]	; (800d680 <MX_GPIO_Init+0x68>)
 800d672:	f001 ff74 	bl	800f55e <LL_GPIO_Init>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
 800d676:	bf00      	nop
 800d678:	3718      	adds	r7, #24
 800d67a:	46bd      	mov	sp, r7
 800d67c:	bd80      	pop	{r7, pc}
 800d67e:	bf00      	nop
 800d680:	40020c00 	.word	0x40020c00

0800d684 <LoadAudioFiles>:

/* USER CODE BEGIN 4 */
void LoadAudioFiles(void)
{
 800d684:	b480      	push	{r7}
 800d686:	af00      	add	r7, sp, #0
	AudioFile.AudioFiles[0] = (uint32_t)&afnm;
 800d688:	4a05      	ldr	r2, [pc, #20]	; (800d6a0 <LoadAudioFiles+0x1c>)
 800d68a:	4b06      	ldr	r3, [pc, #24]	; (800d6a4 <LoadAudioFiles+0x20>)
 800d68c:	601a      	str	r2, [r3, #0]
	AudioFile.AudioSize[0] = NELEMS(afnm);
 800d68e:	4b05      	ldr	r3, [pc, #20]	; (800d6a4 <LoadAudioFiles+0x20>)
 800d690:	f647 2212 	movw	r2, #31250	; 0x7a12
 800d694:	605a      	str	r2, [r3, #4]
}
 800d696:	bf00      	nop
 800d698:	46bd      	mov	sp, r7
 800d69a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d69e:	4770      	bx	lr
 800d6a0:	08005000 	.word	0x08005000
 800d6a4:	200000f0 	.word	0x200000f0

0800d6a8 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800d6a8:	b480      	push	{r7}
 800d6aa:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800d6ac:	b672      	cpsid	i
}
 800d6ae:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800d6b0:	e7fe      	b.n	800d6b0 <Error_Handler+0x8>
	...

0800d6b4 <LL_RCC_SetI2SClockSource>:
{
 800d6b4:	b480      	push	{r7}
 800d6b6:	b083      	sub	sp, #12
 800d6b8:	af00      	add	r7, sp, #0
 800d6ba:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_I2SSRC, Source);
 800d6bc:	4b06      	ldr	r3, [pc, #24]	; (800d6d8 <LL_RCC_SetI2SClockSource+0x24>)
 800d6be:	689b      	ldr	r3, [r3, #8]
 800d6c0:	f423 0200 	bic.w	r2, r3, #8388608	; 0x800000
 800d6c4:	4904      	ldr	r1, [pc, #16]	; (800d6d8 <LL_RCC_SetI2SClockSource+0x24>)
 800d6c6:	687b      	ldr	r3, [r7, #4]
 800d6c8:	4313      	orrs	r3, r2
 800d6ca:	608b      	str	r3, [r1, #8]
}
 800d6cc:	bf00      	nop
 800d6ce:	370c      	adds	r7, #12
 800d6d0:	46bd      	mov	sp, r7
 800d6d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6d6:	4770      	bx	lr
 800d6d8:	40023800 	.word	0x40023800

0800d6dc <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800d6dc:	b580      	push	{r7, lr}
 800d6de:	b082      	sub	sp, #8
 800d6e0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800d6e2:	2300      	movs	r3, #0
 800d6e4:	607b      	str	r3, [r7, #4]
 800d6e6:	4b10      	ldr	r3, [pc, #64]	; (800d728 <HAL_MspInit+0x4c>)
 800d6e8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d6ea:	4a0f      	ldr	r2, [pc, #60]	; (800d728 <HAL_MspInit+0x4c>)
 800d6ec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800d6f0:	6453      	str	r3, [r2, #68]	; 0x44
 800d6f2:	4b0d      	ldr	r3, [pc, #52]	; (800d728 <HAL_MspInit+0x4c>)
 800d6f4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d6f6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800d6fa:	607b      	str	r3, [r7, #4]
 800d6fc:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800d6fe:	2300      	movs	r3, #0
 800d700:	603b      	str	r3, [r7, #0]
 800d702:	4b09      	ldr	r3, [pc, #36]	; (800d728 <HAL_MspInit+0x4c>)
 800d704:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d706:	4a08      	ldr	r2, [pc, #32]	; (800d728 <HAL_MspInit+0x4c>)
 800d708:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800d70c:	6413      	str	r3, [r2, #64]	; 0x40
 800d70e:	4b06      	ldr	r3, [pc, #24]	; (800d728 <HAL_MspInit+0x4c>)
 800d710:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d712:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d716:	603b      	str	r3, [r7, #0]
 800d718:	683b      	ldr	r3, [r7, #0]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 800d71a:	2007      	movs	r0, #7
 800d71c:	f000 fbe4 	bl	800dee8 <HAL_NVIC_SetPriorityGrouping>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800d720:	bf00      	nop
 800d722:	3708      	adds	r7, #8
 800d724:	46bd      	mov	sp, r7
 800d726:	bd80      	pop	{r7, pc}
 800d728:	40023800 	.word	0x40023800

0800d72c <HAL_DAC_MspInit>:
* This function configures the hardware resources used in this example
* @param hdac: DAC handle pointer
* @retval None
*/
void HAL_DAC_MspInit(DAC_HandleTypeDef* hdac)
{
 800d72c:	b580      	push	{r7, lr}
 800d72e:	b08a      	sub	sp, #40	; 0x28
 800d730:	af00      	add	r7, sp, #0
 800d732:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800d734:	f107 0314 	add.w	r3, r7, #20
 800d738:	2200      	movs	r2, #0
 800d73a:	601a      	str	r2, [r3, #0]
 800d73c:	605a      	str	r2, [r3, #4]
 800d73e:	609a      	str	r2, [r3, #8]
 800d740:	60da      	str	r2, [r3, #12]
 800d742:	611a      	str	r2, [r3, #16]
  if(hdac->Instance==DAC)
 800d744:	687b      	ldr	r3, [r7, #4]
 800d746:	681b      	ldr	r3, [r3, #0]
 800d748:	4a17      	ldr	r2, [pc, #92]	; (800d7a8 <HAL_DAC_MspInit+0x7c>)
 800d74a:	4293      	cmp	r3, r2
 800d74c:	d127      	bne.n	800d79e <HAL_DAC_MspInit+0x72>
  {
  /* USER CODE BEGIN DAC_MspInit 0 */

  /* USER CODE END DAC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_DAC_CLK_ENABLE();
 800d74e:	2300      	movs	r3, #0
 800d750:	613b      	str	r3, [r7, #16]
 800d752:	4b16      	ldr	r3, [pc, #88]	; (800d7ac <HAL_DAC_MspInit+0x80>)
 800d754:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d756:	4a15      	ldr	r2, [pc, #84]	; (800d7ac <HAL_DAC_MspInit+0x80>)
 800d758:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800d75c:	6413      	str	r3, [r2, #64]	; 0x40
 800d75e:	4b13      	ldr	r3, [pc, #76]	; (800d7ac <HAL_DAC_MspInit+0x80>)
 800d760:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d762:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800d766:	613b      	str	r3, [r7, #16]
 800d768:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800d76a:	2300      	movs	r3, #0
 800d76c:	60fb      	str	r3, [r7, #12]
 800d76e:	4b0f      	ldr	r3, [pc, #60]	; (800d7ac <HAL_DAC_MspInit+0x80>)
 800d770:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d772:	4a0e      	ldr	r2, [pc, #56]	; (800d7ac <HAL_DAC_MspInit+0x80>)
 800d774:	f043 0301 	orr.w	r3, r3, #1
 800d778:	6313      	str	r3, [r2, #48]	; 0x30
 800d77a:	4b0c      	ldr	r3, [pc, #48]	; (800d7ac <HAL_DAC_MspInit+0x80>)
 800d77c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d77e:	f003 0301 	and.w	r3, r3, #1
 800d782:	60fb      	str	r3, [r7, #12]
 800d784:	68fb      	ldr	r3, [r7, #12]
    /**DAC GPIO Configuration
    PA4     ------> DAC_OUT1
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 800d786:	2310      	movs	r3, #16
 800d788:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800d78a:	2303      	movs	r3, #3
 800d78c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800d78e:	2300      	movs	r3, #0
 800d790:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800d792:	f107 0314 	add.w	r3, r7, #20
 800d796:	4619      	mov	r1, r3
 800d798:	4805      	ldr	r0, [pc, #20]	; (800d7b0 <HAL_DAC_MspInit+0x84>)
 800d79a:	f000 ff41 	bl	800e620 <HAL_GPIO_Init>
  /* USER CODE BEGIN DAC_MspInit 1 */

  /* USER CODE END DAC_MspInit 1 */
  }

}
 800d79e:	bf00      	nop
 800d7a0:	3728      	adds	r7, #40	; 0x28
 800d7a2:	46bd      	mov	sp, r7
 800d7a4:	bd80      	pop	{r7, pc}
 800d7a6:	bf00      	nop
 800d7a8:	40007400 	.word	0x40007400
 800d7ac:	40023800 	.word	0x40023800
 800d7b0:	40020000 	.word	0x40020000

0800d7b4 <HAL_I2S_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2s: I2S handle pointer
* @retval None
*/
void HAL_I2S_MspInit(I2S_HandleTypeDef* hi2s)
{
 800d7b4:	b580      	push	{r7, lr}
 800d7b6:	b08a      	sub	sp, #40	; 0x28
 800d7b8:	af00      	add	r7, sp, #0
 800d7ba:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800d7bc:	f107 0314 	add.w	r3, r7, #20
 800d7c0:	2200      	movs	r2, #0
 800d7c2:	601a      	str	r2, [r3, #0]
 800d7c4:	605a      	str	r2, [r3, #4]
 800d7c6:	609a      	str	r2, [r3, #8]
 800d7c8:	60da      	str	r2, [r3, #12]
 800d7ca:	611a      	str	r2, [r3, #16]
  if(hi2s->Instance==SPI3)
 800d7cc:	687b      	ldr	r3, [r7, #4]
 800d7ce:	681b      	ldr	r3, [r3, #0]
 800d7d0:	4a47      	ldr	r2, [pc, #284]	; (800d8f0 <HAL_I2S_MspInit+0x13c>)
 800d7d2:	4293      	cmp	r3, r2
 800d7d4:	f040 8088 	bne.w	800d8e8 <HAL_I2S_MspInit+0x134>
  {
  /* USER CODE BEGIN SPI3_MspInit 0 */

  /* USER CODE END SPI3_MspInit 0 */
    LL_RCC_SetI2SClockSource(LL_RCC_I2S1_CLKSOURCE_PLLI2S);
 800d7d8:	2000      	movs	r0, #0
 800d7da:	f7ff ff6b 	bl	800d6b4 <LL_RCC_SetI2SClockSource>

    /* Peripheral clock enable */
    __HAL_RCC_SPI3_CLK_ENABLE();
 800d7de:	2300      	movs	r3, #0
 800d7e0:	613b      	str	r3, [r7, #16]
 800d7e2:	4b44      	ldr	r3, [pc, #272]	; (800d8f4 <HAL_I2S_MspInit+0x140>)
 800d7e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d7e6:	4a43      	ldr	r2, [pc, #268]	; (800d8f4 <HAL_I2S_MspInit+0x140>)
 800d7e8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800d7ec:	6413      	str	r3, [r2, #64]	; 0x40
 800d7ee:	4b41      	ldr	r3, [pc, #260]	; (800d8f4 <HAL_I2S_MspInit+0x140>)
 800d7f0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d7f2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800d7f6:	613b      	str	r3, [r7, #16]
 800d7f8:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOC_CLK_ENABLE();
 800d7fa:	2300      	movs	r3, #0
 800d7fc:	60fb      	str	r3, [r7, #12]
 800d7fe:	4b3d      	ldr	r3, [pc, #244]	; (800d8f4 <HAL_I2S_MspInit+0x140>)
 800d800:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d802:	4a3c      	ldr	r2, [pc, #240]	; (800d8f4 <HAL_I2S_MspInit+0x140>)
 800d804:	f043 0304 	orr.w	r3, r3, #4
 800d808:	6313      	str	r3, [r2, #48]	; 0x30
 800d80a:	4b3a      	ldr	r3, [pc, #232]	; (800d8f4 <HAL_I2S_MspInit+0x140>)
 800d80c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d80e:	f003 0304 	and.w	r3, r3, #4
 800d812:	60fb      	str	r3, [r7, #12]
 800d814:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800d816:	2300      	movs	r3, #0
 800d818:	60bb      	str	r3, [r7, #8]
 800d81a:	4b36      	ldr	r3, [pc, #216]	; (800d8f4 <HAL_I2S_MspInit+0x140>)
 800d81c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d81e:	4a35      	ldr	r2, [pc, #212]	; (800d8f4 <HAL_I2S_MspInit+0x140>)
 800d820:	f043 0301 	orr.w	r3, r3, #1
 800d824:	6313      	str	r3, [r2, #48]	; 0x30
 800d826:	4b33      	ldr	r3, [pc, #204]	; (800d8f4 <HAL_I2S_MspInit+0x140>)
 800d828:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d82a:	f003 0301 	and.w	r3, r3, #1
 800d82e:	60bb      	str	r3, [r7, #8]
 800d830:	68bb      	ldr	r3, [r7, #8]
    PC7     ------> I2S3_MCK
    PA15     ------> I2S3_WS
    PC10     ------> I2S3_CK
    PC12     ------> I2S3_SD
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_10|GPIO_PIN_12;
 800d832:	f44f 53a4 	mov.w	r3, #5248	; 0x1480
 800d836:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d838:	2302      	movs	r3, #2
 800d83a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800d83c:	2300      	movs	r3, #0
 800d83e:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800d840:	2300      	movs	r3, #0
 800d842:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 800d844:	2306      	movs	r3, #6
 800d846:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800d848:	f107 0314 	add.w	r3, r7, #20
 800d84c:	4619      	mov	r1, r3
 800d84e:	482a      	ldr	r0, [pc, #168]	; (800d8f8 <HAL_I2S_MspInit+0x144>)
 800d850:	f000 fee6 	bl	800e620 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_15;
 800d854:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800d858:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d85a:	2302      	movs	r3, #2
 800d85c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800d85e:	2300      	movs	r3, #0
 800d860:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800d862:	2300      	movs	r3, #0
 800d864:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 800d866:	2306      	movs	r3, #6
 800d868:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800d86a:	f107 0314 	add.w	r3, r7, #20
 800d86e:	4619      	mov	r1, r3
 800d870:	4822      	ldr	r0, [pc, #136]	; (800d8fc <HAL_I2S_MspInit+0x148>)
 800d872:	f000 fed5 	bl	800e620 <HAL_GPIO_Init>

    /* I2S3 DMA Init */
    /* SPI3_TX Init */
    hdma_spi3_tx.Instance = DMA1_Stream5;
 800d876:	4b22      	ldr	r3, [pc, #136]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d878:	4a22      	ldr	r2, [pc, #136]	; (800d904 <HAL_I2S_MspInit+0x150>)
 800d87a:	601a      	str	r2, [r3, #0]
    hdma_spi3_tx.Init.Channel = DMA_CHANNEL_0;
 800d87c:	4b20      	ldr	r3, [pc, #128]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d87e:	2200      	movs	r2, #0
 800d880:	605a      	str	r2, [r3, #4]
    hdma_spi3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800d882:	4b1f      	ldr	r3, [pc, #124]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d884:	2240      	movs	r2, #64	; 0x40
 800d886:	609a      	str	r2, [r3, #8]
    hdma_spi3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 800d888:	4b1d      	ldr	r3, [pc, #116]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d88a:	2200      	movs	r2, #0
 800d88c:	60da      	str	r2, [r3, #12]
    hdma_spi3_tx.Init.MemInc = DMA_MINC_ENABLE;
 800d88e:	4b1c      	ldr	r3, [pc, #112]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d890:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800d894:	611a      	str	r2, [r3, #16]
    hdma_spi3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 800d896:	4b1a      	ldr	r3, [pc, #104]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d898:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800d89c:	615a      	str	r2, [r3, #20]
    hdma_spi3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 800d89e:	4b18      	ldr	r3, [pc, #96]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d8a0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800d8a4:	619a      	str	r2, [r3, #24]
    hdma_spi3_tx.Init.Mode = DMA_CIRCULAR;
 800d8a6:	4b16      	ldr	r3, [pc, #88]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d8a8:	f44f 7280 	mov.w	r2, #256	; 0x100
 800d8ac:	61da      	str	r2, [r3, #28]
    hdma_spi3_tx.Init.Priority = DMA_PRIORITY_LOW;
 800d8ae:	4b14      	ldr	r3, [pc, #80]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d8b0:	2200      	movs	r2, #0
 800d8b2:	621a      	str	r2, [r3, #32]
    hdma_spi3_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 800d8b4:	4b12      	ldr	r3, [pc, #72]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d8b6:	2204      	movs	r2, #4
 800d8b8:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_spi3_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 800d8ba:	4b11      	ldr	r3, [pc, #68]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d8bc:	2203      	movs	r2, #3
 800d8be:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_spi3_tx.Init.MemBurst = DMA_MBURST_SINGLE;
 800d8c0:	4b0f      	ldr	r3, [pc, #60]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d8c2:	2200      	movs	r2, #0
 800d8c4:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_spi3_tx.Init.PeriphBurst = DMA_PBURST_SINGLE;
 800d8c6:	4b0e      	ldr	r3, [pc, #56]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d8c8:	2200      	movs	r2, #0
 800d8ca:	631a      	str	r2, [r3, #48]	; 0x30
    if (HAL_DMA_Init(&hdma_spi3_tx) != HAL_OK)
 800d8cc:	480c      	ldr	r0, [pc, #48]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d8ce:	f000 fbbd 	bl	800e04c <HAL_DMA_Init>
 800d8d2:	4603      	mov	r3, r0
 800d8d4:	2b00      	cmp	r3, #0
 800d8d6:	d001      	beq.n	800d8dc <HAL_I2S_MspInit+0x128>
    {
      Error_Handler();
 800d8d8:	f7ff fee6 	bl	800d6a8 <Error_Handler>
    }

    __HAL_LINKDMA(hi2s,hdmatx,hdma_spi3_tx);
 800d8dc:	687b      	ldr	r3, [r7, #4]
 800d8de:	4a08      	ldr	r2, [pc, #32]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d8e0:	639a      	str	r2, [r3, #56]	; 0x38
 800d8e2:	4a07      	ldr	r2, [pc, #28]	; (800d900 <HAL_I2S_MspInit+0x14c>)
 800d8e4:	687b      	ldr	r3, [r7, #4]
 800d8e6:	6393      	str	r3, [r2, #56]	; 0x38
  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }

}
 800d8e8:	bf00      	nop
 800d8ea:	3728      	adds	r7, #40	; 0x28
 800d8ec:	46bd      	mov	sp, r7
 800d8ee:	bd80      	pop	{r7, pc}
 800d8f0:	40003c00 	.word	0x40003c00
 800d8f4:	40023800 	.word	0x40023800
 800d8f8:	40020800 	.word	0x40020800
 800d8fc:	40020000 	.word	0x40020000
 800d900:	20000090 	.word	0x20000090
 800d904:	40026088 	.word	0x40026088

0800d908 <__NVIC_DisableIRQ>:
{
 800d908:	b480      	push	{r7}
 800d90a:	b083      	sub	sp, #12
 800d90c:	af00      	add	r7, sp, #0
 800d90e:	4603      	mov	r3, r0
 800d910:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800d912:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d916:	2b00      	cmp	r3, #0
 800d918:	db12      	blt.n	800d940 <__NVIC_DisableIRQ+0x38>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800d91a:	79fb      	ldrb	r3, [r7, #7]
 800d91c:	f003 021f 	and.w	r2, r3, #31
 800d920:	490a      	ldr	r1, [pc, #40]	; (800d94c <__NVIC_DisableIRQ+0x44>)
 800d922:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d926:	095b      	lsrs	r3, r3, #5
 800d928:	2001      	movs	r0, #1
 800d92a:	fa00 f202 	lsl.w	r2, r0, r2
 800d92e:	3320      	adds	r3, #32
 800d930:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800d934:	f3bf 8f4f 	dsb	sy
}
 800d938:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800d93a:	f3bf 8f6f 	isb	sy
}
 800d93e:	bf00      	nop
}
 800d940:	bf00      	nop
 800d942:	370c      	adds	r7, #12
 800d944:	46bd      	mov	sp, r7
 800d946:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d94a:	4770      	bx	lr
 800d94c:	e000e100 	.word	0xe000e100

0800d950 <LL_TIM_DisableCounter>:
{
 800d950:	b480      	push	{r7}
 800d952:	b083      	sub	sp, #12
 800d954:	af00      	add	r7, sp, #0
 800d956:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
 800d958:	687b      	ldr	r3, [r7, #4]
 800d95a:	681b      	ldr	r3, [r3, #0]
 800d95c:	f023 0201 	bic.w	r2, r3, #1
 800d960:	687b      	ldr	r3, [r7, #4]
 800d962:	601a      	str	r2, [r3, #0]
}
 800d964:	bf00      	nop
 800d966:	370c      	adds	r7, #12
 800d968:	46bd      	mov	sp, r7
 800d96a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d96e:	4770      	bx	lr

0800d970 <LL_TIM_ClearFlag_UPDATE>:
{
 800d970:	b480      	push	{r7}
 800d972:	b083      	sub	sp, #12
 800d974:	af00      	add	r7, sp, #0
 800d976:	6078      	str	r0, [r7, #4]
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800d978:	687b      	ldr	r3, [r7, #4]
 800d97a:	f06f 0201 	mvn.w	r2, #1
 800d97e:	611a      	str	r2, [r3, #16]
}
 800d980:	bf00      	nop
 800d982:	370c      	adds	r7, #12
 800d984:	46bd      	mov	sp, r7
 800d986:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d98a:	4770      	bx	lr

0800d98c <LL_TIM_IsActiveFlag_UPDATE>:
{
 800d98c:	b480      	push	{r7}
 800d98e:	b083      	sub	sp, #12
 800d990:	af00      	add	r7, sp, #0
 800d992:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 800d994:	687b      	ldr	r3, [r7, #4]
 800d996:	691b      	ldr	r3, [r3, #16]
 800d998:	f003 0301 	and.w	r3, r3, #1
 800d99c:	2b01      	cmp	r3, #1
 800d99e:	d101      	bne.n	800d9a4 <LL_TIM_IsActiveFlag_UPDATE+0x18>
 800d9a0:	2301      	movs	r3, #1
 800d9a2:	e000      	b.n	800d9a6 <LL_TIM_IsActiveFlag_UPDATE+0x1a>
 800d9a4:	2300      	movs	r3, #0
}
 800d9a6:	4618      	mov	r0, r3
 800d9a8:	370c      	adds	r7, #12
 800d9aa:	46bd      	mov	sp, r7
 800d9ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9b0:	4770      	bx	lr

0800d9b2 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800d9b2:	b480      	push	{r7}
 800d9b4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 800d9b6:	e7fe      	b.n	800d9b6 <NMI_Handler+0x4>

0800d9b8 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800d9b8:	b480      	push	{r7}
 800d9ba:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800d9bc:	e7fe      	b.n	800d9bc <HardFault_Handler+0x4>

0800d9be <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800d9be:	b480      	push	{r7}
 800d9c0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800d9c2:	e7fe      	b.n	800d9c2 <MemManage_Handler+0x4>

0800d9c4 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800d9c4:	b480      	push	{r7}
 800d9c6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800d9c8:	e7fe      	b.n	800d9c8 <BusFault_Handler+0x4>

0800d9ca <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800d9ca:	b480      	push	{r7}
 800d9cc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800d9ce:	e7fe      	b.n	800d9ce <UsageFault_Handler+0x4>

0800d9d0 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800d9d0:	b480      	push	{r7}
 800d9d2:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800d9d4:	bf00      	nop
 800d9d6:	46bd      	mov	sp, r7
 800d9d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9dc:	4770      	bx	lr

0800d9de <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800d9de:	b480      	push	{r7}
 800d9e0:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800d9e2:	bf00      	nop
 800d9e4:	46bd      	mov	sp, r7
 800d9e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9ea:	4770      	bx	lr

0800d9ec <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800d9ec:	b480      	push	{r7}
 800d9ee:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800d9f0:	bf00      	nop
 800d9f2:	46bd      	mov	sp, r7
 800d9f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9f8:	4770      	bx	lr

0800d9fa <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800d9fa:	b580      	push	{r7, lr}
 800d9fc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800d9fe:	f000 f95f 	bl	800dcc0 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800da02:	bf00      	nop
 800da04:	bd80      	pop	{r7, pc}
	...

0800da08 <DMA1_Stream5_IRQHandler>:

/**
  * @brief This function handles DMA1 stream5 global interrupt.
  */
void DMA1_Stream5_IRQHandler(void)
{
 800da08:	b580      	push	{r7, lr}
 800da0a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream5_IRQn 0 */

  /* USER CODE END DMA1_Stream5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi3_tx);
 800da0c:	4802      	ldr	r0, [pc, #8]	; (800da18 <DMA1_Stream5_IRQHandler+0x10>)
 800da0e:	f000 fbcb 	bl	800e1a8 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream5_IRQn 1 */

  /* USER CODE END DMA1_Stream5_IRQn 1 */
}
 800da12:	bf00      	nop
 800da14:	bd80      	pop	{r7, pc}
 800da16:	bf00      	nop
 800da18:	20000090 	.word	0x20000090

0800da1c <TIM3_IRQHandler>:

/**
  * @brief This function handles TIM3 global interrupt.
  */
void TIM3_IRQHandler(void)
{
 800da1c:	b580      	push	{r7, lr}
 800da1e:	b082      	sub	sp, #8
 800da20:	af00      	add	r7, sp, #0
	static uint8_t repetition = 0;
	static uint16_t sample_position = 0;
	static unsigned char *RawAudio;
	static uint8_t PrevAudioFileToPlay = 0xFF;

	if(PrevAudioFileToPlay != AudioFileToPlay)
 800da22:	4b56      	ldr	r3, [pc, #344]	; (800db7c <TIM3_IRQHandler+0x160>)
 800da24:	781a      	ldrb	r2, [r3, #0]
 800da26:	4b56      	ldr	r3, [pc, #344]	; (800db80 <TIM3_IRQHandler+0x164>)
 800da28:	781b      	ldrb	r3, [r3, #0]
 800da2a:	429a      	cmp	r2, r3
 800da2c:	d015      	beq.n	800da5a <TIM3_IRQHandler+0x3e>
	{
		PrevAudioFileToPlay = AudioFileToPlay;
 800da2e:	4b54      	ldr	r3, [pc, #336]	; (800db80 <TIM3_IRQHandler+0x164>)
 800da30:	781a      	ldrb	r2, [r3, #0]
 800da32:	4b52      	ldr	r3, [pc, #328]	; (800db7c <TIM3_IRQHandler+0x160>)
 800da34:	701a      	strb	r2, [r3, #0]
		nibble = 1;
 800da36:	4b53      	ldr	r3, [pc, #332]	; (800db84 <TIM3_IRQHandler+0x168>)
 800da38:	2201      	movs	r2, #1
 800da3a:	701a      	strb	r2, [r3, #0]
		repetition = 0;
 800da3c:	4b52      	ldr	r3, [pc, #328]	; (800db88 <TIM3_IRQHandler+0x16c>)
 800da3e:	2200      	movs	r2, #0
 800da40:	701a      	strb	r2, [r3, #0]
		sample_position = 0;
 800da42:	4b52      	ldr	r3, [pc, #328]	; (800db8c <TIM3_IRQHandler+0x170>)
 800da44:	2200      	movs	r2, #0
 800da46:	801a      	strh	r2, [r3, #0]
		RawAudio = (unsigned char *)AudioFile.AudioFiles[AudioFileToPlay];
 800da48:	4b4d      	ldr	r3, [pc, #308]	; (800db80 <TIM3_IRQHandler+0x164>)
 800da4a:	781b      	ldrb	r3, [r3, #0]
 800da4c:	461a      	mov	r2, r3
 800da4e:	4b50      	ldr	r3, [pc, #320]	; (800db90 <TIM3_IRQHandler+0x174>)
 800da50:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800da54:	461a      	mov	r2, r3
 800da56:	4b4f      	ldr	r3, [pc, #316]	; (800db94 <TIM3_IRQHandler+0x178>)
 800da58:	601a      	str	r2, [r3, #0]
	}

	if (LL_TIM_IsActiveFlag_UPDATE(TIM3))
 800da5a:	484f      	ldr	r0, [pc, #316]	; (800db98 <TIM3_IRQHandler+0x17c>)
 800da5c:	f7ff ff96 	bl	800d98c <LL_TIM_IsActiveFlag_UPDATE>
 800da60:	4603      	mov	r3, r0
 800da62:	2b00      	cmp	r3, #0
 800da64:	f000 8085 	beq.w	800db72 <TIM3_IRQHandler+0x156>
	{
		LL_TIM_ClearFlag_UPDATE(TIM3);
 800da68:	484b      	ldr	r0, [pc, #300]	; (800db98 <TIM3_IRQHandler+0x17c>)
 800da6a:	f7ff ff81 	bl	800d970 <LL_TIM_ClearFlag_UPDATE>

		if ((repetition==0) & (sample_position < AudioFile.AudioSize[AudioFileToPlay]))
 800da6e:	4b46      	ldr	r3, [pc, #280]	; (800db88 <TIM3_IRQHandler+0x16c>)
 800da70:	781b      	ldrb	r3, [r3, #0]
 800da72:	2b00      	cmp	r3, #0
 800da74:	bf0c      	ite	eq
 800da76:	2301      	moveq	r3, #1
 800da78:	2300      	movne	r3, #0
 800da7a:	b2da      	uxtb	r2, r3
 800da7c:	4b43      	ldr	r3, [pc, #268]	; (800db8c <TIM3_IRQHandler+0x170>)
 800da7e:	881b      	ldrh	r3, [r3, #0]
 800da80:	4618      	mov	r0, r3
 800da82:	4b3f      	ldr	r3, [pc, #252]	; (800db80 <TIM3_IRQHandler+0x164>)
 800da84:	781b      	ldrb	r3, [r3, #0]
 800da86:	4942      	ldr	r1, [pc, #264]	; (800db90 <TIM3_IRQHandler+0x174>)
 800da88:	009b      	lsls	r3, r3, #2
 800da8a:	440b      	add	r3, r1
 800da8c:	685b      	ldr	r3, [r3, #4]
 800da8e:	4298      	cmp	r0, r3
 800da90:	bf34      	ite	cc
 800da92:	2301      	movcc	r3, #1
 800da94:	2300      	movcs	r3, #0
 800da96:	b2db      	uxtb	r3, r3
 800da98:	4013      	ands	r3, r2
 800da9a:	b2db      	uxtb	r3, r3
 800da9c:	2b00      	cmp	r3, #0
 800da9e:	d040      	beq.n	800db22 <TIM3_IRQHandler+0x106>
		{  // new sample is generated
			repetition = 7;	// reinitialize repetition down counter
 800daa0:	4b39      	ldr	r3, [pc, #228]	; (800db88 <TIM3_IRQHandler+0x16c>)
 800daa2:	2207      	movs	r2, #7
 800daa4:	701a      	strb	r2, [r3, #0]
			if (nibble)
 800daa6:	4b37      	ldr	r3, [pc, #220]	; (800db84 <TIM3_IRQHandler+0x168>)
 800daa8:	781b      	ldrb	r3, [r3, #0]
 800daaa:	2b00      	cmp	r3, #0
 800daac:	d008      	beq.n	800dac0 <TIM3_IRQHandler+0xa4>
			{   // first 4 bits of the ADPCM byte decoded
				adpcmSample = (uint8_t)(RawAudio[sample_position] >> 4);
 800daae:	4b39      	ldr	r3, [pc, #228]	; (800db94 <TIM3_IRQHandler+0x178>)
 800dab0:	681b      	ldr	r3, [r3, #0]
 800dab2:	4a36      	ldr	r2, [pc, #216]	; (800db8c <TIM3_IRQHandler+0x170>)
 800dab4:	8812      	ldrh	r2, [r2, #0]
 800dab6:	4413      	add	r3, r2
 800dab8:	781b      	ldrb	r3, [r3, #0]
 800daba:	091b      	lsrs	r3, r3, #4
 800dabc:	71fb      	strb	r3, [r7, #7]
 800dabe:	e00e      	b.n	800dade <TIM3_IRQHandler+0xc2>
			}
			else
			{   // last 4 bits of the ADPCM byte decoded
				adpcmSample = (uint8_t)(RawAudio[sample_position] & 0x0F);
 800dac0:	4b34      	ldr	r3, [pc, #208]	; (800db94 <TIM3_IRQHandler+0x178>)
 800dac2:	681b      	ldr	r3, [r3, #0]
 800dac4:	4a31      	ldr	r2, [pc, #196]	; (800db8c <TIM3_IRQHandler+0x170>)
 800dac6:	8812      	ldrh	r2, [r2, #0]
 800dac8:	4413      	add	r3, r2
 800daca:	781b      	ldrb	r3, [r3, #0]
 800dacc:	f003 030f 	and.w	r3, r3, #15
 800dad0:	71fb      	strb	r3, [r7, #7]
				sample_position++ ;
 800dad2:	4b2e      	ldr	r3, [pc, #184]	; (800db8c <TIM3_IRQHandler+0x170>)
 800dad4:	881b      	ldrh	r3, [r3, #0]
 800dad6:	3301      	adds	r3, #1
 800dad8:	b29a      	uxth	r2, r3
 800dada:	4b2c      	ldr	r3, [pc, #176]	; (800db8c <TIM3_IRQHandler+0x170>)
 800dadc:	801a      	strh	r2, [r3, #0]
			}

			nibble = (uint8_t)(!nibble);/* indicator inverted mean next interrupt will handle
 800dade:	4b29      	ldr	r3, [pc, #164]	; (800db84 <TIM3_IRQHandler+0x168>)
 800dae0:	781b      	ldrb	r3, [r3, #0]
 800dae2:	2b00      	cmp	r3, #0
 800dae4:	bf0c      	ite	eq
 800dae6:	2301      	moveq	r3, #1
 800dae8:	2300      	movne	r3, #0
 800daea:	b2db      	uxtb	r3, r3
 800daec:	461a      	mov	r2, r3
 800daee:	4b25      	ldr	r3, [pc, #148]	; (800db84 <TIM3_IRQHandler+0x168>)
 800daf0:	701a      	strb	r2, [r3, #0]
																					 the second part of the byte.  */
			pcmSample = ADPCM_Decode(adpcmSample);
 800daf2:	79fb      	ldrb	r3, [r7, #7]
 800daf4:	4618      	mov	r0, r3
 800daf6:	f7fe ffad 	bl	800ca54 <ADPCM_Decode>
 800dafa:	4603      	mov	r3, r0
 800dafc:	b29a      	uxth	r2, r3
 800dafe:	4b27      	ldr	r3, [pc, #156]	; (800db9c <TIM3_IRQHandler+0x180>)
 800db00:	801a      	strh	r2, [r3, #0]

			// update sample
			newSample.uShort = (uint16_t)32768 + pcmSample;
 800db02:	4b26      	ldr	r3, [pc, #152]	; (800db9c <TIM3_IRQHandler+0x180>)
 800db04:	881b      	ldrh	r3, [r3, #0]
 800db06:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
 800db0a:	b29a      	uxth	r2, r3
 800db0c:	4b24      	ldr	r3, [pc, #144]	; (800dba0 <TIM3_IRQHandler+0x184>)
 800db0e:	801a      	strh	r2, [r3, #0]
			TIM3->CCR2 = newSample.uBytes[0]; //LSB
 800db10:	4b23      	ldr	r3, [pc, #140]	; (800dba0 <TIM3_IRQHandler+0x184>)
 800db12:	781a      	ldrb	r2, [r3, #0]
 800db14:	4b20      	ldr	r3, [pc, #128]	; (800db98 <TIM3_IRQHandler+0x17c>)
 800db16:	639a      	str	r2, [r3, #56]	; 0x38
			TIM3->CCR1 = newSample.uBytes[1]; //MSB
 800db18:	4b21      	ldr	r3, [pc, #132]	; (800dba0 <TIM3_IRQHandler+0x184>)
 800db1a:	785a      	ldrb	r2, [r3, #1]
 800db1c:	4b1e      	ldr	r3, [pc, #120]	; (800db98 <TIM3_IRQHandler+0x17c>)
 800db1e:	635a      	str	r2, [r3, #52]	; 0x34
			// stop the timer
			LL_TIM_DisableCounter(TIM3);
		}

	}
	return;
 800db20:	e027      	b.n	800db72 <TIM3_IRQHandler+0x156>
		else if (sample_position < AudioFile.AudioSize[AudioFileToPlay])
 800db22:	4b1a      	ldr	r3, [pc, #104]	; (800db8c <TIM3_IRQHandler+0x170>)
 800db24:	881b      	ldrh	r3, [r3, #0]
 800db26:	4619      	mov	r1, r3
 800db28:	4b15      	ldr	r3, [pc, #84]	; (800db80 <TIM3_IRQHandler+0x164>)
 800db2a:	781b      	ldrb	r3, [r3, #0]
 800db2c:	4a18      	ldr	r2, [pc, #96]	; (800db90 <TIM3_IRQHandler+0x174>)
 800db2e:	009b      	lsls	r3, r3, #2
 800db30:	4413      	add	r3, r2
 800db32:	685b      	ldr	r3, [r3, #4]
 800db34:	4299      	cmp	r1, r3
 800db36:	d215      	bcs.n	800db64 <TIM3_IRQHandler+0x148>
			repetition--;
 800db38:	4b13      	ldr	r3, [pc, #76]	; (800db88 <TIM3_IRQHandler+0x16c>)
 800db3a:	781b      	ldrb	r3, [r3, #0]
 800db3c:	3b01      	subs	r3, #1
 800db3e:	b2da      	uxtb	r2, r3
 800db40:	4b11      	ldr	r3, [pc, #68]	; (800db88 <TIM3_IRQHandler+0x16c>)
 800db42:	701a      	strb	r2, [r3, #0]
			newSample.uShort = (uint16_t)32768 + pcmSample;
 800db44:	4b15      	ldr	r3, [pc, #84]	; (800db9c <TIM3_IRQHandler+0x180>)
 800db46:	881b      	ldrh	r3, [r3, #0]
 800db48:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
 800db4c:	b29a      	uxth	r2, r3
 800db4e:	4b14      	ldr	r3, [pc, #80]	; (800dba0 <TIM3_IRQHandler+0x184>)
 800db50:	801a      	strh	r2, [r3, #0]
			TIM3->CCR2 = newSample.uBytes[0]; //LSB
 800db52:	4b13      	ldr	r3, [pc, #76]	; (800dba0 <TIM3_IRQHandler+0x184>)
 800db54:	781a      	ldrb	r2, [r3, #0]
 800db56:	4b10      	ldr	r3, [pc, #64]	; (800db98 <TIM3_IRQHandler+0x17c>)
 800db58:	639a      	str	r2, [r3, #56]	; 0x38
			TIM3->CCR1 = newSample.uBytes[1]; //MSB
 800db5a:	4b11      	ldr	r3, [pc, #68]	; (800dba0 <TIM3_IRQHandler+0x184>)
 800db5c:	785a      	ldrb	r2, [r3, #1]
 800db5e:	4b0e      	ldr	r3, [pc, #56]	; (800db98 <TIM3_IRQHandler+0x17c>)
 800db60:	635a      	str	r2, [r3, #52]	; 0x34
	return;
 800db62:	e006      	b.n	800db72 <TIM3_IRQHandler+0x156>
			NVIC_DisableIRQ(TIM3_IRQn);
 800db64:	201d      	movs	r0, #29
 800db66:	f7ff fecf 	bl	800d908 <__NVIC_DisableIRQ>
			LL_TIM_DisableCounter(TIM3);
 800db6a:	480b      	ldr	r0, [pc, #44]	; (800db98 <TIM3_IRQHandler+0x17c>)
 800db6c:	f7ff fef0 	bl	800d950 <LL_TIM_DisableCounter>
	return;
 800db70:	bf00      	nop
 800db72:	bf00      	nop
  /* USER CODE END TIM3_IRQn 0 */
  /* USER CODE BEGIN TIM3_IRQn 1 */

  /* USER CODE END TIM3_IRQn 1 */
}
 800db74:	3708      	adds	r7, #8
 800db76:	46bd      	mov	sp, r7
 800db78:	bd80      	pop	{r7, pc}
 800db7a:	bf00      	nop
 800db7c:	20000000 	.word	0x20000000
 800db80:	200000f8 	.word	0x200000f8
 800db84:	20000001 	.word	0x20000001
 800db88:	200000fe 	.word	0x200000fe
 800db8c:	20000100 	.word	0x20000100
 800db90:	200000f0 	.word	0x200000f0
 800db94:	20000104 	.word	0x20000104
 800db98:	40000400 	.word	0x40000400
 800db9c:	20000108 	.word	0x20000108
 800dba0:	200000fc 	.word	0x200000fc

0800dba4 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800dba4:	b480      	push	{r7}
 800dba6:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800dba8:	4b06      	ldr	r3, [pc, #24]	; (800dbc4 <SystemInit+0x20>)
 800dbaa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800dbae:	4a05      	ldr	r2, [pc, #20]	; (800dbc4 <SystemInit+0x20>)
 800dbb0:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800dbb4:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 800dbb8:	bf00      	nop
 800dbba:	46bd      	mov	sp, r7
 800dbbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbc0:	4770      	bx	lr
 800dbc2:	bf00      	nop
 800dbc4:	e000ed00 	.word	0xe000ed00

0800dbc8 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 800dbc8:	f8df d034 	ldr.w	sp, [pc, #52]	; 800dc00 <LoopFillZerobss+0x12>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 800dbcc:	480d      	ldr	r0, [pc, #52]	; (800dc04 <LoopFillZerobss+0x16>)
  ldr r1, =_edata
 800dbce:	490e      	ldr	r1, [pc, #56]	; (800dc08 <LoopFillZerobss+0x1a>)
  ldr r2, =_sidata
 800dbd0:	4a0e      	ldr	r2, [pc, #56]	; (800dc0c <LoopFillZerobss+0x1e>)
  movs r3, #0
 800dbd2:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800dbd4:	e002      	b.n	800dbdc <LoopCopyDataInit>

0800dbd6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800dbd6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800dbd8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800dbda:	3304      	adds	r3, #4

0800dbdc <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800dbdc:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800dbde:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800dbe0:	d3f9      	bcc.n	800dbd6 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800dbe2:	4a0b      	ldr	r2, [pc, #44]	; (800dc10 <LoopFillZerobss+0x22>)
  ldr r4, =_ebss
 800dbe4:	4c0b      	ldr	r4, [pc, #44]	; (800dc14 <LoopFillZerobss+0x26>)
  movs r3, #0
 800dbe6:	2300      	movs	r3, #0
  b LoopFillZerobss
 800dbe8:	e001      	b.n	800dbee <LoopFillZerobss>

0800dbea <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800dbea:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800dbec:	3204      	adds	r2, #4

0800dbee <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800dbee:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800dbf0:	d3fb      	bcc.n	800dbea <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800dbf2:	f7ff ffd7 	bl	800dba4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800dbf6:	f002 fa91 	bl	801011c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800dbfa:	f7ff fb25 	bl	800d248 <main>
  bx  lr    
 800dbfe:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 800dc00:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 800dc04:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800dc08:	20000010 	.word	0x20000010
  ldr r2, =_sidata
 800dc0c:	08010278 	.word	0x08010278
  ldr r2, =_sbss
 800dc10:	20000010 	.word	0x20000010
  ldr r4, =_ebss
 800dc14:	20000110 	.word	0x20000110

0800dc18 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800dc18:	e7fe      	b.n	800dc18 <ADC_IRQHandler>
	...

0800dc1c <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800dc1c:	b580      	push	{r7, lr}
 800dc1e:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800dc20:	4b0e      	ldr	r3, [pc, #56]	; (800dc5c <HAL_Init+0x40>)
 800dc22:	681b      	ldr	r3, [r3, #0]
 800dc24:	4a0d      	ldr	r2, [pc, #52]	; (800dc5c <HAL_Init+0x40>)
 800dc26:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800dc2a:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 800dc2c:	4b0b      	ldr	r3, [pc, #44]	; (800dc5c <HAL_Init+0x40>)
 800dc2e:	681b      	ldr	r3, [r3, #0]
 800dc30:	4a0a      	ldr	r2, [pc, #40]	; (800dc5c <HAL_Init+0x40>)
 800dc32:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800dc36:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800dc38:	4b08      	ldr	r3, [pc, #32]	; (800dc5c <HAL_Init+0x40>)
 800dc3a:	681b      	ldr	r3, [r3, #0]
 800dc3c:	4a07      	ldr	r2, [pc, #28]	; (800dc5c <HAL_Init+0x40>)
 800dc3e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800dc42:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800dc44:	2003      	movs	r0, #3
 800dc46:	f000 f94f 	bl	800dee8 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800dc4a:	2000      	movs	r0, #0
 800dc4c:	f000 f808 	bl	800dc60 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800dc50:	f7ff fd44 	bl	800d6dc <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800dc54:	2300      	movs	r3, #0
}
 800dc56:	4618      	mov	r0, r3
 800dc58:	bd80      	pop	{r7, pc}
 800dc5a:	bf00      	nop
 800dc5c:	40023c00 	.word	0x40023c00

0800dc60 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800dc60:	b580      	push	{r7, lr}
 800dc62:	b082      	sub	sp, #8
 800dc64:	af00      	add	r7, sp, #0
 800dc66:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800dc68:	4b12      	ldr	r3, [pc, #72]	; (800dcb4 <HAL_InitTick+0x54>)
 800dc6a:	681a      	ldr	r2, [r3, #0]
 800dc6c:	4b12      	ldr	r3, [pc, #72]	; (800dcb8 <HAL_InitTick+0x58>)
 800dc6e:	781b      	ldrb	r3, [r3, #0]
 800dc70:	4619      	mov	r1, r3
 800dc72:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800dc76:	fbb3 f3f1 	udiv	r3, r3, r1
 800dc7a:	fbb2 f3f3 	udiv	r3, r2, r3
 800dc7e:	4618      	mov	r0, r3
 800dc80:	f000 f967 	bl	800df52 <HAL_SYSTICK_Config>
 800dc84:	4603      	mov	r3, r0
 800dc86:	2b00      	cmp	r3, #0
 800dc88:	d001      	beq.n	800dc8e <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 800dc8a:	2301      	movs	r3, #1
 800dc8c:	e00e      	b.n	800dcac <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800dc8e:	687b      	ldr	r3, [r7, #4]
 800dc90:	2b0f      	cmp	r3, #15
 800dc92:	d80a      	bhi.n	800dcaa <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800dc94:	2200      	movs	r2, #0
 800dc96:	6879      	ldr	r1, [r7, #4]
 800dc98:	f04f 30ff 	mov.w	r0, #4294967295
 800dc9c:	f000 f92f 	bl	800defe <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800dca0:	4a06      	ldr	r2, [pc, #24]	; (800dcbc <HAL_InitTick+0x5c>)
 800dca2:	687b      	ldr	r3, [r7, #4]
 800dca4:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 800dca6:	2300      	movs	r3, #0
 800dca8:	e000      	b.n	800dcac <HAL_InitTick+0x4c>
    return HAL_ERROR;
 800dcaa:	2301      	movs	r3, #1
}
 800dcac:	4618      	mov	r0, r3
 800dcae:	3708      	adds	r7, #8
 800dcb0:	46bd      	mov	sp, r7
 800dcb2:	bd80      	pop	{r7, pc}
 800dcb4:	20000004 	.word	0x20000004
 800dcb8:	2000000c 	.word	0x2000000c
 800dcbc:	20000008 	.word	0x20000008

0800dcc0 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800dcc0:	b480      	push	{r7}
 800dcc2:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 800dcc4:	4b06      	ldr	r3, [pc, #24]	; (800dce0 <HAL_IncTick+0x20>)
 800dcc6:	781b      	ldrb	r3, [r3, #0]
 800dcc8:	461a      	mov	r2, r3
 800dcca:	4b06      	ldr	r3, [pc, #24]	; (800dce4 <HAL_IncTick+0x24>)
 800dccc:	681b      	ldr	r3, [r3, #0]
 800dcce:	4413      	add	r3, r2
 800dcd0:	4a04      	ldr	r2, [pc, #16]	; (800dce4 <HAL_IncTick+0x24>)
 800dcd2:	6013      	str	r3, [r2, #0]
}
 800dcd4:	bf00      	nop
 800dcd6:	46bd      	mov	sp, r7
 800dcd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dcdc:	4770      	bx	lr
 800dcde:	bf00      	nop
 800dce0:	2000000c 	.word	0x2000000c
 800dce4:	2000010c 	.word	0x2000010c

0800dce8 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800dce8:	b480      	push	{r7}
 800dcea:	af00      	add	r7, sp, #0
  return uwTick;
 800dcec:	4b03      	ldr	r3, [pc, #12]	; (800dcfc <HAL_GetTick+0x14>)
 800dcee:	681b      	ldr	r3, [r3, #0]
}
 800dcf0:	4618      	mov	r0, r3
 800dcf2:	46bd      	mov	sp, r7
 800dcf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dcf8:	4770      	bx	lr
 800dcfa:	bf00      	nop
 800dcfc:	2000010c 	.word	0x2000010c

0800dd00 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800dd00:	b580      	push	{r7, lr}
 800dd02:	b084      	sub	sp, #16
 800dd04:	af00      	add	r7, sp, #0
 800dd06:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 800dd08:	f7ff ffee 	bl	800dce8 <HAL_GetTick>
 800dd0c:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 800dd0e:	687b      	ldr	r3, [r7, #4]
 800dd10:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800dd12:	68fb      	ldr	r3, [r7, #12]
 800dd14:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dd18:	d005      	beq.n	800dd26 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 800dd1a:	4b0a      	ldr	r3, [pc, #40]	; (800dd44 <HAL_Delay+0x44>)
 800dd1c:	781b      	ldrb	r3, [r3, #0]
 800dd1e:	461a      	mov	r2, r3
 800dd20:	68fb      	ldr	r3, [r7, #12]
 800dd22:	4413      	add	r3, r2
 800dd24:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 800dd26:	bf00      	nop
 800dd28:	f7ff ffde 	bl	800dce8 <HAL_GetTick>
 800dd2c:	4602      	mov	r2, r0
 800dd2e:	68bb      	ldr	r3, [r7, #8]
 800dd30:	1ad3      	subs	r3, r2, r3
 800dd32:	68fa      	ldr	r2, [r7, #12]
 800dd34:	429a      	cmp	r2, r3
 800dd36:	d8f7      	bhi.n	800dd28 <HAL_Delay+0x28>
  {
  }
}
 800dd38:	bf00      	nop
 800dd3a:	bf00      	nop
 800dd3c:	3710      	adds	r7, #16
 800dd3e:	46bd      	mov	sp, r7
 800dd40:	bd80      	pop	{r7, pc}
 800dd42:	bf00      	nop
 800dd44:	2000000c 	.word	0x2000000c

0800dd48 <__NVIC_SetPriorityGrouping>:
{
 800dd48:	b480      	push	{r7}
 800dd4a:	b085      	sub	sp, #20
 800dd4c:	af00      	add	r7, sp, #0
 800dd4e:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800dd50:	687b      	ldr	r3, [r7, #4]
 800dd52:	f003 0307 	and.w	r3, r3, #7
 800dd56:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800dd58:	4b0c      	ldr	r3, [pc, #48]	; (800dd8c <__NVIC_SetPriorityGrouping+0x44>)
 800dd5a:	68db      	ldr	r3, [r3, #12]
 800dd5c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800dd5e:	68ba      	ldr	r2, [r7, #8]
 800dd60:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800dd64:	4013      	ands	r3, r2
 800dd66:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800dd68:	68fb      	ldr	r3, [r7, #12]
 800dd6a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800dd6c:	68bb      	ldr	r3, [r7, #8]
 800dd6e:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800dd70:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800dd74:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800dd78:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800dd7a:	4a04      	ldr	r2, [pc, #16]	; (800dd8c <__NVIC_SetPriorityGrouping+0x44>)
 800dd7c:	68bb      	ldr	r3, [r7, #8]
 800dd7e:	60d3      	str	r3, [r2, #12]
}
 800dd80:	bf00      	nop
 800dd82:	3714      	adds	r7, #20
 800dd84:	46bd      	mov	sp, r7
 800dd86:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd8a:	4770      	bx	lr
 800dd8c:	e000ed00 	.word	0xe000ed00

0800dd90 <__NVIC_GetPriorityGrouping>:
{
 800dd90:	b480      	push	{r7}
 800dd92:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800dd94:	4b04      	ldr	r3, [pc, #16]	; (800dda8 <__NVIC_GetPriorityGrouping+0x18>)
 800dd96:	68db      	ldr	r3, [r3, #12]
 800dd98:	0a1b      	lsrs	r3, r3, #8
 800dd9a:	f003 0307 	and.w	r3, r3, #7
}
 800dd9e:	4618      	mov	r0, r3
 800dda0:	46bd      	mov	sp, r7
 800dda2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dda6:	4770      	bx	lr
 800dda8:	e000ed00 	.word	0xe000ed00

0800ddac <__NVIC_EnableIRQ>:
{
 800ddac:	b480      	push	{r7}
 800ddae:	b083      	sub	sp, #12
 800ddb0:	af00      	add	r7, sp, #0
 800ddb2:	4603      	mov	r3, r0
 800ddb4:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800ddb6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800ddba:	2b00      	cmp	r3, #0
 800ddbc:	db0b      	blt.n	800ddd6 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800ddbe:	79fb      	ldrb	r3, [r7, #7]
 800ddc0:	f003 021f 	and.w	r2, r3, #31
 800ddc4:	4907      	ldr	r1, [pc, #28]	; (800dde4 <__NVIC_EnableIRQ+0x38>)
 800ddc6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800ddca:	095b      	lsrs	r3, r3, #5
 800ddcc:	2001      	movs	r0, #1
 800ddce:	fa00 f202 	lsl.w	r2, r0, r2
 800ddd2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800ddd6:	bf00      	nop
 800ddd8:	370c      	adds	r7, #12
 800ddda:	46bd      	mov	sp, r7
 800dddc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dde0:	4770      	bx	lr
 800dde2:	bf00      	nop
 800dde4:	e000e100 	.word	0xe000e100

0800dde8 <__NVIC_SetPriority>:
{
 800dde8:	b480      	push	{r7}
 800ddea:	b083      	sub	sp, #12
 800ddec:	af00      	add	r7, sp, #0
 800ddee:	4603      	mov	r3, r0
 800ddf0:	6039      	str	r1, [r7, #0]
 800ddf2:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800ddf4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800ddf8:	2b00      	cmp	r3, #0
 800ddfa:	db0a      	blt.n	800de12 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800ddfc:	683b      	ldr	r3, [r7, #0]
 800ddfe:	b2da      	uxtb	r2, r3
 800de00:	490c      	ldr	r1, [pc, #48]	; (800de34 <__NVIC_SetPriority+0x4c>)
 800de02:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800de06:	0112      	lsls	r2, r2, #4
 800de08:	b2d2      	uxtb	r2, r2
 800de0a:	440b      	add	r3, r1
 800de0c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 800de10:	e00a      	b.n	800de28 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800de12:	683b      	ldr	r3, [r7, #0]
 800de14:	b2da      	uxtb	r2, r3
 800de16:	4908      	ldr	r1, [pc, #32]	; (800de38 <__NVIC_SetPriority+0x50>)
 800de18:	79fb      	ldrb	r3, [r7, #7]
 800de1a:	f003 030f 	and.w	r3, r3, #15
 800de1e:	3b04      	subs	r3, #4
 800de20:	0112      	lsls	r2, r2, #4
 800de22:	b2d2      	uxtb	r2, r2
 800de24:	440b      	add	r3, r1
 800de26:	761a      	strb	r2, [r3, #24]
}
 800de28:	bf00      	nop
 800de2a:	370c      	adds	r7, #12
 800de2c:	46bd      	mov	sp, r7
 800de2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de32:	4770      	bx	lr
 800de34:	e000e100 	.word	0xe000e100
 800de38:	e000ed00 	.word	0xe000ed00

0800de3c <NVIC_EncodePriority>:
{
 800de3c:	b480      	push	{r7}
 800de3e:	b089      	sub	sp, #36	; 0x24
 800de40:	af00      	add	r7, sp, #0
 800de42:	60f8      	str	r0, [r7, #12]
 800de44:	60b9      	str	r1, [r7, #8]
 800de46:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800de48:	68fb      	ldr	r3, [r7, #12]
 800de4a:	f003 0307 	and.w	r3, r3, #7
 800de4e:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800de50:	69fb      	ldr	r3, [r7, #28]
 800de52:	f1c3 0307 	rsb	r3, r3, #7
 800de56:	2b04      	cmp	r3, #4
 800de58:	bf28      	it	cs
 800de5a:	2304      	movcs	r3, #4
 800de5c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800de5e:	69fb      	ldr	r3, [r7, #28]
 800de60:	3304      	adds	r3, #4
 800de62:	2b06      	cmp	r3, #6
 800de64:	d902      	bls.n	800de6c <NVIC_EncodePriority+0x30>
 800de66:	69fb      	ldr	r3, [r7, #28]
 800de68:	3b03      	subs	r3, #3
 800de6a:	e000      	b.n	800de6e <NVIC_EncodePriority+0x32>
 800de6c:	2300      	movs	r3, #0
 800de6e:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800de70:	f04f 32ff 	mov.w	r2, #4294967295
 800de74:	69bb      	ldr	r3, [r7, #24]
 800de76:	fa02 f303 	lsl.w	r3, r2, r3
 800de7a:	43da      	mvns	r2, r3
 800de7c:	68bb      	ldr	r3, [r7, #8]
 800de7e:	401a      	ands	r2, r3
 800de80:	697b      	ldr	r3, [r7, #20]
 800de82:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800de84:	f04f 31ff 	mov.w	r1, #4294967295
 800de88:	697b      	ldr	r3, [r7, #20]
 800de8a:	fa01 f303 	lsl.w	r3, r1, r3
 800de8e:	43d9      	mvns	r1, r3
 800de90:	687b      	ldr	r3, [r7, #4]
 800de92:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800de94:	4313      	orrs	r3, r2
}
 800de96:	4618      	mov	r0, r3
 800de98:	3724      	adds	r7, #36	; 0x24
 800de9a:	46bd      	mov	sp, r7
 800de9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dea0:	4770      	bx	lr
	...

0800dea4 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800dea4:	b580      	push	{r7, lr}
 800dea6:	b082      	sub	sp, #8
 800dea8:	af00      	add	r7, sp, #0
 800deaa:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800deac:	687b      	ldr	r3, [r7, #4]
 800deae:	3b01      	subs	r3, #1
 800deb0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800deb4:	d301      	bcc.n	800deba <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800deb6:	2301      	movs	r3, #1
 800deb8:	e00f      	b.n	800deda <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800deba:	4a0a      	ldr	r2, [pc, #40]	; (800dee4 <SysTick_Config+0x40>)
 800debc:	687b      	ldr	r3, [r7, #4]
 800debe:	3b01      	subs	r3, #1
 800dec0:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800dec2:	210f      	movs	r1, #15
 800dec4:	f04f 30ff 	mov.w	r0, #4294967295
 800dec8:	f7ff ff8e 	bl	800dde8 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800decc:	4b05      	ldr	r3, [pc, #20]	; (800dee4 <SysTick_Config+0x40>)
 800dece:	2200      	movs	r2, #0
 800ded0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800ded2:	4b04      	ldr	r3, [pc, #16]	; (800dee4 <SysTick_Config+0x40>)
 800ded4:	2207      	movs	r2, #7
 800ded6:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800ded8:	2300      	movs	r3, #0
}
 800deda:	4618      	mov	r0, r3
 800dedc:	3708      	adds	r7, #8
 800dede:	46bd      	mov	sp, r7
 800dee0:	bd80      	pop	{r7, pc}
 800dee2:	bf00      	nop
 800dee4:	e000e010 	.word	0xe000e010

0800dee8 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800dee8:	b580      	push	{r7, lr}
 800deea:	b082      	sub	sp, #8
 800deec:	af00      	add	r7, sp, #0
 800deee:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800def0:	6878      	ldr	r0, [r7, #4]
 800def2:	f7ff ff29 	bl	800dd48 <__NVIC_SetPriorityGrouping>
}
 800def6:	bf00      	nop
 800def8:	3708      	adds	r7, #8
 800defa:	46bd      	mov	sp, r7
 800defc:	bd80      	pop	{r7, pc}

0800defe <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800defe:	b580      	push	{r7, lr}
 800df00:	b086      	sub	sp, #24
 800df02:	af00      	add	r7, sp, #0
 800df04:	4603      	mov	r3, r0
 800df06:	60b9      	str	r1, [r7, #8]
 800df08:	607a      	str	r2, [r7, #4]
 800df0a:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 800df0c:	2300      	movs	r3, #0
 800df0e:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800df10:	f7ff ff3e 	bl	800dd90 <__NVIC_GetPriorityGrouping>
 800df14:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800df16:	687a      	ldr	r2, [r7, #4]
 800df18:	68b9      	ldr	r1, [r7, #8]
 800df1a:	6978      	ldr	r0, [r7, #20]
 800df1c:	f7ff ff8e 	bl	800de3c <NVIC_EncodePriority>
 800df20:	4602      	mov	r2, r0
 800df22:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800df26:	4611      	mov	r1, r2
 800df28:	4618      	mov	r0, r3
 800df2a:	f7ff ff5d 	bl	800dde8 <__NVIC_SetPriority>
}
 800df2e:	bf00      	nop
 800df30:	3718      	adds	r7, #24
 800df32:	46bd      	mov	sp, r7
 800df34:	bd80      	pop	{r7, pc}

0800df36 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800df36:	b580      	push	{r7, lr}
 800df38:	b082      	sub	sp, #8
 800df3a:	af00      	add	r7, sp, #0
 800df3c:	4603      	mov	r3, r0
 800df3e:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800df40:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800df44:	4618      	mov	r0, r3
 800df46:	f7ff ff31 	bl	800ddac <__NVIC_EnableIRQ>
}
 800df4a:	bf00      	nop
 800df4c:	3708      	adds	r7, #8
 800df4e:	46bd      	mov	sp, r7
 800df50:	bd80      	pop	{r7, pc}

0800df52 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800df52:	b580      	push	{r7, lr}
 800df54:	b082      	sub	sp, #8
 800df56:	af00      	add	r7, sp, #0
 800df58:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800df5a:	6878      	ldr	r0, [r7, #4]
 800df5c:	f7ff ffa2 	bl	800dea4 <SysTick_Config>
 800df60:	4603      	mov	r3, r0
}
 800df62:	4618      	mov	r0, r3
 800df64:	3708      	adds	r7, #8
 800df66:	46bd      	mov	sp, r7
 800df68:	bd80      	pop	{r7, pc}

0800df6a <HAL_DAC_Init>:
  * @param  hdac pointer to a DAC_HandleTypeDef structure that contains
  *         the configuration information for the specified DAC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_Init(DAC_HandleTypeDef *hdac)
{
 800df6a:	b580      	push	{r7, lr}
 800df6c:	b082      	sub	sp, #8
 800df6e:	af00      	add	r7, sp, #0
 800df70:	6078      	str	r0, [r7, #4]
  /* Check DAC handle */
  if (hdac == NULL)
 800df72:	687b      	ldr	r3, [r7, #4]
 800df74:	2b00      	cmp	r3, #0
 800df76:	d101      	bne.n	800df7c <HAL_DAC_Init+0x12>
  {
    return HAL_ERROR;
 800df78:	2301      	movs	r3, #1
 800df7a:	e014      	b.n	800dfa6 <HAL_DAC_Init+0x3c>
  }
  /* Check the parameters */
  assert_param(IS_DAC_ALL_INSTANCE(hdac->Instance));

  if (hdac->State == HAL_DAC_STATE_RESET)
 800df7c:	687b      	ldr	r3, [r7, #4]
 800df7e:	791b      	ldrb	r3, [r3, #4]
 800df80:	b2db      	uxtb	r3, r3
 800df82:	2b00      	cmp	r3, #0
 800df84:	d105      	bne.n	800df92 <HAL_DAC_Init+0x28>
      hdac->MspInitCallback             = HAL_DAC_MspInit;
    }
#endif /* USE_HAL_DAC_REGISTER_CALLBACKS */

    /* Allocate lock resource and initialize it */
    hdac->Lock = HAL_UNLOCKED;
 800df86:	687b      	ldr	r3, [r7, #4]
 800df88:	2200      	movs	r2, #0
 800df8a:	715a      	strb	r2, [r3, #5]
#if (USE_HAL_DAC_REGISTER_CALLBACKS == 1)
    /* Init the low level hardware */
    hdac->MspInitCallback(hdac);
#else
    /* Init the low level hardware */
    HAL_DAC_MspInit(hdac);
 800df8c:	6878      	ldr	r0, [r7, #4]
 800df8e:	f7ff fbcd 	bl	800d72c <HAL_DAC_MspInit>
#endif /* USE_HAL_DAC_REGISTER_CALLBACKS */
  }

  /* Initialize the DAC state*/
  hdac->State = HAL_DAC_STATE_BUSY;
 800df92:	687b      	ldr	r3, [r7, #4]
 800df94:	2202      	movs	r2, #2
 800df96:	711a      	strb	r2, [r3, #4]

  /* Set DAC error code to none */
  hdac->ErrorCode = HAL_DAC_ERROR_NONE;
 800df98:	687b      	ldr	r3, [r7, #4]
 800df9a:	2200      	movs	r2, #0
 800df9c:	611a      	str	r2, [r3, #16]

  /* Initialize the DAC state*/
  hdac->State = HAL_DAC_STATE_READY;
 800df9e:	687b      	ldr	r3, [r7, #4]
 800dfa0:	2201      	movs	r2, #1
 800dfa2:	711a      	strb	r2, [r3, #4]

  /* Return function status */
  return HAL_OK;
 800dfa4:	2300      	movs	r3, #0
}
 800dfa6:	4618      	mov	r0, r3
 800dfa8:	3708      	adds	r7, #8
 800dfaa:	46bd      	mov	sp, r7
 800dfac:	bd80      	pop	{r7, pc}

0800dfae <HAL_DAC_ConfigChannel>:
  *            @arg DAC_CHANNEL_1: DAC Channel1 selected
  *            @arg DAC_CHANNEL_2: DAC Channel2 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DAC_ConfigChannel(DAC_HandleTypeDef *hdac, DAC_ChannelConfTypeDef *sConfig, uint32_t Channel)
{
 800dfae:	b480      	push	{r7}
 800dfb0:	b087      	sub	sp, #28
 800dfb2:	af00      	add	r7, sp, #0
 800dfb4:	60f8      	str	r0, [r7, #12]
 800dfb6:	60b9      	str	r1, [r7, #8]
 800dfb8:	607a      	str	r2, [r7, #4]
  assert_param(IS_DAC_TRIGGER(sConfig->DAC_Trigger));
  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(sConfig->DAC_OutputBuffer));
  assert_param(IS_DAC_CHANNEL(Channel));

  /* Process locked */
  __HAL_LOCK(hdac);
 800dfba:	68fb      	ldr	r3, [r7, #12]
 800dfbc:	795b      	ldrb	r3, [r3, #5]
 800dfbe:	2b01      	cmp	r3, #1
 800dfc0:	d101      	bne.n	800dfc6 <HAL_DAC_ConfigChannel+0x18>
 800dfc2:	2302      	movs	r3, #2
 800dfc4:	e03c      	b.n	800e040 <HAL_DAC_ConfigChannel+0x92>
 800dfc6:	68fb      	ldr	r3, [r7, #12]
 800dfc8:	2201      	movs	r2, #1
 800dfca:	715a      	strb	r2, [r3, #5]

  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_BUSY;
 800dfcc:	68fb      	ldr	r3, [r7, #12]
 800dfce:	2202      	movs	r2, #2
 800dfd0:	711a      	strb	r2, [r3, #4]

  /* Get the DAC CR value */
  tmpreg1 = hdac->Instance->CR;
 800dfd2:	68fb      	ldr	r3, [r7, #12]
 800dfd4:	681b      	ldr	r3, [r3, #0]
 800dfd6:	681b      	ldr	r3, [r3, #0]
 800dfd8:	617b      	str	r3, [r7, #20]
  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
  tmpreg1 &= ~(((uint32_t)(DAC_CR_MAMP1 | DAC_CR_WAVE1 | DAC_CR_TSEL1 | DAC_CR_TEN1 | DAC_CR_BOFF1)) << (Channel & 0x10UL));
 800dfda:	687b      	ldr	r3, [r7, #4]
 800dfdc:	f003 0310 	and.w	r3, r3, #16
 800dfe0:	f640 72fe 	movw	r2, #4094	; 0xffe
 800dfe4:	fa02 f303 	lsl.w	r3, r2, r3
 800dfe8:	43db      	mvns	r3, r3
 800dfea:	697a      	ldr	r2, [r7, #20]
 800dfec:	4013      	ands	r3, r2
 800dfee:	617b      	str	r3, [r7, #20]
  /* Configure for the selected DAC channel: buffer output, trigger */
  /* Set TSELx and TENx bits according to DAC_Trigger value */
  /* Set BOFFx bit according to DAC_OutputBuffer value */
  tmpreg2 = (sConfig->DAC_Trigger | sConfig->DAC_OutputBuffer);
 800dff0:	68bb      	ldr	r3, [r7, #8]
 800dff2:	681a      	ldr	r2, [r3, #0]
 800dff4:	68bb      	ldr	r3, [r7, #8]
 800dff6:	685b      	ldr	r3, [r3, #4]
 800dff8:	4313      	orrs	r3, r2
 800dffa:	613b      	str	r3, [r7, #16]
  /* Calculate CR register value depending on DAC_Channel */
  tmpreg1 |= tmpreg2 << (Channel & 0x10UL);
 800dffc:	687b      	ldr	r3, [r7, #4]
 800dffe:	f003 0310 	and.w	r3, r3, #16
 800e002:	693a      	ldr	r2, [r7, #16]
 800e004:	fa02 f303 	lsl.w	r3, r2, r3
 800e008:	697a      	ldr	r2, [r7, #20]
 800e00a:	4313      	orrs	r3, r2
 800e00c:	617b      	str	r3, [r7, #20]
  /* Write to DAC CR */
  hdac->Instance->CR = tmpreg1;
 800e00e:	68fb      	ldr	r3, [r7, #12]
 800e010:	681b      	ldr	r3, [r3, #0]
 800e012:	697a      	ldr	r2, [r7, #20]
 800e014:	601a      	str	r2, [r3, #0]
  /* Disable wave generation */
  CLEAR_BIT(hdac->Instance->CR, (DAC_CR_WAVE1 << (Channel & 0x10UL)));
 800e016:	68fb      	ldr	r3, [r7, #12]
 800e018:	681b      	ldr	r3, [r3, #0]
 800e01a:	6819      	ldr	r1, [r3, #0]
 800e01c:	687b      	ldr	r3, [r7, #4]
 800e01e:	f003 0310 	and.w	r3, r3, #16
 800e022:	22c0      	movs	r2, #192	; 0xc0
 800e024:	fa02 f303 	lsl.w	r3, r2, r3
 800e028:	43da      	mvns	r2, r3
 800e02a:	68fb      	ldr	r3, [r7, #12]
 800e02c:	681b      	ldr	r3, [r3, #0]
 800e02e:	400a      	ands	r2, r1
 800e030:	601a      	str	r2, [r3, #0]

  /* Change DAC state */
  hdac->State = HAL_DAC_STATE_READY;
 800e032:	68fb      	ldr	r3, [r7, #12]
 800e034:	2201      	movs	r2, #1
 800e036:	711a      	strb	r2, [r3, #4]

  /* Process unlocked */
  __HAL_UNLOCK(hdac);
 800e038:	68fb      	ldr	r3, [r7, #12]
 800e03a:	2200      	movs	r2, #0
 800e03c:	715a      	strb	r2, [r3, #5]

  /* Return function status */
  return HAL_OK;
 800e03e:	2300      	movs	r3, #0
}
 800e040:	4618      	mov	r0, r3
 800e042:	371c      	adds	r7, #28
 800e044:	46bd      	mov	sp, r7
 800e046:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e04a:	4770      	bx	lr

0800e04c <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 800e04c:	b580      	push	{r7, lr}
 800e04e:	b086      	sub	sp, #24
 800e050:	af00      	add	r7, sp, #0
 800e052:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 800e054:	2300      	movs	r3, #0
 800e056:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
 800e058:	f7ff fe46 	bl	800dce8 <HAL_GetTick>
 800e05c:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 800e05e:	687b      	ldr	r3, [r7, #4]
 800e060:	2b00      	cmp	r3, #0
 800e062:	d101      	bne.n	800e068 <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
 800e064:	2301      	movs	r3, #1
 800e066:	e099      	b.n	800e19c <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 800e068:	687b      	ldr	r3, [r7, #4]
 800e06a:	2202      	movs	r2, #2
 800e06c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 800e070:	687b      	ldr	r3, [r7, #4]
 800e072:	2200      	movs	r2, #0
 800e074:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 800e078:	687b      	ldr	r3, [r7, #4]
 800e07a:	681b      	ldr	r3, [r3, #0]
 800e07c:	681a      	ldr	r2, [r3, #0]
 800e07e:	687b      	ldr	r3, [r7, #4]
 800e080:	681b      	ldr	r3, [r3, #0]
 800e082:	f022 0201 	bic.w	r2, r2, #1
 800e086:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 800e088:	e00f      	b.n	800e0aa <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 800e08a:	f7ff fe2d 	bl	800dce8 <HAL_GetTick>
 800e08e:	4602      	mov	r2, r0
 800e090:	693b      	ldr	r3, [r7, #16]
 800e092:	1ad3      	subs	r3, r2, r3
 800e094:	2b05      	cmp	r3, #5
 800e096:	d908      	bls.n	800e0aa <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800e098:	687b      	ldr	r3, [r7, #4]
 800e09a:	2220      	movs	r2, #32
 800e09c:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 800e09e:	687b      	ldr	r3, [r7, #4]
 800e0a0:	2203      	movs	r2, #3
 800e0a2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      return HAL_TIMEOUT;
 800e0a6:	2303      	movs	r3, #3
 800e0a8:	e078      	b.n	800e19c <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 800e0aa:	687b      	ldr	r3, [r7, #4]
 800e0ac:	681b      	ldr	r3, [r3, #0]
 800e0ae:	681b      	ldr	r3, [r3, #0]
 800e0b0:	f003 0301 	and.w	r3, r3, #1
 800e0b4:	2b00      	cmp	r3, #0
 800e0b6:	d1e8      	bne.n	800e08a <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 800e0b8:	687b      	ldr	r3, [r7, #4]
 800e0ba:	681b      	ldr	r3, [r3, #0]
 800e0bc:	681b      	ldr	r3, [r3, #0]
 800e0be:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800e0c0:	697a      	ldr	r2, [r7, #20]
 800e0c2:	4b38      	ldr	r3, [pc, #224]	; (800e1a4 <HAL_DMA_Init+0x158>)
 800e0c4:	4013      	ands	r3, r2
 800e0c6:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800e0c8:	687b      	ldr	r3, [r7, #4]
 800e0ca:	685a      	ldr	r2, [r3, #4]
 800e0cc:	687b      	ldr	r3, [r7, #4]
 800e0ce:	689b      	ldr	r3, [r3, #8]
 800e0d0:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800e0d2:	687b      	ldr	r3, [r7, #4]
 800e0d4:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800e0d6:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800e0d8:	687b      	ldr	r3, [r7, #4]
 800e0da:	691b      	ldr	r3, [r3, #16]
 800e0dc:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800e0de:	687b      	ldr	r3, [r7, #4]
 800e0e0:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800e0e2:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800e0e4:	687b      	ldr	r3, [r7, #4]
 800e0e6:	699b      	ldr	r3, [r3, #24]
 800e0e8:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 800e0ea:	687b      	ldr	r3, [r7, #4]
 800e0ec:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800e0ee:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 800e0f0:	687b      	ldr	r3, [r7, #4]
 800e0f2:	6a1b      	ldr	r3, [r3, #32]
 800e0f4:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800e0f6:	697a      	ldr	r2, [r7, #20]
 800e0f8:	4313      	orrs	r3, r2
 800e0fa:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800e0fc:	687b      	ldr	r3, [r7, #4]
 800e0fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e100:	2b04      	cmp	r3, #4
 800e102:	d107      	bne.n	800e114 <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800e104:	687b      	ldr	r3, [r7, #4]
 800e106:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800e108:	687b      	ldr	r3, [r7, #4]
 800e10a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e10c:	4313      	orrs	r3, r2
 800e10e:	697a      	ldr	r2, [r7, #20]
 800e110:	4313      	orrs	r3, r2
 800e112:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 800e114:	687b      	ldr	r3, [r7, #4]
 800e116:	681b      	ldr	r3, [r3, #0]
 800e118:	697a      	ldr	r2, [r7, #20]
 800e11a:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 800e11c:	687b      	ldr	r3, [r7, #4]
 800e11e:	681b      	ldr	r3, [r3, #0]
 800e120:	695b      	ldr	r3, [r3, #20]
 800e122:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800e124:	697b      	ldr	r3, [r7, #20]
 800e126:	f023 0307 	bic.w	r3, r3, #7
 800e12a:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 800e12c:	687b      	ldr	r3, [r7, #4]
 800e12e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e130:	697a      	ldr	r2, [r7, #20]
 800e132:	4313      	orrs	r3, r2
 800e134:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800e136:	687b      	ldr	r3, [r7, #4]
 800e138:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e13a:	2b04      	cmp	r3, #4
 800e13c:	d117      	bne.n	800e16e <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 800e13e:	687b      	ldr	r3, [r7, #4]
 800e140:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e142:	697a      	ldr	r2, [r7, #20]
 800e144:	4313      	orrs	r3, r2
 800e146:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 800e148:	687b      	ldr	r3, [r7, #4]
 800e14a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e14c:	2b00      	cmp	r3, #0
 800e14e:	d00e      	beq.n	800e16e <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
 800e150:	6878      	ldr	r0, [r7, #4]
 800e152:	f000 f9e9 	bl	800e528 <DMA_CheckFifoParam>
 800e156:	4603      	mov	r3, r0
 800e158:	2b00      	cmp	r3, #0
 800e15a:	d008      	beq.n	800e16e <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800e15c:	687b      	ldr	r3, [r7, #4]
 800e15e:	2240      	movs	r2, #64	; 0x40
 800e160:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 800e162:	687b      	ldr	r3, [r7, #4]
 800e164:	2201      	movs	r2, #1
 800e166:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_ERROR; 
 800e16a:	2301      	movs	r3, #1
 800e16c:	e016      	b.n	800e19c <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 800e16e:	687b      	ldr	r3, [r7, #4]
 800e170:	681b      	ldr	r3, [r3, #0]
 800e172:	697a      	ldr	r2, [r7, #20]
 800e174:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800e176:	6878      	ldr	r0, [r7, #4]
 800e178:	f000 f9a0 	bl	800e4bc <DMA_CalcBaseAndBitshift>
 800e17c:	4603      	mov	r3, r0
 800e17e:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 800e180:	687b      	ldr	r3, [r7, #4]
 800e182:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e184:	223f      	movs	r2, #63	; 0x3f
 800e186:	409a      	lsls	r2, r3
 800e188:	68fb      	ldr	r3, [r7, #12]
 800e18a:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800e18c:	687b      	ldr	r3, [r7, #4]
 800e18e:	2200      	movs	r2, #0
 800e190:	655a      	str	r2, [r3, #84]	; 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 800e192:	687b      	ldr	r3, [r7, #4]
 800e194:	2201      	movs	r2, #1
 800e196:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 800e19a:	2300      	movs	r3, #0
}
 800e19c:	4618      	mov	r0, r3
 800e19e:	3718      	adds	r7, #24
 800e1a0:	46bd      	mov	sp, r7
 800e1a2:	bd80      	pop	{r7, pc}
 800e1a4:	f010803f 	.word	0xf010803f

0800e1a8 <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 800e1a8:	b580      	push	{r7, lr}
 800e1aa:	b086      	sub	sp, #24
 800e1ac:	af00      	add	r7, sp, #0
 800e1ae:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr;
  __IO uint32_t count = 0U;
 800e1b0:	2300      	movs	r3, #0
 800e1b2:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
 800e1b4:	4b8e      	ldr	r3, [pc, #568]	; (800e3f0 <HAL_DMA_IRQHandler+0x248>)
 800e1b6:	681b      	ldr	r3, [r3, #0]
 800e1b8:	4a8e      	ldr	r2, [pc, #568]	; (800e3f4 <HAL_DMA_IRQHandler+0x24c>)
 800e1ba:	fba2 2303 	umull	r2, r3, r2, r3
 800e1be:	0a9b      	lsrs	r3, r3, #10
 800e1c0:	617b      	str	r3, [r7, #20]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800e1c2:	687b      	ldr	r3, [r7, #4]
 800e1c4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e1c6:	613b      	str	r3, [r7, #16]

  tmpisr = regs->ISR;
 800e1c8:	693b      	ldr	r3, [r7, #16]
 800e1ca:	681b      	ldr	r3, [r3, #0]
 800e1cc:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 800e1ce:	687b      	ldr	r3, [r7, #4]
 800e1d0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e1d2:	2208      	movs	r2, #8
 800e1d4:	409a      	lsls	r2, r3
 800e1d6:	68fb      	ldr	r3, [r7, #12]
 800e1d8:	4013      	ands	r3, r2
 800e1da:	2b00      	cmp	r3, #0
 800e1dc:	d01a      	beq.n	800e214 <HAL_DMA_IRQHandler+0x6c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 800e1de:	687b      	ldr	r3, [r7, #4]
 800e1e0:	681b      	ldr	r3, [r3, #0]
 800e1e2:	681b      	ldr	r3, [r3, #0]
 800e1e4:	f003 0304 	and.w	r3, r3, #4
 800e1e8:	2b00      	cmp	r3, #0
 800e1ea:	d013      	beq.n	800e214 <HAL_DMA_IRQHandler+0x6c>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 800e1ec:	687b      	ldr	r3, [r7, #4]
 800e1ee:	681b      	ldr	r3, [r3, #0]
 800e1f0:	681a      	ldr	r2, [r3, #0]
 800e1f2:	687b      	ldr	r3, [r7, #4]
 800e1f4:	681b      	ldr	r3, [r3, #0]
 800e1f6:	f022 0204 	bic.w	r2, r2, #4
 800e1fa:	601a      	str	r2, [r3, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 800e1fc:	687b      	ldr	r3, [r7, #4]
 800e1fe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e200:	2208      	movs	r2, #8
 800e202:	409a      	lsls	r2, r3
 800e204:	693b      	ldr	r3, [r7, #16]
 800e206:	609a      	str	r2, [r3, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800e208:	687b      	ldr	r3, [r7, #4]
 800e20a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e20c:	f043 0201 	orr.w	r2, r3, #1
 800e210:	687b      	ldr	r3, [r7, #4]
 800e212:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 800e214:	687b      	ldr	r3, [r7, #4]
 800e216:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e218:	2201      	movs	r2, #1
 800e21a:	409a      	lsls	r2, r3
 800e21c:	68fb      	ldr	r3, [r7, #12]
 800e21e:	4013      	ands	r3, r2
 800e220:	2b00      	cmp	r3, #0
 800e222:	d012      	beq.n	800e24a <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 800e224:	687b      	ldr	r3, [r7, #4]
 800e226:	681b      	ldr	r3, [r3, #0]
 800e228:	695b      	ldr	r3, [r3, #20]
 800e22a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e22e:	2b00      	cmp	r3, #0
 800e230:	d00b      	beq.n	800e24a <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 800e232:	687b      	ldr	r3, [r7, #4]
 800e234:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e236:	2201      	movs	r2, #1
 800e238:	409a      	lsls	r2, r3
 800e23a:	693b      	ldr	r3, [r7, #16]
 800e23c:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 800e23e:	687b      	ldr	r3, [r7, #4]
 800e240:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e242:	f043 0202 	orr.w	r2, r3, #2
 800e246:	687b      	ldr	r3, [r7, #4]
 800e248:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 800e24a:	687b      	ldr	r3, [r7, #4]
 800e24c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e24e:	2204      	movs	r2, #4
 800e250:	409a      	lsls	r2, r3
 800e252:	68fb      	ldr	r3, [r7, #12]
 800e254:	4013      	ands	r3, r2
 800e256:	2b00      	cmp	r3, #0
 800e258:	d012      	beq.n	800e280 <HAL_DMA_IRQHandler+0xd8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 800e25a:	687b      	ldr	r3, [r7, #4]
 800e25c:	681b      	ldr	r3, [r3, #0]
 800e25e:	681b      	ldr	r3, [r3, #0]
 800e260:	f003 0302 	and.w	r3, r3, #2
 800e264:	2b00      	cmp	r3, #0
 800e266:	d00b      	beq.n	800e280 <HAL_DMA_IRQHandler+0xd8>
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 800e268:	687b      	ldr	r3, [r7, #4]
 800e26a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e26c:	2204      	movs	r2, #4
 800e26e:	409a      	lsls	r2, r3
 800e270:	693b      	ldr	r3, [r7, #16]
 800e272:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 800e274:	687b      	ldr	r3, [r7, #4]
 800e276:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e278:	f043 0204 	orr.w	r2, r3, #4
 800e27c:	687b      	ldr	r3, [r7, #4]
 800e27e:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 800e280:	687b      	ldr	r3, [r7, #4]
 800e282:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e284:	2210      	movs	r2, #16
 800e286:	409a      	lsls	r2, r3
 800e288:	68fb      	ldr	r3, [r7, #12]
 800e28a:	4013      	ands	r3, r2
 800e28c:	2b00      	cmp	r3, #0
 800e28e:	d043      	beq.n	800e318 <HAL_DMA_IRQHandler+0x170>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 800e290:	687b      	ldr	r3, [r7, #4]
 800e292:	681b      	ldr	r3, [r3, #0]
 800e294:	681b      	ldr	r3, [r3, #0]
 800e296:	f003 0308 	and.w	r3, r3, #8
 800e29a:	2b00      	cmp	r3, #0
 800e29c:	d03c      	beq.n	800e318 <HAL_DMA_IRQHandler+0x170>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 800e29e:	687b      	ldr	r3, [r7, #4]
 800e2a0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e2a2:	2210      	movs	r2, #16
 800e2a4:	409a      	lsls	r2, r3
 800e2a6:	693b      	ldr	r3, [r7, #16]
 800e2a8:	609a      	str	r2, [r3, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 800e2aa:	687b      	ldr	r3, [r7, #4]
 800e2ac:	681b      	ldr	r3, [r3, #0]
 800e2ae:	681b      	ldr	r3, [r3, #0]
 800e2b0:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800e2b4:	2b00      	cmp	r3, #0
 800e2b6:	d018      	beq.n	800e2ea <HAL_DMA_IRQHandler+0x142>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 800e2b8:	687b      	ldr	r3, [r7, #4]
 800e2ba:	681b      	ldr	r3, [r3, #0]
 800e2bc:	681b      	ldr	r3, [r3, #0]
 800e2be:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800e2c2:	2b00      	cmp	r3, #0
 800e2c4:	d108      	bne.n	800e2d8 <HAL_DMA_IRQHandler+0x130>
        {
          if(hdma->XferHalfCpltCallback != NULL)
 800e2c6:	687b      	ldr	r3, [r7, #4]
 800e2c8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e2ca:	2b00      	cmp	r3, #0
 800e2cc:	d024      	beq.n	800e318 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 800e2ce:	687b      	ldr	r3, [r7, #4]
 800e2d0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e2d2:	6878      	ldr	r0, [r7, #4]
 800e2d4:	4798      	blx	r3
 800e2d6:	e01f      	b.n	800e318 <HAL_DMA_IRQHandler+0x170>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 800e2d8:	687b      	ldr	r3, [r7, #4]
 800e2da:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e2dc:	2b00      	cmp	r3, #0
 800e2de:	d01b      	beq.n	800e318 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferM1HalfCpltCallback(hdma);
 800e2e0:	687b      	ldr	r3, [r7, #4]
 800e2e2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e2e4:	6878      	ldr	r0, [r7, #4]
 800e2e6:	4798      	blx	r3
 800e2e8:	e016      	b.n	800e318 <HAL_DMA_IRQHandler+0x170>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 800e2ea:	687b      	ldr	r3, [r7, #4]
 800e2ec:	681b      	ldr	r3, [r3, #0]
 800e2ee:	681b      	ldr	r3, [r3, #0]
 800e2f0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800e2f4:	2b00      	cmp	r3, #0
 800e2f6:	d107      	bne.n	800e308 <HAL_DMA_IRQHandler+0x160>
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 800e2f8:	687b      	ldr	r3, [r7, #4]
 800e2fa:	681b      	ldr	r3, [r3, #0]
 800e2fc:	681a      	ldr	r2, [r3, #0]
 800e2fe:	687b      	ldr	r3, [r7, #4]
 800e300:	681b      	ldr	r3, [r3, #0]
 800e302:	f022 0208 	bic.w	r2, r2, #8
 800e306:	601a      	str	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
 800e308:	687b      	ldr	r3, [r7, #4]
 800e30a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e30c:	2b00      	cmp	r3, #0
 800e30e:	d003      	beq.n	800e318 <HAL_DMA_IRQHandler+0x170>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 800e310:	687b      	ldr	r3, [r7, #4]
 800e312:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e314:	6878      	ldr	r0, [r7, #4]
 800e316:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 800e318:	687b      	ldr	r3, [r7, #4]
 800e31a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e31c:	2220      	movs	r2, #32
 800e31e:	409a      	lsls	r2, r3
 800e320:	68fb      	ldr	r3, [r7, #12]
 800e322:	4013      	ands	r3, r2
 800e324:	2b00      	cmp	r3, #0
 800e326:	f000 808f 	beq.w	800e448 <HAL_DMA_IRQHandler+0x2a0>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 800e32a:	687b      	ldr	r3, [r7, #4]
 800e32c:	681b      	ldr	r3, [r3, #0]
 800e32e:	681b      	ldr	r3, [r3, #0]
 800e330:	f003 0310 	and.w	r3, r3, #16
 800e334:	2b00      	cmp	r3, #0
 800e336:	f000 8087 	beq.w	800e448 <HAL_DMA_IRQHandler+0x2a0>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 800e33a:	687b      	ldr	r3, [r7, #4]
 800e33c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e33e:	2220      	movs	r2, #32
 800e340:	409a      	lsls	r2, r3
 800e342:	693b      	ldr	r3, [r7, #16]
 800e344:	609a      	str	r2, [r3, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 800e346:	687b      	ldr	r3, [r7, #4]
 800e348:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 800e34c:	b2db      	uxtb	r3, r3
 800e34e:	2b05      	cmp	r3, #5
 800e350:	d136      	bne.n	800e3c0 <HAL_DMA_IRQHandler+0x218>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 800e352:	687b      	ldr	r3, [r7, #4]
 800e354:	681b      	ldr	r3, [r3, #0]
 800e356:	681a      	ldr	r2, [r3, #0]
 800e358:	687b      	ldr	r3, [r7, #4]
 800e35a:	681b      	ldr	r3, [r3, #0]
 800e35c:	f022 0216 	bic.w	r2, r2, #22
 800e360:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 800e362:	687b      	ldr	r3, [r7, #4]
 800e364:	681b      	ldr	r3, [r3, #0]
 800e366:	695a      	ldr	r2, [r3, #20]
 800e368:	687b      	ldr	r3, [r7, #4]
 800e36a:	681b      	ldr	r3, [r3, #0]
 800e36c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800e370:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 800e372:	687b      	ldr	r3, [r7, #4]
 800e374:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e376:	2b00      	cmp	r3, #0
 800e378:	d103      	bne.n	800e382 <HAL_DMA_IRQHandler+0x1da>
 800e37a:	687b      	ldr	r3, [r7, #4]
 800e37c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e37e:	2b00      	cmp	r3, #0
 800e380:	d007      	beq.n	800e392 <HAL_DMA_IRQHandler+0x1ea>
        {
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 800e382:	687b      	ldr	r3, [r7, #4]
 800e384:	681b      	ldr	r3, [r3, #0]
 800e386:	681a      	ldr	r2, [r3, #0]
 800e388:	687b      	ldr	r3, [r7, #4]
 800e38a:	681b      	ldr	r3, [r3, #0]
 800e38c:	f022 0208 	bic.w	r2, r2, #8
 800e390:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 800e392:	687b      	ldr	r3, [r7, #4]
 800e394:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e396:	223f      	movs	r2, #63	; 0x3f
 800e398:	409a      	lsls	r2, r3
 800e39a:	693b      	ldr	r3, [r7, #16]
 800e39c:	609a      	str	r2, [r3, #8]

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 800e39e:	687b      	ldr	r3, [r7, #4]
 800e3a0:	2201      	movs	r2, #1
 800e3a2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 800e3a6:	687b      	ldr	r3, [r7, #4]
 800e3a8:	2200      	movs	r2, #0
 800e3aa:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        if(hdma->XferAbortCallback != NULL)
 800e3ae:	687b      	ldr	r3, [r7, #4]
 800e3b0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800e3b2:	2b00      	cmp	r3, #0
 800e3b4:	d07e      	beq.n	800e4b4 <HAL_DMA_IRQHandler+0x30c>
        {
          hdma->XferAbortCallback(hdma);
 800e3b6:	687b      	ldr	r3, [r7, #4]
 800e3b8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800e3ba:	6878      	ldr	r0, [r7, #4]
 800e3bc:	4798      	blx	r3
        }
        return;
 800e3be:	e079      	b.n	800e4b4 <HAL_DMA_IRQHandler+0x30c>
      }

      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 800e3c0:	687b      	ldr	r3, [r7, #4]
 800e3c2:	681b      	ldr	r3, [r3, #0]
 800e3c4:	681b      	ldr	r3, [r3, #0]
 800e3c6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800e3ca:	2b00      	cmp	r3, #0
 800e3cc:	d01d      	beq.n	800e40a <HAL_DMA_IRQHandler+0x262>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 800e3ce:	687b      	ldr	r3, [r7, #4]
 800e3d0:	681b      	ldr	r3, [r3, #0]
 800e3d2:	681b      	ldr	r3, [r3, #0]
 800e3d4:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800e3d8:	2b00      	cmp	r3, #0
 800e3da:	d10d      	bne.n	800e3f8 <HAL_DMA_IRQHandler+0x250>
        {
          if(hdma->XferM1CpltCallback != NULL)
 800e3dc:	687b      	ldr	r3, [r7, #4]
 800e3de:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e3e0:	2b00      	cmp	r3, #0
 800e3e2:	d031      	beq.n	800e448 <HAL_DMA_IRQHandler+0x2a0>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 800e3e4:	687b      	ldr	r3, [r7, #4]
 800e3e6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e3e8:	6878      	ldr	r0, [r7, #4]
 800e3ea:	4798      	blx	r3
 800e3ec:	e02c      	b.n	800e448 <HAL_DMA_IRQHandler+0x2a0>
 800e3ee:	bf00      	nop
 800e3f0:	20000004 	.word	0x20000004
 800e3f4:	1b4e81b5 	.word	0x1b4e81b5
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 800e3f8:	687b      	ldr	r3, [r7, #4]
 800e3fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e3fc:	2b00      	cmp	r3, #0
 800e3fe:	d023      	beq.n	800e448 <HAL_DMA_IRQHandler+0x2a0>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 800e400:	687b      	ldr	r3, [r7, #4]
 800e402:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e404:	6878      	ldr	r0, [r7, #4]
 800e406:	4798      	blx	r3
 800e408:	e01e      	b.n	800e448 <HAL_DMA_IRQHandler+0x2a0>
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 800e40a:	687b      	ldr	r3, [r7, #4]
 800e40c:	681b      	ldr	r3, [r3, #0]
 800e40e:	681b      	ldr	r3, [r3, #0]
 800e410:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800e414:	2b00      	cmp	r3, #0
 800e416:	d10f      	bne.n	800e438 <HAL_DMA_IRQHandler+0x290>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 800e418:	687b      	ldr	r3, [r7, #4]
 800e41a:	681b      	ldr	r3, [r3, #0]
 800e41c:	681a      	ldr	r2, [r3, #0]
 800e41e:	687b      	ldr	r3, [r7, #4]
 800e420:	681b      	ldr	r3, [r3, #0]
 800e422:	f022 0210 	bic.w	r2, r2, #16
 800e426:	601a      	str	r2, [r3, #0]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 800e428:	687b      	ldr	r3, [r7, #4]
 800e42a:	2201      	movs	r2, #1
 800e42c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 800e430:	687b      	ldr	r3, [r7, #4]
 800e432:	2200      	movs	r2, #0
 800e434:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        }

        if(hdma->XferCpltCallback != NULL)
 800e438:	687b      	ldr	r3, [r7, #4]
 800e43a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e43c:	2b00      	cmp	r3, #0
 800e43e:	d003      	beq.n	800e448 <HAL_DMA_IRQHandler+0x2a0>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 800e440:	687b      	ldr	r3, [r7, #4]
 800e442:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e444:	6878      	ldr	r0, [r7, #4]
 800e446:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 800e448:	687b      	ldr	r3, [r7, #4]
 800e44a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e44c:	2b00      	cmp	r3, #0
 800e44e:	d032      	beq.n	800e4b6 <HAL_DMA_IRQHandler+0x30e>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 800e450:	687b      	ldr	r3, [r7, #4]
 800e452:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e454:	f003 0301 	and.w	r3, r3, #1
 800e458:	2b00      	cmp	r3, #0
 800e45a:	d022      	beq.n	800e4a2 <HAL_DMA_IRQHandler+0x2fa>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
 800e45c:	687b      	ldr	r3, [r7, #4]
 800e45e:	2205      	movs	r2, #5
 800e460:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 800e464:	687b      	ldr	r3, [r7, #4]
 800e466:	681b      	ldr	r3, [r3, #0]
 800e468:	681a      	ldr	r2, [r3, #0]
 800e46a:	687b      	ldr	r3, [r7, #4]
 800e46c:	681b      	ldr	r3, [r3, #0]
 800e46e:	f022 0201 	bic.w	r2, r2, #1
 800e472:	601a      	str	r2, [r3, #0]

      do
      {
        if (++count > timeout)
 800e474:	68bb      	ldr	r3, [r7, #8]
 800e476:	3301      	adds	r3, #1
 800e478:	60bb      	str	r3, [r7, #8]
 800e47a:	697a      	ldr	r2, [r7, #20]
 800e47c:	429a      	cmp	r2, r3
 800e47e:	d307      	bcc.n	800e490 <HAL_DMA_IRQHandler+0x2e8>
        {
          break;
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 800e480:	687b      	ldr	r3, [r7, #4]
 800e482:	681b      	ldr	r3, [r3, #0]
 800e484:	681b      	ldr	r3, [r3, #0]
 800e486:	f003 0301 	and.w	r3, r3, #1
 800e48a:	2b00      	cmp	r3, #0
 800e48c:	d1f2      	bne.n	800e474 <HAL_DMA_IRQHandler+0x2cc>
 800e48e:	e000      	b.n	800e492 <HAL_DMA_IRQHandler+0x2ea>
          break;
 800e490:	bf00      	nop

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 800e492:	687b      	ldr	r3, [r7, #4]
 800e494:	2201      	movs	r2, #1
 800e496:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800e49a:	687b      	ldr	r3, [r7, #4]
 800e49c:	2200      	movs	r2, #0
 800e49e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    }

    if(hdma->XferErrorCallback != NULL)
 800e4a2:	687b      	ldr	r3, [r7, #4]
 800e4a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800e4a6:	2b00      	cmp	r3, #0
 800e4a8:	d005      	beq.n	800e4b6 <HAL_DMA_IRQHandler+0x30e>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 800e4aa:	687b      	ldr	r3, [r7, #4]
 800e4ac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800e4ae:	6878      	ldr	r0, [r7, #4]
 800e4b0:	4798      	blx	r3
 800e4b2:	e000      	b.n	800e4b6 <HAL_DMA_IRQHandler+0x30e>
        return;
 800e4b4:	bf00      	nop
    }
  }
}
 800e4b6:	3718      	adds	r7, #24
 800e4b8:	46bd      	mov	sp, r7
 800e4ba:	bd80      	pop	{r7, pc}

0800e4bc <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 800e4bc:	b480      	push	{r7}
 800e4be:	b085      	sub	sp, #20
 800e4c0:	af00      	add	r7, sp, #0
 800e4c2:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800e4c4:	687b      	ldr	r3, [r7, #4]
 800e4c6:	681b      	ldr	r3, [r3, #0]
 800e4c8:	b2db      	uxtb	r3, r3
 800e4ca:	3b10      	subs	r3, #16
 800e4cc:	4a14      	ldr	r2, [pc, #80]	; (800e520 <DMA_CalcBaseAndBitshift+0x64>)
 800e4ce:	fba2 2303 	umull	r2, r3, r2, r3
 800e4d2:	091b      	lsrs	r3, r3, #4
 800e4d4:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800e4d6:	4a13      	ldr	r2, [pc, #76]	; (800e524 <DMA_CalcBaseAndBitshift+0x68>)
 800e4d8:	68fb      	ldr	r3, [r7, #12]
 800e4da:	4413      	add	r3, r2
 800e4dc:	781b      	ldrb	r3, [r3, #0]
 800e4de:	461a      	mov	r2, r3
 800e4e0:	687b      	ldr	r3, [r7, #4]
 800e4e2:	65da      	str	r2, [r3, #92]	; 0x5c
  
  if (stream_number > 3U)
 800e4e4:	68fb      	ldr	r3, [r7, #12]
 800e4e6:	2b03      	cmp	r3, #3
 800e4e8:	d909      	bls.n	800e4fe <DMA_CalcBaseAndBitshift+0x42>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800e4ea:	687b      	ldr	r3, [r7, #4]
 800e4ec:	681b      	ldr	r3, [r3, #0]
 800e4ee:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 800e4f2:	f023 0303 	bic.w	r3, r3, #3
 800e4f6:	1d1a      	adds	r2, r3, #4
 800e4f8:	687b      	ldr	r3, [r7, #4]
 800e4fa:	659a      	str	r2, [r3, #88]	; 0x58
 800e4fc:	e007      	b.n	800e50e <DMA_CalcBaseAndBitshift+0x52>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 800e4fe:	687b      	ldr	r3, [r7, #4]
 800e500:	681b      	ldr	r3, [r3, #0]
 800e502:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 800e506:	f023 0303 	bic.w	r3, r3, #3
 800e50a:	687a      	ldr	r2, [r7, #4]
 800e50c:	6593      	str	r3, [r2, #88]	; 0x58
  }
  
  return hdma->StreamBaseAddress;
 800e50e:	687b      	ldr	r3, [r7, #4]
 800e510:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
 800e512:	4618      	mov	r0, r3
 800e514:	3714      	adds	r7, #20
 800e516:	46bd      	mov	sp, r7
 800e518:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e51c:	4770      	bx	lr
 800e51e:	bf00      	nop
 800e520:	aaaaaaab 	.word	0xaaaaaaab
 800e524:	08010268 	.word	0x08010268

0800e528 <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
 800e528:	b480      	push	{r7}
 800e52a:	b085      	sub	sp, #20
 800e52c:	af00      	add	r7, sp, #0
 800e52e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 800e530:	2300      	movs	r3, #0
 800e532:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
 800e534:	687b      	ldr	r3, [r7, #4]
 800e536:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e538:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 800e53a:	687b      	ldr	r3, [r7, #4]
 800e53c:	699b      	ldr	r3, [r3, #24]
 800e53e:	2b00      	cmp	r3, #0
 800e540:	d11f      	bne.n	800e582 <DMA_CheckFifoParam+0x5a>
  {
    switch (tmp)
 800e542:	68bb      	ldr	r3, [r7, #8]
 800e544:	2b03      	cmp	r3, #3
 800e546:	d856      	bhi.n	800e5f6 <DMA_CheckFifoParam+0xce>
 800e548:	a201      	add	r2, pc, #4	; (adr r2, 800e550 <DMA_CheckFifoParam+0x28>)
 800e54a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e54e:	bf00      	nop
 800e550:	0800e561 	.word	0x0800e561
 800e554:	0800e573 	.word	0x0800e573
 800e558:	0800e561 	.word	0x0800e561
 800e55c:	0800e5f7 	.word	0x0800e5f7
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800e560:	687b      	ldr	r3, [r7, #4]
 800e562:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e564:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800e568:	2b00      	cmp	r3, #0
 800e56a:	d046      	beq.n	800e5fa <DMA_CheckFifoParam+0xd2>
      {
        status = HAL_ERROR;
 800e56c:	2301      	movs	r3, #1
 800e56e:	73fb      	strb	r3, [r7, #15]
      }
      break;
 800e570:	e043      	b.n	800e5fa <DMA_CheckFifoParam+0xd2>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 800e572:	687b      	ldr	r3, [r7, #4]
 800e574:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e576:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 800e57a:	d140      	bne.n	800e5fe <DMA_CheckFifoParam+0xd6>
      {
        status = HAL_ERROR;
 800e57c:	2301      	movs	r3, #1
 800e57e:	73fb      	strb	r3, [r7, #15]
      }
      break;
 800e580:	e03d      	b.n	800e5fe <DMA_CheckFifoParam+0xd6>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800e582:	687b      	ldr	r3, [r7, #4]
 800e584:	699b      	ldr	r3, [r3, #24]
 800e586:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800e58a:	d121      	bne.n	800e5d0 <DMA_CheckFifoParam+0xa8>
  {
    switch (tmp)
 800e58c:	68bb      	ldr	r3, [r7, #8]
 800e58e:	2b03      	cmp	r3, #3
 800e590:	d837      	bhi.n	800e602 <DMA_CheckFifoParam+0xda>
 800e592:	a201      	add	r2, pc, #4	; (adr r2, 800e598 <DMA_CheckFifoParam+0x70>)
 800e594:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e598:	0800e5a9 	.word	0x0800e5a9
 800e59c:	0800e5af 	.word	0x0800e5af
 800e5a0:	0800e5a9 	.word	0x0800e5a9
 800e5a4:	0800e5c1 	.word	0x0800e5c1
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
 800e5a8:	2301      	movs	r3, #1
 800e5aa:	73fb      	strb	r3, [r7, #15]
      break;
 800e5ac:	e030      	b.n	800e610 <DMA_CheckFifoParam+0xe8>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800e5ae:	687b      	ldr	r3, [r7, #4]
 800e5b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e5b2:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800e5b6:	2b00      	cmp	r3, #0
 800e5b8:	d025      	beq.n	800e606 <DMA_CheckFifoParam+0xde>
      {
        status = HAL_ERROR;
 800e5ba:	2301      	movs	r3, #1
 800e5bc:	73fb      	strb	r3, [r7, #15]
      }
      break;
 800e5be:	e022      	b.n	800e606 <DMA_CheckFifoParam+0xde>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 800e5c0:	687b      	ldr	r3, [r7, #4]
 800e5c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e5c4:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 800e5c8:	d11f      	bne.n	800e60a <DMA_CheckFifoParam+0xe2>
      {
        status = HAL_ERROR;
 800e5ca:	2301      	movs	r3, #1
 800e5cc:	73fb      	strb	r3, [r7, #15]
      }
      break;   
 800e5ce:	e01c      	b.n	800e60a <DMA_CheckFifoParam+0xe2>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 800e5d0:	68bb      	ldr	r3, [r7, #8]
 800e5d2:	2b02      	cmp	r3, #2
 800e5d4:	d903      	bls.n	800e5de <DMA_CheckFifoParam+0xb6>
 800e5d6:	68bb      	ldr	r3, [r7, #8]
 800e5d8:	2b03      	cmp	r3, #3
 800e5da:	d003      	beq.n	800e5e4 <DMA_CheckFifoParam+0xbc>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
 800e5dc:	e018      	b.n	800e610 <DMA_CheckFifoParam+0xe8>
      status = HAL_ERROR;
 800e5de:	2301      	movs	r3, #1
 800e5e0:	73fb      	strb	r3, [r7, #15]
      break;
 800e5e2:	e015      	b.n	800e610 <DMA_CheckFifoParam+0xe8>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800e5e4:	687b      	ldr	r3, [r7, #4]
 800e5e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e5e8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800e5ec:	2b00      	cmp	r3, #0
 800e5ee:	d00e      	beq.n	800e60e <DMA_CheckFifoParam+0xe6>
        status = HAL_ERROR;
 800e5f0:	2301      	movs	r3, #1
 800e5f2:	73fb      	strb	r3, [r7, #15]
      break;
 800e5f4:	e00b      	b.n	800e60e <DMA_CheckFifoParam+0xe6>
      break;
 800e5f6:	bf00      	nop
 800e5f8:	e00a      	b.n	800e610 <DMA_CheckFifoParam+0xe8>
      break;
 800e5fa:	bf00      	nop
 800e5fc:	e008      	b.n	800e610 <DMA_CheckFifoParam+0xe8>
      break;
 800e5fe:	bf00      	nop
 800e600:	e006      	b.n	800e610 <DMA_CheckFifoParam+0xe8>
      break;
 800e602:	bf00      	nop
 800e604:	e004      	b.n	800e610 <DMA_CheckFifoParam+0xe8>
      break;
 800e606:	bf00      	nop
 800e608:	e002      	b.n	800e610 <DMA_CheckFifoParam+0xe8>
      break;   
 800e60a:	bf00      	nop
 800e60c:	e000      	b.n	800e610 <DMA_CheckFifoParam+0xe8>
      break;
 800e60e:	bf00      	nop
    }
  } 
  
  return status; 
 800e610:	7bfb      	ldrb	r3, [r7, #15]
}
 800e612:	4618      	mov	r0, r3
 800e614:	3714      	adds	r7, #20
 800e616:	46bd      	mov	sp, r7
 800e618:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e61c:	4770      	bx	lr
 800e61e:	bf00      	nop

0800e620 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800e620:	b480      	push	{r7}
 800e622:	b089      	sub	sp, #36	; 0x24
 800e624:	af00      	add	r7, sp, #0
 800e626:	6078      	str	r0, [r7, #4]
 800e628:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 800e62a:	2300      	movs	r3, #0
 800e62c:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 800e62e:	2300      	movs	r3, #0
 800e630:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 800e632:	2300      	movs	r3, #0
 800e634:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 800e636:	2300      	movs	r3, #0
 800e638:	61fb      	str	r3, [r7, #28]
 800e63a:	e16b      	b.n	800e914 <HAL_GPIO_Init+0x2f4>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 800e63c:	2201      	movs	r2, #1
 800e63e:	69fb      	ldr	r3, [r7, #28]
 800e640:	fa02 f303 	lsl.w	r3, r2, r3
 800e644:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800e646:	683b      	ldr	r3, [r7, #0]
 800e648:	681b      	ldr	r3, [r3, #0]
 800e64a:	697a      	ldr	r2, [r7, #20]
 800e64c:	4013      	ands	r3, r2
 800e64e:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 800e650:	693a      	ldr	r2, [r7, #16]
 800e652:	697b      	ldr	r3, [r7, #20]
 800e654:	429a      	cmp	r2, r3
 800e656:	f040 815a 	bne.w	800e90e <HAL_GPIO_Init+0x2ee>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 800e65a:	683b      	ldr	r3, [r7, #0]
 800e65c:	685b      	ldr	r3, [r3, #4]
 800e65e:	f003 0303 	and.w	r3, r3, #3
 800e662:	2b01      	cmp	r3, #1
 800e664:	d005      	beq.n	800e672 <HAL_GPIO_Init+0x52>
          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800e666:	683b      	ldr	r3, [r7, #0]
 800e668:	685b      	ldr	r3, [r3, #4]
 800e66a:	f003 0303 	and.w	r3, r3, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 800e66e:	2b02      	cmp	r3, #2
 800e670:	d130      	bne.n	800e6d4 <HAL_GPIO_Init+0xb4>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 800e672:	687b      	ldr	r3, [r7, #4]
 800e674:	689b      	ldr	r3, [r3, #8]
 800e676:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 800e678:	69fb      	ldr	r3, [r7, #28]
 800e67a:	005b      	lsls	r3, r3, #1
 800e67c:	2203      	movs	r2, #3
 800e67e:	fa02 f303 	lsl.w	r3, r2, r3
 800e682:	43db      	mvns	r3, r3
 800e684:	69ba      	ldr	r2, [r7, #24]
 800e686:	4013      	ands	r3, r2
 800e688:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800e68a:	683b      	ldr	r3, [r7, #0]
 800e68c:	68da      	ldr	r2, [r3, #12]
 800e68e:	69fb      	ldr	r3, [r7, #28]
 800e690:	005b      	lsls	r3, r3, #1
 800e692:	fa02 f303 	lsl.w	r3, r2, r3
 800e696:	69ba      	ldr	r2, [r7, #24]
 800e698:	4313      	orrs	r3, r2
 800e69a:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 800e69c:	687b      	ldr	r3, [r7, #4]
 800e69e:	69ba      	ldr	r2, [r7, #24]
 800e6a0:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800e6a2:	687b      	ldr	r3, [r7, #4]
 800e6a4:	685b      	ldr	r3, [r3, #4]
 800e6a6:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800e6a8:	2201      	movs	r2, #1
 800e6aa:	69fb      	ldr	r3, [r7, #28]
 800e6ac:	fa02 f303 	lsl.w	r3, r2, r3
 800e6b0:	43db      	mvns	r3, r3
 800e6b2:	69ba      	ldr	r2, [r7, #24]
 800e6b4:	4013      	ands	r3, r2
 800e6b6:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800e6b8:	683b      	ldr	r3, [r7, #0]
 800e6ba:	685b      	ldr	r3, [r3, #4]
 800e6bc:	091b      	lsrs	r3, r3, #4
 800e6be:	f003 0201 	and.w	r2, r3, #1
 800e6c2:	69fb      	ldr	r3, [r7, #28]
 800e6c4:	fa02 f303 	lsl.w	r3, r2, r3
 800e6c8:	69ba      	ldr	r2, [r7, #24]
 800e6ca:	4313      	orrs	r3, r2
 800e6cc:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 800e6ce:	687b      	ldr	r3, [r7, #4]
 800e6d0:	69ba      	ldr	r2, [r7, #24]
 800e6d2:	605a      	str	r2, [r3, #4]
       }

      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800e6d4:	683b      	ldr	r3, [r7, #0]
 800e6d6:	685b      	ldr	r3, [r3, #4]
 800e6d8:	f003 0303 	and.w	r3, r3, #3
 800e6dc:	2b03      	cmp	r3, #3
 800e6de:	d017      	beq.n	800e710 <HAL_GPIO_Init+0xf0>
      {
        /* Check the parameters */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
        
        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 800e6e0:	687b      	ldr	r3, [r7, #4]
 800e6e2:	68db      	ldr	r3, [r3, #12]
 800e6e4:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800e6e6:	69fb      	ldr	r3, [r7, #28]
 800e6e8:	005b      	lsls	r3, r3, #1
 800e6ea:	2203      	movs	r2, #3
 800e6ec:	fa02 f303 	lsl.w	r3, r2, r3
 800e6f0:	43db      	mvns	r3, r3
 800e6f2:	69ba      	ldr	r2, [r7, #24]
 800e6f4:	4013      	ands	r3, r2
 800e6f6:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 800e6f8:	683b      	ldr	r3, [r7, #0]
 800e6fa:	689a      	ldr	r2, [r3, #8]
 800e6fc:	69fb      	ldr	r3, [r7, #28]
 800e6fe:	005b      	lsls	r3, r3, #1
 800e700:	fa02 f303 	lsl.w	r3, r2, r3
 800e704:	69ba      	ldr	r2, [r7, #24]
 800e706:	4313      	orrs	r3, r2
 800e708:	61bb      	str	r3, [r7, #24]
        GPIOx->PUPDR = temp;
 800e70a:	687b      	ldr	r3, [r7, #4]
 800e70c:	69ba      	ldr	r2, [r7, #24]
 800e70e:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800e710:	683b      	ldr	r3, [r7, #0]
 800e712:	685b      	ldr	r3, [r3, #4]
 800e714:	f003 0303 	and.w	r3, r3, #3
 800e718:	2b02      	cmp	r3, #2
 800e71a:	d123      	bne.n	800e764 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 800e71c:	69fb      	ldr	r3, [r7, #28]
 800e71e:	08da      	lsrs	r2, r3, #3
 800e720:	687b      	ldr	r3, [r7, #4]
 800e722:	3208      	adds	r2, #8
 800e724:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e728:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800e72a:	69fb      	ldr	r3, [r7, #28]
 800e72c:	f003 0307 	and.w	r3, r3, #7
 800e730:	009b      	lsls	r3, r3, #2
 800e732:	220f      	movs	r2, #15
 800e734:	fa02 f303 	lsl.w	r3, r2, r3
 800e738:	43db      	mvns	r3, r3
 800e73a:	69ba      	ldr	r2, [r7, #24]
 800e73c:	4013      	ands	r3, r2
 800e73e:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 800e740:	683b      	ldr	r3, [r7, #0]
 800e742:	691a      	ldr	r2, [r3, #16]
 800e744:	69fb      	ldr	r3, [r7, #28]
 800e746:	f003 0307 	and.w	r3, r3, #7
 800e74a:	009b      	lsls	r3, r3, #2
 800e74c:	fa02 f303 	lsl.w	r3, r2, r3
 800e750:	69ba      	ldr	r2, [r7, #24]
 800e752:	4313      	orrs	r3, r2
 800e754:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 800e756:	69fb      	ldr	r3, [r7, #28]
 800e758:	08da      	lsrs	r2, r3, #3
 800e75a:	687b      	ldr	r3, [r7, #4]
 800e75c:	3208      	adds	r2, #8
 800e75e:	69b9      	ldr	r1, [r7, #24]
 800e760:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800e764:	687b      	ldr	r3, [r7, #4]
 800e766:	681b      	ldr	r3, [r3, #0]
 800e768:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800e76a:	69fb      	ldr	r3, [r7, #28]
 800e76c:	005b      	lsls	r3, r3, #1
 800e76e:	2203      	movs	r2, #3
 800e770:	fa02 f303 	lsl.w	r3, r2, r3
 800e774:	43db      	mvns	r3, r3
 800e776:	69ba      	ldr	r2, [r7, #24]
 800e778:	4013      	ands	r3, r2
 800e77a:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800e77c:	683b      	ldr	r3, [r7, #0]
 800e77e:	685b      	ldr	r3, [r3, #4]
 800e780:	f003 0203 	and.w	r2, r3, #3
 800e784:	69fb      	ldr	r3, [r7, #28]
 800e786:	005b      	lsls	r3, r3, #1
 800e788:	fa02 f303 	lsl.w	r3, r2, r3
 800e78c:	69ba      	ldr	r2, [r7, #24]
 800e78e:	4313      	orrs	r3, r2
 800e790:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 800e792:	687b      	ldr	r3, [r7, #4]
 800e794:	69ba      	ldr	r2, [r7, #24]
 800e796:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800e798:	683b      	ldr	r3, [r7, #0]
 800e79a:	685b      	ldr	r3, [r3, #4]
 800e79c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800e7a0:	2b00      	cmp	r3, #0
 800e7a2:	f000 80b4 	beq.w	800e90e <HAL_GPIO_Init+0x2ee>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800e7a6:	2300      	movs	r3, #0
 800e7a8:	60fb      	str	r3, [r7, #12]
 800e7aa:	4b60      	ldr	r3, [pc, #384]	; (800e92c <HAL_GPIO_Init+0x30c>)
 800e7ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e7ae:	4a5f      	ldr	r2, [pc, #380]	; (800e92c <HAL_GPIO_Init+0x30c>)
 800e7b0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800e7b4:	6453      	str	r3, [r2, #68]	; 0x44
 800e7b6:	4b5d      	ldr	r3, [pc, #372]	; (800e92c <HAL_GPIO_Init+0x30c>)
 800e7b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e7ba:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800e7be:	60fb      	str	r3, [r7, #12]
 800e7c0:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 800e7c2:	4a5b      	ldr	r2, [pc, #364]	; (800e930 <HAL_GPIO_Init+0x310>)
 800e7c4:	69fb      	ldr	r3, [r7, #28]
 800e7c6:	089b      	lsrs	r3, r3, #2
 800e7c8:	3302      	adds	r3, #2
 800e7ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e7ce:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 800e7d0:	69fb      	ldr	r3, [r7, #28]
 800e7d2:	f003 0303 	and.w	r3, r3, #3
 800e7d6:	009b      	lsls	r3, r3, #2
 800e7d8:	220f      	movs	r2, #15
 800e7da:	fa02 f303 	lsl.w	r3, r2, r3
 800e7de:	43db      	mvns	r3, r3
 800e7e0:	69ba      	ldr	r2, [r7, #24]
 800e7e2:	4013      	ands	r3, r2
 800e7e4:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800e7e6:	687b      	ldr	r3, [r7, #4]
 800e7e8:	4a52      	ldr	r2, [pc, #328]	; (800e934 <HAL_GPIO_Init+0x314>)
 800e7ea:	4293      	cmp	r3, r2
 800e7ec:	d02b      	beq.n	800e846 <HAL_GPIO_Init+0x226>
 800e7ee:	687b      	ldr	r3, [r7, #4]
 800e7f0:	4a51      	ldr	r2, [pc, #324]	; (800e938 <HAL_GPIO_Init+0x318>)
 800e7f2:	4293      	cmp	r3, r2
 800e7f4:	d025      	beq.n	800e842 <HAL_GPIO_Init+0x222>
 800e7f6:	687b      	ldr	r3, [r7, #4]
 800e7f8:	4a50      	ldr	r2, [pc, #320]	; (800e93c <HAL_GPIO_Init+0x31c>)
 800e7fa:	4293      	cmp	r3, r2
 800e7fc:	d01f      	beq.n	800e83e <HAL_GPIO_Init+0x21e>
 800e7fe:	687b      	ldr	r3, [r7, #4]
 800e800:	4a4f      	ldr	r2, [pc, #316]	; (800e940 <HAL_GPIO_Init+0x320>)
 800e802:	4293      	cmp	r3, r2
 800e804:	d019      	beq.n	800e83a <HAL_GPIO_Init+0x21a>
 800e806:	687b      	ldr	r3, [r7, #4]
 800e808:	4a4e      	ldr	r2, [pc, #312]	; (800e944 <HAL_GPIO_Init+0x324>)
 800e80a:	4293      	cmp	r3, r2
 800e80c:	d013      	beq.n	800e836 <HAL_GPIO_Init+0x216>
 800e80e:	687b      	ldr	r3, [r7, #4]
 800e810:	4a4d      	ldr	r2, [pc, #308]	; (800e948 <HAL_GPIO_Init+0x328>)
 800e812:	4293      	cmp	r3, r2
 800e814:	d00d      	beq.n	800e832 <HAL_GPIO_Init+0x212>
 800e816:	687b      	ldr	r3, [r7, #4]
 800e818:	4a4c      	ldr	r2, [pc, #304]	; (800e94c <HAL_GPIO_Init+0x32c>)
 800e81a:	4293      	cmp	r3, r2
 800e81c:	d007      	beq.n	800e82e <HAL_GPIO_Init+0x20e>
 800e81e:	687b      	ldr	r3, [r7, #4]
 800e820:	4a4b      	ldr	r2, [pc, #300]	; (800e950 <HAL_GPIO_Init+0x330>)
 800e822:	4293      	cmp	r3, r2
 800e824:	d101      	bne.n	800e82a <HAL_GPIO_Init+0x20a>
 800e826:	2307      	movs	r3, #7
 800e828:	e00e      	b.n	800e848 <HAL_GPIO_Init+0x228>
 800e82a:	2308      	movs	r3, #8
 800e82c:	e00c      	b.n	800e848 <HAL_GPIO_Init+0x228>
 800e82e:	2306      	movs	r3, #6
 800e830:	e00a      	b.n	800e848 <HAL_GPIO_Init+0x228>
 800e832:	2305      	movs	r3, #5
 800e834:	e008      	b.n	800e848 <HAL_GPIO_Init+0x228>
 800e836:	2304      	movs	r3, #4
 800e838:	e006      	b.n	800e848 <HAL_GPIO_Init+0x228>
 800e83a:	2303      	movs	r3, #3
 800e83c:	e004      	b.n	800e848 <HAL_GPIO_Init+0x228>
 800e83e:	2302      	movs	r3, #2
 800e840:	e002      	b.n	800e848 <HAL_GPIO_Init+0x228>
 800e842:	2301      	movs	r3, #1
 800e844:	e000      	b.n	800e848 <HAL_GPIO_Init+0x228>
 800e846:	2300      	movs	r3, #0
 800e848:	69fa      	ldr	r2, [r7, #28]
 800e84a:	f002 0203 	and.w	r2, r2, #3
 800e84e:	0092      	lsls	r2, r2, #2
 800e850:	4093      	lsls	r3, r2
 800e852:	69ba      	ldr	r2, [r7, #24]
 800e854:	4313      	orrs	r3, r2
 800e856:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 800e858:	4935      	ldr	r1, [pc, #212]	; (800e930 <HAL_GPIO_Init+0x310>)
 800e85a:	69fb      	ldr	r3, [r7, #28]
 800e85c:	089b      	lsrs	r3, r3, #2
 800e85e:	3302      	adds	r3, #2
 800e860:	69ba      	ldr	r2, [r7, #24]
 800e862:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800e866:	4b3b      	ldr	r3, [pc, #236]	; (800e954 <HAL_GPIO_Init+0x334>)
 800e868:	689b      	ldr	r3, [r3, #8]
 800e86a:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800e86c:	693b      	ldr	r3, [r7, #16]
 800e86e:	43db      	mvns	r3, r3
 800e870:	69ba      	ldr	r2, [r7, #24]
 800e872:	4013      	ands	r3, r2
 800e874:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800e876:	683b      	ldr	r3, [r7, #0]
 800e878:	685b      	ldr	r3, [r3, #4]
 800e87a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800e87e:	2b00      	cmp	r3, #0
 800e880:	d003      	beq.n	800e88a <HAL_GPIO_Init+0x26a>
        {
          temp |= iocurrent;
 800e882:	69ba      	ldr	r2, [r7, #24]
 800e884:	693b      	ldr	r3, [r7, #16]
 800e886:	4313      	orrs	r3, r2
 800e888:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 800e88a:	4a32      	ldr	r2, [pc, #200]	; (800e954 <HAL_GPIO_Init+0x334>)
 800e88c:	69bb      	ldr	r3, [r7, #24]
 800e88e:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 800e890:	4b30      	ldr	r3, [pc, #192]	; (800e954 <HAL_GPIO_Init+0x334>)
 800e892:	68db      	ldr	r3, [r3, #12]
 800e894:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800e896:	693b      	ldr	r3, [r7, #16]
 800e898:	43db      	mvns	r3, r3
 800e89a:	69ba      	ldr	r2, [r7, #24]
 800e89c:	4013      	ands	r3, r2
 800e89e:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 800e8a0:	683b      	ldr	r3, [r7, #0]
 800e8a2:	685b      	ldr	r3, [r3, #4]
 800e8a4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800e8a8:	2b00      	cmp	r3, #0
 800e8aa:	d003      	beq.n	800e8b4 <HAL_GPIO_Init+0x294>
        {
          temp |= iocurrent;
 800e8ac:	69ba      	ldr	r2, [r7, #24]
 800e8ae:	693b      	ldr	r3, [r7, #16]
 800e8b0:	4313      	orrs	r3, r2
 800e8b2:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 800e8b4:	4a27      	ldr	r2, [pc, #156]	; (800e954 <HAL_GPIO_Init+0x334>)
 800e8b6:	69bb      	ldr	r3, [r7, #24]
 800e8b8:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 800e8ba:	4b26      	ldr	r3, [pc, #152]	; (800e954 <HAL_GPIO_Init+0x334>)
 800e8bc:	685b      	ldr	r3, [r3, #4]
 800e8be:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800e8c0:	693b      	ldr	r3, [r7, #16]
 800e8c2:	43db      	mvns	r3, r3
 800e8c4:	69ba      	ldr	r2, [r7, #24]
 800e8c6:	4013      	ands	r3, r2
 800e8c8:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800e8ca:	683b      	ldr	r3, [r7, #0]
 800e8cc:	685b      	ldr	r3, [r3, #4]
 800e8ce:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800e8d2:	2b00      	cmp	r3, #0
 800e8d4:	d003      	beq.n	800e8de <HAL_GPIO_Init+0x2be>
        {
          temp |= iocurrent;
 800e8d6:	69ba      	ldr	r2, [r7, #24]
 800e8d8:	693b      	ldr	r3, [r7, #16]
 800e8da:	4313      	orrs	r3, r2
 800e8dc:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 800e8de:	4a1d      	ldr	r2, [pc, #116]	; (800e954 <HAL_GPIO_Init+0x334>)
 800e8e0:	69bb      	ldr	r3, [r7, #24]
 800e8e2:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800e8e4:	4b1b      	ldr	r3, [pc, #108]	; (800e954 <HAL_GPIO_Init+0x334>)
 800e8e6:	681b      	ldr	r3, [r3, #0]
 800e8e8:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800e8ea:	693b      	ldr	r3, [r7, #16]
 800e8ec:	43db      	mvns	r3, r3
 800e8ee:	69ba      	ldr	r2, [r7, #24]
 800e8f0:	4013      	ands	r3, r2
 800e8f2:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800e8f4:	683b      	ldr	r3, [r7, #0]
 800e8f6:	685b      	ldr	r3, [r3, #4]
 800e8f8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800e8fc:	2b00      	cmp	r3, #0
 800e8fe:	d003      	beq.n	800e908 <HAL_GPIO_Init+0x2e8>
        {
          temp |= iocurrent;
 800e900:	69ba      	ldr	r2, [r7, #24]
 800e902:	693b      	ldr	r3, [r7, #16]
 800e904:	4313      	orrs	r3, r2
 800e906:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 800e908:	4a12      	ldr	r2, [pc, #72]	; (800e954 <HAL_GPIO_Init+0x334>)
 800e90a:	69bb      	ldr	r3, [r7, #24]
 800e90c:	6013      	str	r3, [r2, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800e90e:	69fb      	ldr	r3, [r7, #28]
 800e910:	3301      	adds	r3, #1
 800e912:	61fb      	str	r3, [r7, #28]
 800e914:	69fb      	ldr	r3, [r7, #28]
 800e916:	2b0f      	cmp	r3, #15
 800e918:	f67f ae90 	bls.w	800e63c <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 800e91c:	bf00      	nop
 800e91e:	bf00      	nop
 800e920:	3724      	adds	r7, #36	; 0x24
 800e922:	46bd      	mov	sp, r7
 800e924:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e928:	4770      	bx	lr
 800e92a:	bf00      	nop
 800e92c:	40023800 	.word	0x40023800
 800e930:	40013800 	.word	0x40013800
 800e934:	40020000 	.word	0x40020000
 800e938:	40020400 	.word	0x40020400
 800e93c:	40020800 	.word	0x40020800
 800e940:	40020c00 	.word	0x40020c00
 800e944:	40021000 	.word	0x40021000
 800e948:	40021400 	.word	0x40021400
 800e94c:	40021800 	.word	0x40021800
 800e950:	40021c00 	.word	0x40021c00
 800e954:	40013c00 	.word	0x40013c00

0800e958 <HAL_I2S_Init>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s)
{
 800e958:	b580      	push	{r7, lr}
 800e95a:	b088      	sub	sp, #32
 800e95c:	af00      	add	r7, sp, #0
 800e95e:	6078      	str	r0, [r7, #4]
#if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
  uint16_t tmpreg;
#endif

  /* Check the I2S handle allocation */
  if (hi2s == NULL)
 800e960:	687b      	ldr	r3, [r7, #4]
 800e962:	2b00      	cmp	r3, #0
 800e964:	d101      	bne.n	800e96a <HAL_I2S_Init+0x12>
  {
    return HAL_ERROR;
 800e966:	2301      	movs	r3, #1
 800e968:	e128      	b.n	800ebbc <HAL_I2S_Init+0x264>
  assert_param(IS_I2S_MCLK_OUTPUT(hi2s->Init.MCLKOutput));
  assert_param(IS_I2S_AUDIO_FREQ(hi2s->Init.AudioFreq));
  assert_param(IS_I2S_CPOL(hi2s->Init.CPOL));
  assert_param(IS_I2S_CLOCKSOURCE(hi2s->Init.ClockSource));

  if (hi2s->State == HAL_I2S_STATE_RESET)
 800e96a:	687b      	ldr	r3, [r7, #4]
 800e96c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800e970:	b2db      	uxtb	r3, r3
 800e972:	2b00      	cmp	r3, #0
 800e974:	d109      	bne.n	800e98a <HAL_I2S_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hi2s->Lock = HAL_UNLOCKED;
 800e976:	687b      	ldr	r3, [r7, #4]
 800e978:	2200      	movs	r2, #0
 800e97a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Initialize Default I2S IrqHandler ISR */
    hi2s->IrqHandlerISR = I2S_IRQHandler;
 800e97e:	687b      	ldr	r3, [r7, #4]
 800e980:	4a90      	ldr	r2, [pc, #576]	; (800ebc4 <HAL_I2S_Init+0x26c>)
 800e982:	635a      	str	r2, [r3, #52]	; 0x34

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hi2s->MspInitCallback(hi2s);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2S_MspInit(hi2s);
 800e984:	6878      	ldr	r0, [r7, #4]
 800e986:	f7fe ff15 	bl	800d7b4 <HAL_I2S_MspInit>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }

  hi2s->State = HAL_I2S_STATE_BUSY;
 800e98a:	687b      	ldr	r3, [r7, #4]
 800e98c:	2202      	movs	r2, #2
 800e98e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  CLEAR_BIT(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 800e992:	687b      	ldr	r3, [r7, #4]
 800e994:	681b      	ldr	r3, [r3, #0]
 800e996:	69db      	ldr	r3, [r3, #28]
 800e998:	687a      	ldr	r2, [r7, #4]
 800e99a:	6812      	ldr	r2, [r2, #0]
 800e99c:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 800e9a0:	f023 030f 	bic.w	r3, r3, #15
 800e9a4:	61d3      	str	r3, [r2, #28]
                                      SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                      SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
  hi2s->Instance->I2SPR = 0x0002U;
 800e9a6:	687b      	ldr	r3, [r7, #4]
 800e9a8:	681b      	ldr	r3, [r3, #0]
 800e9aa:	2202      	movs	r2, #2
 800e9ac:	621a      	str	r2, [r3, #32]

  /*----------------------- I2SPR: I2SDIV and ODD Calculation -----------------*/
  /* If the requested audio frequency is not the default, compute the prescaler */
  if (hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
 800e9ae:	687b      	ldr	r3, [r7, #4]
 800e9b0:	695b      	ldr	r3, [r3, #20]
 800e9b2:	2b02      	cmp	r3, #2
 800e9b4:	d060      	beq.n	800ea78 <HAL_I2S_Init+0x120>
  {
    /* Check the frame length (For the Prescaler computing) ********************/
    if (hi2s->Init.DataFormat == I2S_DATAFORMAT_16B)
 800e9b6:	687b      	ldr	r3, [r7, #4]
 800e9b8:	68db      	ldr	r3, [r3, #12]
 800e9ba:	2b00      	cmp	r3, #0
 800e9bc:	d102      	bne.n	800e9c4 <HAL_I2S_Init+0x6c>
    {
      /* Packet length is 16 bits */
      packetlength = 16U;
 800e9be:	2310      	movs	r3, #16
 800e9c0:	617b      	str	r3, [r7, #20]
 800e9c2:	e001      	b.n	800e9c8 <HAL_I2S_Init+0x70>
    }
    else
    {
      /* Packet length is 32 bits */
      packetlength = 32U;
 800e9c4:	2320      	movs	r3, #32
 800e9c6:	617b      	str	r3, [r7, #20]
    }

    /* I2S standard */
    if (hi2s->Init.Standard <= I2S_STANDARD_LSB)
 800e9c8:	687b      	ldr	r3, [r7, #4]
 800e9ca:	689b      	ldr	r3, [r3, #8]
 800e9cc:	2b20      	cmp	r3, #32
 800e9ce:	d802      	bhi.n	800e9d6 <HAL_I2S_Init+0x7e>
    {
      /* In I2S standard packet length is multiplied by 2 */
      packetlength = packetlength * 2U;
 800e9d0:	697b      	ldr	r3, [r7, #20]
 800e9d2:	005b      	lsls	r3, r3, #1
 800e9d4:	617b      	str	r3, [r7, #20]
    else
    {
      i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S_APB2);
    }
#else
    i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S);
 800e9d6:	2001      	movs	r0, #1
 800e9d8:	f000 fc5e 	bl	800f298 <HAL_RCCEx_GetPeriphCLKFreq>
 800e9dc:	60f8      	str	r0, [r7, #12]
#endif /* I2S_APB1_APB2_FEATURE */

    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if (hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
 800e9de:	687b      	ldr	r3, [r7, #4]
 800e9e0:	691b      	ldr	r3, [r3, #16]
 800e9e2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800e9e6:	d125      	bne.n	800ea34 <HAL_I2S_Init+0xdc>
    {
      /* MCLK output is enabled */
      if (hi2s->Init.DataFormat != I2S_DATAFORMAT_16B)
 800e9e8:	687b      	ldr	r3, [r7, #4]
 800e9ea:	68db      	ldr	r3, [r3, #12]
 800e9ec:	2b00      	cmp	r3, #0
 800e9ee:	d010      	beq.n	800ea12 <HAL_I2S_Init+0xba>
      {
        tmp = (uint32_t)(((((i2sclk / (packetlength * 4U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800e9f0:	697b      	ldr	r3, [r7, #20]
 800e9f2:	009b      	lsls	r3, r3, #2
 800e9f4:	68fa      	ldr	r2, [r7, #12]
 800e9f6:	fbb2 f2f3 	udiv	r2, r2, r3
 800e9fa:	4613      	mov	r3, r2
 800e9fc:	009b      	lsls	r3, r3, #2
 800e9fe:	4413      	add	r3, r2
 800ea00:	005b      	lsls	r3, r3, #1
 800ea02:	461a      	mov	r2, r3
 800ea04:	687b      	ldr	r3, [r7, #4]
 800ea06:	695b      	ldr	r3, [r3, #20]
 800ea08:	fbb2 f3f3 	udiv	r3, r2, r3
 800ea0c:	3305      	adds	r3, #5
 800ea0e:	613b      	str	r3, [r7, #16]
 800ea10:	e01f      	b.n	800ea52 <HAL_I2S_Init+0xfa>
      }
      else
      {
        tmp = (uint32_t)(((((i2sclk / (packetlength * 8U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800ea12:	697b      	ldr	r3, [r7, #20]
 800ea14:	00db      	lsls	r3, r3, #3
 800ea16:	68fa      	ldr	r2, [r7, #12]
 800ea18:	fbb2 f2f3 	udiv	r2, r2, r3
 800ea1c:	4613      	mov	r3, r2
 800ea1e:	009b      	lsls	r3, r3, #2
 800ea20:	4413      	add	r3, r2
 800ea22:	005b      	lsls	r3, r3, #1
 800ea24:	461a      	mov	r2, r3
 800ea26:	687b      	ldr	r3, [r7, #4]
 800ea28:	695b      	ldr	r3, [r3, #20]
 800ea2a:	fbb2 f3f3 	udiv	r3, r2, r3
 800ea2e:	3305      	adds	r3, #5
 800ea30:	613b      	str	r3, [r7, #16]
 800ea32:	e00e      	b.n	800ea52 <HAL_I2S_Init+0xfa>
      }
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint32_t)(((((i2sclk / packetlength) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800ea34:	68fa      	ldr	r2, [r7, #12]
 800ea36:	697b      	ldr	r3, [r7, #20]
 800ea38:	fbb2 f2f3 	udiv	r2, r2, r3
 800ea3c:	4613      	mov	r3, r2
 800ea3e:	009b      	lsls	r3, r3, #2
 800ea40:	4413      	add	r3, r2
 800ea42:	005b      	lsls	r3, r3, #1
 800ea44:	461a      	mov	r2, r3
 800ea46:	687b      	ldr	r3, [r7, #4]
 800ea48:	695b      	ldr	r3, [r3, #20]
 800ea4a:	fbb2 f3f3 	udiv	r3, r2, r3
 800ea4e:	3305      	adds	r3, #5
 800ea50:	613b      	str	r3, [r7, #16]
    }

    /* Remove the flatting point */
    tmp = tmp / 10U;
 800ea52:	693b      	ldr	r3, [r7, #16]
 800ea54:	4a5c      	ldr	r2, [pc, #368]	; (800ebc8 <HAL_I2S_Init+0x270>)
 800ea56:	fba2 2303 	umull	r2, r3, r2, r3
 800ea5a:	08db      	lsrs	r3, r3, #3
 800ea5c:	613b      	str	r3, [r7, #16]

    /* Check the parity of the divider */
    i2sodd = (uint32_t)(tmp & (uint32_t)1U);
 800ea5e:	693b      	ldr	r3, [r7, #16]
 800ea60:	f003 0301 	and.w	r3, r3, #1
 800ea64:	61bb      	str	r3, [r7, #24]

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint32_t)((tmp - i2sodd) / 2U);
 800ea66:	693a      	ldr	r2, [r7, #16]
 800ea68:	69bb      	ldr	r3, [r7, #24]
 800ea6a:	1ad3      	subs	r3, r2, r3
 800ea6c:	085b      	lsrs	r3, r3, #1
 800ea6e:	61fb      	str	r3, [r7, #28]

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint32_t)(i2sodd << 8U);
 800ea70:	69bb      	ldr	r3, [r7, #24]
 800ea72:	021b      	lsls	r3, r3, #8
 800ea74:	61bb      	str	r3, [r7, #24]
 800ea76:	e003      	b.n	800ea80 <HAL_I2S_Init+0x128>
  }
  else
  {
    /* Set the default values */
    i2sdiv = 2U;
 800ea78:	2302      	movs	r3, #2
 800ea7a:	61fb      	str	r3, [r7, #28]
    i2sodd = 0U;
 800ea7c:	2300      	movs	r3, #0
 800ea7e:	61bb      	str	r3, [r7, #24]
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2U) || (i2sdiv > 0xFFU))
 800ea80:	69fb      	ldr	r3, [r7, #28]
 800ea82:	2b01      	cmp	r3, #1
 800ea84:	d902      	bls.n	800ea8c <HAL_I2S_Init+0x134>
 800ea86:	69fb      	ldr	r3, [r7, #28]
 800ea88:	2bff      	cmp	r3, #255	; 0xff
 800ea8a:	d907      	bls.n	800ea9c <HAL_I2S_Init+0x144>
  {
    /* Set the error code and execute error callback*/
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_PRESCALER);
 800ea8c:	687b      	ldr	r3, [r7, #4]
 800ea8e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ea90:	f043 0210 	orr.w	r2, r3, #16
 800ea94:	687b      	ldr	r3, [r7, #4]
 800ea96:	645a      	str	r2, [r3, #68]	; 0x44
    return  HAL_ERROR;
 800ea98:	2301      	movs	r3, #1
 800ea9a:	e08f      	b.n	800ebbc <HAL_I2S_Init+0x264>
  }

  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/

  /* Write to SPIx I2SPR register the computed value */
  hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
 800ea9c:	687b      	ldr	r3, [r7, #4]
 800ea9e:	691a      	ldr	r2, [r3, #16]
 800eaa0:	69bb      	ldr	r3, [r7, #24]
 800eaa2:	ea42 0103 	orr.w	r1, r2, r3
 800eaa6:	687b      	ldr	r3, [r7, #4]
 800eaa8:	681b      	ldr	r3, [r3, #0]
 800eaaa:	69fa      	ldr	r2, [r7, #28]
 800eaac:	430a      	orrs	r2, r1
 800eaae:	621a      	str	r2, [r3, #32]

  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  /* And configure the I2S with the I2S_InitStruct values                      */
  MODIFY_REG(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | \
 800eab0:	687b      	ldr	r3, [r7, #4]
 800eab2:	681b      	ldr	r3, [r3, #0]
 800eab4:	69db      	ldr	r3, [r3, #28]
 800eab6:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 800eaba:	f023 030f 	bic.w	r3, r3, #15
 800eabe:	687a      	ldr	r2, [r7, #4]
 800eac0:	6851      	ldr	r1, [r2, #4]
 800eac2:	687a      	ldr	r2, [r7, #4]
 800eac4:	6892      	ldr	r2, [r2, #8]
 800eac6:	4311      	orrs	r1, r2
 800eac8:	687a      	ldr	r2, [r7, #4]
 800eaca:	68d2      	ldr	r2, [r2, #12]
 800eacc:	4311      	orrs	r1, r2
 800eace:	687a      	ldr	r2, [r7, #4]
 800ead0:	6992      	ldr	r2, [r2, #24]
 800ead2:	430a      	orrs	r2, r1
 800ead4:	431a      	orrs	r2, r3
 800ead6:	687b      	ldr	r3, [r7, #4]
 800ead8:	681b      	ldr	r3, [r3, #0]
 800eada:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800eade:	61da      	str	r2, [r3, #28]
#if defined (SPI_I2S_FULLDUPLEX_SUPPORT)

  /* Configure the I2S extended if the full duplex mode is enabled */
  assert_param(IS_I2S_FULLDUPLEX_MODE(hi2s->Init.FullDuplexMode));

  if (hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 800eae0:	687b      	ldr	r3, [r7, #4]
 800eae2:	6a1b      	ldr	r3, [r3, #32]
 800eae4:	2b01      	cmp	r3, #1
 800eae6:	d161      	bne.n	800ebac <HAL_I2S_Init+0x254>
  {
    /* Set FullDuplex I2S IrqHandler ISR if FULLDUPLEXMODE is enabled */
    hi2s->IrqHandlerISR = HAL_I2SEx_FullDuplex_IRQHandler;
 800eae8:	687b      	ldr	r3, [r7, #4]
 800eaea:	4a38      	ldr	r2, [pc, #224]	; (800ebcc <HAL_I2S_Init+0x274>)
 800eaec:	635a      	str	r2, [r3, #52]	; 0x34

    /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    CLEAR_BIT(I2SxEXT(hi2s->Instance)->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 800eaee:	687b      	ldr	r3, [r7, #4]
 800eaf0:	681b      	ldr	r3, [r3, #0]
 800eaf2:	4a37      	ldr	r2, [pc, #220]	; (800ebd0 <HAL_I2S_Init+0x278>)
 800eaf4:	4293      	cmp	r3, r2
 800eaf6:	d101      	bne.n	800eafc <HAL_I2S_Init+0x1a4>
 800eaf8:	4b36      	ldr	r3, [pc, #216]	; (800ebd4 <HAL_I2S_Init+0x27c>)
 800eafa:	e001      	b.n	800eb00 <HAL_I2S_Init+0x1a8>
 800eafc:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800eb00:	69db      	ldr	r3, [r3, #28]
 800eb02:	687a      	ldr	r2, [r7, #4]
 800eb04:	6812      	ldr	r2, [r2, #0]
 800eb06:	4932      	ldr	r1, [pc, #200]	; (800ebd0 <HAL_I2S_Init+0x278>)
 800eb08:	428a      	cmp	r2, r1
 800eb0a:	d101      	bne.n	800eb10 <HAL_I2S_Init+0x1b8>
 800eb0c:	4a31      	ldr	r2, [pc, #196]	; (800ebd4 <HAL_I2S_Init+0x27c>)
 800eb0e:	e001      	b.n	800eb14 <HAL_I2S_Init+0x1bc>
 800eb10:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 800eb14:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 800eb18:	f023 030f 	bic.w	r3, r3, #15
 800eb1c:	61d3      	str	r3, [r2, #28]
                                                 SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                                 SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
    I2SxEXT(hi2s->Instance)->I2SPR = 2U;
 800eb1e:	687b      	ldr	r3, [r7, #4]
 800eb20:	681b      	ldr	r3, [r3, #0]
 800eb22:	4a2b      	ldr	r2, [pc, #172]	; (800ebd0 <HAL_I2S_Init+0x278>)
 800eb24:	4293      	cmp	r3, r2
 800eb26:	d101      	bne.n	800eb2c <HAL_I2S_Init+0x1d4>
 800eb28:	4b2a      	ldr	r3, [pc, #168]	; (800ebd4 <HAL_I2S_Init+0x27c>)
 800eb2a:	e001      	b.n	800eb30 <HAL_I2S_Init+0x1d8>
 800eb2c:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800eb30:	2202      	movs	r2, #2
 800eb32:	621a      	str	r2, [r3, #32]

    /* Get the I2SCFGR register value */
    tmpreg = I2SxEXT(hi2s->Instance)->I2SCFGR;
 800eb34:	687b      	ldr	r3, [r7, #4]
 800eb36:	681b      	ldr	r3, [r3, #0]
 800eb38:	4a25      	ldr	r2, [pc, #148]	; (800ebd0 <HAL_I2S_Init+0x278>)
 800eb3a:	4293      	cmp	r3, r2
 800eb3c:	d101      	bne.n	800eb42 <HAL_I2S_Init+0x1ea>
 800eb3e:	4b25      	ldr	r3, [pc, #148]	; (800ebd4 <HAL_I2S_Init+0x27c>)
 800eb40:	e001      	b.n	800eb46 <HAL_I2S_Init+0x1ee>
 800eb42:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800eb46:	69db      	ldr	r3, [r3, #28]
 800eb48:	817b      	strh	r3, [r7, #10]

    /* Get the mode to be configured for the extended I2S */
    if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 800eb4a:	687b      	ldr	r3, [r7, #4]
 800eb4c:	685b      	ldr	r3, [r3, #4]
 800eb4e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800eb52:	d003      	beq.n	800eb5c <HAL_I2S_Init+0x204>
 800eb54:	687b      	ldr	r3, [r7, #4]
 800eb56:	685b      	ldr	r3, [r3, #4]
 800eb58:	2b00      	cmp	r3, #0
 800eb5a:	d103      	bne.n	800eb64 <HAL_I2S_Init+0x20c>
    {
      tmp = I2S_MODE_SLAVE_RX;
 800eb5c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800eb60:	613b      	str	r3, [r7, #16]
 800eb62:	e001      	b.n	800eb68 <HAL_I2S_Init+0x210>
    }
    else /* I2S_MODE_MASTER_RX ||  I2S_MODE_SLAVE_RX */
    {
      tmp = I2S_MODE_SLAVE_TX;
 800eb64:	2300      	movs	r3, #0
 800eb66:	613b      	str	r3, [r7, #16]
    }

    /* Configure the I2S Slave with the I2S Master parameter values */
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
                         (uint16_t)tmp                   | \
 800eb68:	693b      	ldr	r3, [r7, #16]
 800eb6a:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.Standard   | \
 800eb6c:	687b      	ldr	r3, [r7, #4]
 800eb6e:	689b      	ldr	r3, [r3, #8]
 800eb70:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 800eb72:	4313      	orrs	r3, r2
 800eb74:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.DataFormat | \
 800eb76:	687b      	ldr	r3, [r7, #4]
 800eb78:	68db      	ldr	r3, [r3, #12]
 800eb7a:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 800eb7c:	4313      	orrs	r3, r2
 800eb7e:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.CPOL);
 800eb80:	687b      	ldr	r3, [r7, #4]
 800eb82:	699b      	ldr	r3, [r3, #24]
 800eb84:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 800eb86:	4313      	orrs	r3, r2
 800eb88:	b29a      	uxth	r2, r3
 800eb8a:	897b      	ldrh	r3, [r7, #10]
 800eb8c:	4313      	orrs	r3, r2
 800eb8e:	b29b      	uxth	r3, r3
 800eb90:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800eb94:	817b      	strh	r3, [r7, #10]

    /* Write to SPIx I2SCFGR */
    WRITE_REG(I2SxEXT(hi2s->Instance)->I2SCFGR, tmpreg);
 800eb96:	687b      	ldr	r3, [r7, #4]
 800eb98:	681b      	ldr	r3, [r3, #0]
 800eb9a:	4a0d      	ldr	r2, [pc, #52]	; (800ebd0 <HAL_I2S_Init+0x278>)
 800eb9c:	4293      	cmp	r3, r2
 800eb9e:	d101      	bne.n	800eba4 <HAL_I2S_Init+0x24c>
 800eba0:	4b0c      	ldr	r3, [pc, #48]	; (800ebd4 <HAL_I2S_Init+0x27c>)
 800eba2:	e001      	b.n	800eba8 <HAL_I2S_Init+0x250>
 800eba4:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800eba8:	897a      	ldrh	r2, [r7, #10]
 800ebaa:	61da      	str	r2, [r3, #28]
  }
#endif /* SPI_I2S_FULLDUPLEX_SUPPORT */

  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 800ebac:	687b      	ldr	r3, [r7, #4]
 800ebae:	2200      	movs	r2, #0
 800ebb0:	645a      	str	r2, [r3, #68]	; 0x44
  hi2s->State     = HAL_I2S_STATE_READY;
 800ebb2:	687b      	ldr	r3, [r7, #4]
 800ebb4:	2201      	movs	r2, #1
 800ebb6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  return HAL_OK;
 800ebba:	2300      	movs	r3, #0
}
 800ebbc:	4618      	mov	r0, r3
 800ebbe:	3720      	adds	r7, #32
 800ebc0:	46bd      	mov	sp, r7
 800ebc2:	bd80      	pop	{r7, pc}
 800ebc4:	0800eccf 	.word	0x0800eccf
 800ebc8:	cccccccd 	.word	0xcccccccd
 800ebcc:	0800ede5 	.word	0x0800ede5
 800ebd0:	40003800 	.word	0x40003800
 800ebd4:	40003400 	.word	0x40003400

0800ebd8 <HAL_I2S_TxCpltCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 800ebd8:	b480      	push	{r7}
 800ebda:	b083      	sub	sp, #12
 800ebdc:	af00      	add	r7, sp, #0
 800ebde:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_TxCpltCallback could be implemented in the user file
   */
}
 800ebe0:	bf00      	nop
 800ebe2:	370c      	adds	r7, #12
 800ebe4:	46bd      	mov	sp, r7
 800ebe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ebea:	4770      	bx	lr

0800ebec <HAL_I2S_RxCpltCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 800ebec:	b480      	push	{r7}
 800ebee:	b083      	sub	sp, #12
 800ebf0:	af00      	add	r7, sp, #0
 800ebf2:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_RxCpltCallback could be implemented in the user file
   */
}
 800ebf4:	bf00      	nop
 800ebf6:	370c      	adds	r7, #12
 800ebf8:	46bd      	mov	sp, r7
 800ebfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ebfe:	4770      	bx	lr

0800ec00 <HAL_I2S_ErrorCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_ErrorCallback(I2S_HandleTypeDef *hi2s)
{
 800ec00:	b480      	push	{r7}
 800ec02:	b083      	sub	sp, #12
 800ec04:	af00      	add	r7, sp, #0
 800ec06:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_ErrorCallback could be implemented in the user file
   */
}
 800ec08:	bf00      	nop
 800ec0a:	370c      	adds	r7, #12
 800ec0c:	46bd      	mov	sp, r7
 800ec0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec12:	4770      	bx	lr

0800ec14 <I2S_Transmit_IT>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_Transmit_IT(I2S_HandleTypeDef *hi2s)
{
 800ec14:	b580      	push	{r7, lr}
 800ec16:	b082      	sub	sp, #8
 800ec18:	af00      	add	r7, sp, #0
 800ec1a:	6078      	str	r0, [r7, #4]
  /* Transmit data */
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr);
 800ec1c:	687b      	ldr	r3, [r7, #4]
 800ec1e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ec20:	881a      	ldrh	r2, [r3, #0]
 800ec22:	687b      	ldr	r3, [r7, #4]
 800ec24:	681b      	ldr	r3, [r3, #0]
 800ec26:	60da      	str	r2, [r3, #12]
  hi2s->pTxBuffPtr++;
 800ec28:	687b      	ldr	r3, [r7, #4]
 800ec2a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ec2c:	1c9a      	adds	r2, r3, #2
 800ec2e:	687b      	ldr	r3, [r7, #4]
 800ec30:	625a      	str	r2, [r3, #36]	; 0x24
  hi2s->TxXferCount--;
 800ec32:	687b      	ldr	r3, [r7, #4]
 800ec34:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ec36:	b29b      	uxth	r3, r3
 800ec38:	3b01      	subs	r3, #1
 800ec3a:	b29a      	uxth	r2, r3
 800ec3c:	687b      	ldr	r3, [r7, #4]
 800ec3e:	855a      	strh	r2, [r3, #42]	; 0x2a

  if (hi2s->TxXferCount == 0U)
 800ec40:	687b      	ldr	r3, [r7, #4]
 800ec42:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ec44:	b29b      	uxth	r3, r3
 800ec46:	2b00      	cmp	r3, #0
 800ec48:	d10e      	bne.n	800ec68 <I2S_Transmit_IT+0x54>
  {
    /* Disable TXE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800ec4a:	687b      	ldr	r3, [r7, #4]
 800ec4c:	681b      	ldr	r3, [r3, #0]
 800ec4e:	685a      	ldr	r2, [r3, #4]
 800ec50:	687b      	ldr	r3, [r7, #4]
 800ec52:	681b      	ldr	r3, [r3, #0]
 800ec54:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800ec58:	605a      	str	r2, [r3, #4]

    hi2s->State = HAL_I2S_STATE_READY;
 800ec5a:	687b      	ldr	r3, [r7, #4]
 800ec5c:	2201      	movs	r2, #1
 800ec5e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    /* Call user Tx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    hi2s->TxCpltCallback(hi2s);
#else
    HAL_I2S_TxCpltCallback(hi2s);
 800ec62:	6878      	ldr	r0, [r7, #4]
 800ec64:	f7ff ffb8 	bl	800ebd8 <HAL_I2S_TxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }
}
 800ec68:	bf00      	nop
 800ec6a:	3708      	adds	r7, #8
 800ec6c:	46bd      	mov	sp, r7
 800ec6e:	bd80      	pop	{r7, pc}

0800ec70 <I2S_Receive_IT>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_Receive_IT(I2S_HandleTypeDef *hi2s)
{
 800ec70:	b580      	push	{r7, lr}
 800ec72:	b082      	sub	sp, #8
 800ec74:	af00      	add	r7, sp, #0
 800ec76:	6078      	str	r0, [r7, #4]
  /* Receive data */
  (*hi2s->pRxBuffPtr) = (uint16_t)hi2s->Instance->DR;
 800ec78:	687b      	ldr	r3, [r7, #4]
 800ec7a:	681b      	ldr	r3, [r3, #0]
 800ec7c:	68da      	ldr	r2, [r3, #12]
 800ec7e:	687b      	ldr	r3, [r7, #4]
 800ec80:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ec82:	b292      	uxth	r2, r2
 800ec84:	801a      	strh	r2, [r3, #0]
  hi2s->pRxBuffPtr++;
 800ec86:	687b      	ldr	r3, [r7, #4]
 800ec88:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ec8a:	1c9a      	adds	r2, r3, #2
 800ec8c:	687b      	ldr	r3, [r7, #4]
 800ec8e:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2s->RxXferCount--;
 800ec90:	687b      	ldr	r3, [r7, #4]
 800ec92:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800ec94:	b29b      	uxth	r3, r3
 800ec96:	3b01      	subs	r3, #1
 800ec98:	b29a      	uxth	r2, r3
 800ec9a:	687b      	ldr	r3, [r7, #4]
 800ec9c:	865a      	strh	r2, [r3, #50]	; 0x32

  if (hi2s->RxXferCount == 0U)
 800ec9e:	687b      	ldr	r3, [r7, #4]
 800eca0:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800eca2:	b29b      	uxth	r3, r3
 800eca4:	2b00      	cmp	r3, #0
 800eca6:	d10e      	bne.n	800ecc6 <I2S_Receive_IT+0x56>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800eca8:	687b      	ldr	r3, [r7, #4]
 800ecaa:	681b      	ldr	r3, [r3, #0]
 800ecac:	685a      	ldr	r2, [r3, #4]
 800ecae:	687b      	ldr	r3, [r7, #4]
 800ecb0:	681b      	ldr	r3, [r3, #0]
 800ecb2:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800ecb6:	605a      	str	r2, [r3, #4]

    hi2s->State = HAL_I2S_STATE_READY;
 800ecb8:	687b      	ldr	r3, [r7, #4]
 800ecba:	2201      	movs	r2, #1
 800ecbc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    /* Call user Rx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    hi2s->RxCpltCallback(hi2s);
#else
    HAL_I2S_RxCpltCallback(hi2s);
 800ecc0:	6878      	ldr	r0, [r7, #4]
 800ecc2:	f7ff ff93 	bl	800ebec <HAL_I2S_RxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }
}
 800ecc6:	bf00      	nop
 800ecc8:	3708      	adds	r7, #8
 800ecca:	46bd      	mov	sp, r7
 800eccc:	bd80      	pop	{r7, pc}

0800ecce <I2S_IRQHandler>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 800ecce:	b580      	push	{r7, lr}
 800ecd0:	b086      	sub	sp, #24
 800ecd2:	af00      	add	r7, sp, #0
 800ecd4:	6078      	str	r0, [r7, #4]
  __IO uint32_t i2ssr = hi2s->Instance->SR;
 800ecd6:	687b      	ldr	r3, [r7, #4]
 800ecd8:	681b      	ldr	r3, [r3, #0]
 800ecda:	689b      	ldr	r3, [r3, #8]
 800ecdc:	617b      	str	r3, [r7, #20]

  if (hi2s->State == HAL_I2S_STATE_BUSY_RX)
 800ecde:	687b      	ldr	r3, [r7, #4]
 800ece0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800ece4:	b2db      	uxtb	r3, r3
 800ece6:	2b04      	cmp	r3, #4
 800ece8:	d13a      	bne.n	800ed60 <I2S_IRQHandler+0x92>
  {
    /* I2S in mode Receiver ------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE) != RESET))
 800ecea:	697b      	ldr	r3, [r7, #20]
 800ecec:	f003 0301 	and.w	r3, r3, #1
 800ecf0:	2b01      	cmp	r3, #1
 800ecf2:	d109      	bne.n	800ed08 <I2S_IRQHandler+0x3a>
 800ecf4:	687b      	ldr	r3, [r7, #4]
 800ecf6:	681b      	ldr	r3, [r3, #0]
 800ecf8:	685b      	ldr	r3, [r3, #4]
 800ecfa:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ecfe:	2b40      	cmp	r3, #64	; 0x40
 800ed00:	d102      	bne.n	800ed08 <I2S_IRQHandler+0x3a>
    {
      I2S_Receive_IT(hi2s);
 800ed02:	6878      	ldr	r0, [r7, #4]
 800ed04:	f7ff ffb4 	bl	800ec70 <I2S_Receive_IT>
    }

    /* I2S Overrun error interrupt occurred -------------------------------------*/
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 800ed08:	697b      	ldr	r3, [r7, #20]
 800ed0a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ed0e:	2b40      	cmp	r3, #64	; 0x40
 800ed10:	d126      	bne.n	800ed60 <I2S_IRQHandler+0x92>
 800ed12:	687b      	ldr	r3, [r7, #4]
 800ed14:	681b      	ldr	r3, [r3, #0]
 800ed16:	685b      	ldr	r3, [r3, #4]
 800ed18:	f003 0320 	and.w	r3, r3, #32
 800ed1c:	2b20      	cmp	r3, #32
 800ed1e:	d11f      	bne.n	800ed60 <I2S_IRQHandler+0x92>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800ed20:	687b      	ldr	r3, [r7, #4]
 800ed22:	681b      	ldr	r3, [r3, #0]
 800ed24:	685a      	ldr	r2, [r3, #4]
 800ed26:	687b      	ldr	r3, [r7, #4]
 800ed28:	681b      	ldr	r3, [r3, #0]
 800ed2a:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800ed2e:	605a      	str	r2, [r3, #4]

      /* Clear Overrun flag */
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 800ed30:	2300      	movs	r3, #0
 800ed32:	613b      	str	r3, [r7, #16]
 800ed34:	687b      	ldr	r3, [r7, #4]
 800ed36:	681b      	ldr	r3, [r3, #0]
 800ed38:	68db      	ldr	r3, [r3, #12]
 800ed3a:	613b      	str	r3, [r7, #16]
 800ed3c:	687b      	ldr	r3, [r7, #4]
 800ed3e:	681b      	ldr	r3, [r3, #0]
 800ed40:	689b      	ldr	r3, [r3, #8]
 800ed42:	613b      	str	r3, [r7, #16]
 800ed44:	693b      	ldr	r3, [r7, #16]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800ed46:	687b      	ldr	r3, [r7, #4]
 800ed48:	2201      	movs	r2, #1
 800ed4a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41


      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 800ed4e:	687b      	ldr	r3, [r7, #4]
 800ed50:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ed52:	f043 0202 	orr.w	r2, r3, #2
 800ed56:	687b      	ldr	r3, [r7, #4]
 800ed58:	645a      	str	r2, [r3, #68]	; 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800ed5a:	6878      	ldr	r0, [r7, #4]
 800ed5c:	f7ff ff50 	bl	800ec00 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }

  if (hi2s->State == HAL_I2S_STATE_BUSY_TX)
 800ed60:	687b      	ldr	r3, [r7, #4]
 800ed62:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800ed66:	b2db      	uxtb	r3, r3
 800ed68:	2b03      	cmp	r3, #3
 800ed6a:	d136      	bne.n	800edda <I2S_IRQHandler+0x10c>
  {
    /* I2S in mode Transmitter -----------------------------------------------*/
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE) != RESET))
 800ed6c:	697b      	ldr	r3, [r7, #20]
 800ed6e:	f003 0302 	and.w	r3, r3, #2
 800ed72:	2b02      	cmp	r3, #2
 800ed74:	d109      	bne.n	800ed8a <I2S_IRQHandler+0xbc>
 800ed76:	687b      	ldr	r3, [r7, #4]
 800ed78:	681b      	ldr	r3, [r3, #0]
 800ed7a:	685b      	ldr	r3, [r3, #4]
 800ed7c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ed80:	2b80      	cmp	r3, #128	; 0x80
 800ed82:	d102      	bne.n	800ed8a <I2S_IRQHandler+0xbc>
    {
      I2S_Transmit_IT(hi2s);
 800ed84:	6878      	ldr	r0, [r7, #4]
 800ed86:	f7ff ff45 	bl	800ec14 <I2S_Transmit_IT>
    }

    /* I2S Underrun error interrupt occurred --------------------------------*/
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 800ed8a:	697b      	ldr	r3, [r7, #20]
 800ed8c:	f003 0308 	and.w	r3, r3, #8
 800ed90:	2b08      	cmp	r3, #8
 800ed92:	d122      	bne.n	800edda <I2S_IRQHandler+0x10c>
 800ed94:	687b      	ldr	r3, [r7, #4]
 800ed96:	681b      	ldr	r3, [r3, #0]
 800ed98:	685b      	ldr	r3, [r3, #4]
 800ed9a:	f003 0320 	and.w	r3, r3, #32
 800ed9e:	2b20      	cmp	r3, #32
 800eda0:	d11b      	bne.n	800edda <I2S_IRQHandler+0x10c>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800eda2:	687b      	ldr	r3, [r7, #4]
 800eda4:	681b      	ldr	r3, [r3, #0]
 800eda6:	685a      	ldr	r2, [r3, #4]
 800eda8:	687b      	ldr	r3, [r7, #4]
 800edaa:	681b      	ldr	r3, [r3, #0]
 800edac:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800edb0:	605a      	str	r2, [r3, #4]

      /* Clear Underrun flag */
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 800edb2:	2300      	movs	r3, #0
 800edb4:	60fb      	str	r3, [r7, #12]
 800edb6:	687b      	ldr	r3, [r7, #4]
 800edb8:	681b      	ldr	r3, [r3, #0]
 800edba:	689b      	ldr	r3, [r3, #8]
 800edbc:	60fb      	str	r3, [r7, #12]
 800edbe:	68fb      	ldr	r3, [r7, #12]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800edc0:	687b      	ldr	r3, [r7, #4]
 800edc2:	2201      	movs	r2, #1
 800edc4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 800edc8:	687b      	ldr	r3, [r7, #4]
 800edca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800edcc:	f043 0204 	orr.w	r2, r3, #4
 800edd0:	687b      	ldr	r3, [r7, #4]
 800edd2:	645a      	str	r2, [r3, #68]	; 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800edd4:	6878      	ldr	r0, [r7, #4]
 800edd6:	f7ff ff13 	bl	800ec00 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800edda:	bf00      	nop
 800eddc:	3718      	adds	r7, #24
 800edde:	46bd      	mov	sp, r7
 800ede0:	bd80      	pop	{r7, pc}
	...

0800ede4 <HAL_I2SEx_FullDuplex_IRQHandler>:
  * @brief  This function handles I2S/I2Sext interrupt requests in full-duplex mode.
  * @param  hi2s I2S handle
  * @retval HAL status
  */
void HAL_I2SEx_FullDuplex_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 800ede4:	b580      	push	{r7, lr}
 800ede6:	b088      	sub	sp, #32
 800ede8:	af00      	add	r7, sp, #0
 800edea:	6078      	str	r0, [r7, #4]
  __IO uint32_t i2ssr     = hi2s->Instance->SR;
 800edec:	687b      	ldr	r3, [r7, #4]
 800edee:	681b      	ldr	r3, [r3, #0]
 800edf0:	689b      	ldr	r3, [r3, #8]
 800edf2:	61fb      	str	r3, [r7, #28]
  __IO uint32_t i2sextsr  = I2SxEXT(hi2s->Instance)->SR;
 800edf4:	687b      	ldr	r3, [r7, #4]
 800edf6:	681b      	ldr	r3, [r3, #0]
 800edf8:	4a92      	ldr	r2, [pc, #584]	; (800f044 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800edfa:	4293      	cmp	r3, r2
 800edfc:	d101      	bne.n	800ee02 <HAL_I2SEx_FullDuplex_IRQHandler+0x1e>
 800edfe:	4b92      	ldr	r3, [pc, #584]	; (800f048 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800ee00:	e001      	b.n	800ee06 <HAL_I2SEx_FullDuplex_IRQHandler+0x22>
 800ee02:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800ee06:	689b      	ldr	r3, [r3, #8]
 800ee08:	61bb      	str	r3, [r7, #24]
  __IO uint32_t i2scr2    = hi2s->Instance->CR2;
 800ee0a:	687b      	ldr	r3, [r7, #4]
 800ee0c:	681b      	ldr	r3, [r3, #0]
 800ee0e:	685b      	ldr	r3, [r3, #4]
 800ee10:	617b      	str	r3, [r7, #20]
  __IO uint32_t i2sextcr2 = I2SxEXT(hi2s->Instance)->CR2;
 800ee12:	687b      	ldr	r3, [r7, #4]
 800ee14:	681b      	ldr	r3, [r3, #0]
 800ee16:	4a8b      	ldr	r2, [pc, #556]	; (800f044 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800ee18:	4293      	cmp	r3, r2
 800ee1a:	d101      	bne.n	800ee20 <HAL_I2SEx_FullDuplex_IRQHandler+0x3c>
 800ee1c:	4b8a      	ldr	r3, [pc, #552]	; (800f048 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800ee1e:	e001      	b.n	800ee24 <HAL_I2SEx_FullDuplex_IRQHandler+0x40>
 800ee20:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800ee24:	685b      	ldr	r3, [r3, #4]
 800ee26:	613b      	str	r3, [r7, #16]

  /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
  if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 800ee28:	687b      	ldr	r3, [r7, #4]
 800ee2a:	685b      	ldr	r3, [r3, #4]
 800ee2c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800ee30:	d004      	beq.n	800ee3c <HAL_I2SEx_FullDuplex_IRQHandler+0x58>
 800ee32:	687b      	ldr	r3, [r7, #4]
 800ee34:	685b      	ldr	r3, [r3, #4]
 800ee36:	2b00      	cmp	r3, #0
 800ee38:	f040 8099 	bne.w	800ef6e <HAL_I2SEx_FullDuplex_IRQHandler+0x18a>
  {
    /* I2S in mode Transmitter -------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2scr2 & I2S_IT_TXE) != RESET))
 800ee3c:	69fb      	ldr	r3, [r7, #28]
 800ee3e:	f003 0302 	and.w	r3, r3, #2
 800ee42:	2b02      	cmp	r3, #2
 800ee44:	d107      	bne.n	800ee56 <HAL_I2SEx_FullDuplex_IRQHandler+0x72>
 800ee46:	697b      	ldr	r3, [r7, #20]
 800ee48:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ee4c:	2b00      	cmp	r3, #0
 800ee4e:	d002      	beq.n	800ee56 <HAL_I2SEx_FullDuplex_IRQHandler+0x72>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
      the I2S TXE interrupt will be generated to manage the full-duplex transmit phase. */
      I2SEx_TxISR_I2S(hi2s);
 800ee50:	6878      	ldr	r0, [r7, #4]
 800ee52:	f000 f925 	bl	800f0a0 <I2SEx_TxISR_I2S>
    }

    /* I2Sext in mode Receiver -----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2sextcr2 & I2S_IT_RXNE) != RESET))
 800ee56:	69bb      	ldr	r3, [r7, #24]
 800ee58:	f003 0301 	and.w	r3, r3, #1
 800ee5c:	2b01      	cmp	r3, #1
 800ee5e:	d107      	bne.n	800ee70 <HAL_I2SEx_FullDuplex_IRQHandler+0x8c>
 800ee60:	693b      	ldr	r3, [r7, #16]
 800ee62:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ee66:	2b00      	cmp	r3, #0
 800ee68:	d002      	beq.n	800ee70 <HAL_I2SEx_FullDuplex_IRQHandler+0x8c>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
      the I2Sext RXNE interrupt will be generated to manage the full-duplex receive phase. */
      I2SEx_RxISR_I2SExt(hi2s);
 800ee6a:	6878      	ldr	r0, [r7, #4]
 800ee6c:	f000 f9c8 	bl	800f200 <I2SEx_RxISR_I2SExt>
    }

    /* I2Sext Overrun error interrupt occurred --------------------------------*/
    if (((i2sextsr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 800ee70:	69bb      	ldr	r3, [r7, #24]
 800ee72:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ee76:	2b40      	cmp	r3, #64	; 0x40
 800ee78:	d13a      	bne.n	800eef0 <HAL_I2SEx_FullDuplex_IRQHandler+0x10c>
 800ee7a:	693b      	ldr	r3, [r7, #16]
 800ee7c:	f003 0320 	and.w	r3, r3, #32
 800ee80:	2b00      	cmp	r3, #0
 800ee82:	d035      	beq.n	800eef0 <HAL_I2SEx_FullDuplex_IRQHandler+0x10c>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800ee84:	687b      	ldr	r3, [r7, #4]
 800ee86:	681b      	ldr	r3, [r3, #0]
 800ee88:	4a6e      	ldr	r2, [pc, #440]	; (800f044 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800ee8a:	4293      	cmp	r3, r2
 800ee8c:	d101      	bne.n	800ee92 <HAL_I2SEx_FullDuplex_IRQHandler+0xae>
 800ee8e:	4b6e      	ldr	r3, [pc, #440]	; (800f048 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800ee90:	e001      	b.n	800ee96 <HAL_I2SEx_FullDuplex_IRQHandler+0xb2>
 800ee92:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800ee96:	685a      	ldr	r2, [r3, #4]
 800ee98:	687b      	ldr	r3, [r7, #4]
 800ee9a:	681b      	ldr	r3, [r3, #0]
 800ee9c:	4969      	ldr	r1, [pc, #420]	; (800f044 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800ee9e:	428b      	cmp	r3, r1
 800eea0:	d101      	bne.n	800eea6 <HAL_I2SEx_FullDuplex_IRQHandler+0xc2>
 800eea2:	4b69      	ldr	r3, [pc, #420]	; (800f048 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800eea4:	e001      	b.n	800eeaa <HAL_I2SEx_FullDuplex_IRQHandler+0xc6>
 800eea6:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800eeaa:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800eeae:	605a      	str	r2, [r3, #4]

      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800eeb0:	687b      	ldr	r3, [r7, #4]
 800eeb2:	681b      	ldr	r3, [r3, #0]
 800eeb4:	685a      	ldr	r2, [r3, #4]
 800eeb6:	687b      	ldr	r3, [r7, #4]
 800eeb8:	681b      	ldr	r3, [r3, #0]
 800eeba:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800eebe:	605a      	str	r2, [r3, #4]

      /* Clear Overrun flag */
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 800eec0:	2300      	movs	r3, #0
 800eec2:	60fb      	str	r3, [r7, #12]
 800eec4:	687b      	ldr	r3, [r7, #4]
 800eec6:	681b      	ldr	r3, [r3, #0]
 800eec8:	68db      	ldr	r3, [r3, #12]
 800eeca:	60fb      	str	r3, [r7, #12]
 800eecc:	687b      	ldr	r3, [r7, #4]
 800eece:	681b      	ldr	r3, [r3, #0]
 800eed0:	689b      	ldr	r3, [r3, #8]
 800eed2:	60fb      	str	r3, [r7, #12]
 800eed4:	68fb      	ldr	r3, [r7, #12]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800eed6:	687b      	ldr	r3, [r7, #4]
 800eed8:	2201      	movs	r2, #1
 800eeda:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 800eede:	687b      	ldr	r3, [r7, #4]
 800eee0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800eee2:	f043 0202 	orr.w	r2, r3, #2
 800eee6:	687b      	ldr	r3, [r7, #4]
 800eee8:	645a      	str	r2, [r3, #68]	; 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800eeea:	6878      	ldr	r0, [r7, #4]
 800eeec:	f7ff fe88 	bl	800ec00 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }

    /* I2S Underrun error interrupt occurred ----------------------------------*/
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 800eef0:	69fb      	ldr	r3, [r7, #28]
 800eef2:	f003 0308 	and.w	r3, r3, #8
 800eef6:	2b08      	cmp	r3, #8
 800eef8:	f040 80c3 	bne.w	800f082 <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
 800eefc:	697b      	ldr	r3, [r7, #20]
 800eefe:	f003 0320 	and.w	r3, r3, #32
 800ef02:	2b00      	cmp	r3, #0
 800ef04:	f000 80bd 	beq.w	800f082 <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800ef08:	687b      	ldr	r3, [r7, #4]
 800ef0a:	681b      	ldr	r3, [r3, #0]
 800ef0c:	685a      	ldr	r2, [r3, #4]
 800ef0e:	687b      	ldr	r3, [r7, #4]
 800ef10:	681b      	ldr	r3, [r3, #0]
 800ef12:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800ef16:	605a      	str	r2, [r3, #4]

      /* Disable RXNE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800ef18:	687b      	ldr	r3, [r7, #4]
 800ef1a:	681b      	ldr	r3, [r3, #0]
 800ef1c:	4a49      	ldr	r2, [pc, #292]	; (800f044 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800ef1e:	4293      	cmp	r3, r2
 800ef20:	d101      	bne.n	800ef26 <HAL_I2SEx_FullDuplex_IRQHandler+0x142>
 800ef22:	4b49      	ldr	r3, [pc, #292]	; (800f048 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800ef24:	e001      	b.n	800ef2a <HAL_I2SEx_FullDuplex_IRQHandler+0x146>
 800ef26:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800ef2a:	685a      	ldr	r2, [r3, #4]
 800ef2c:	687b      	ldr	r3, [r7, #4]
 800ef2e:	681b      	ldr	r3, [r3, #0]
 800ef30:	4944      	ldr	r1, [pc, #272]	; (800f044 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800ef32:	428b      	cmp	r3, r1
 800ef34:	d101      	bne.n	800ef3a <HAL_I2SEx_FullDuplex_IRQHandler+0x156>
 800ef36:	4b44      	ldr	r3, [pc, #272]	; (800f048 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800ef38:	e001      	b.n	800ef3e <HAL_I2SEx_FullDuplex_IRQHandler+0x15a>
 800ef3a:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800ef3e:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800ef42:	605a      	str	r2, [r3, #4]

      /* Clear underrun flag */
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 800ef44:	2300      	movs	r3, #0
 800ef46:	60bb      	str	r3, [r7, #8]
 800ef48:	687b      	ldr	r3, [r7, #4]
 800ef4a:	681b      	ldr	r3, [r3, #0]
 800ef4c:	689b      	ldr	r3, [r3, #8]
 800ef4e:	60bb      	str	r3, [r7, #8]
 800ef50:	68bb      	ldr	r3, [r7, #8]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800ef52:	687b      	ldr	r3, [r7, #4]
 800ef54:	2201      	movs	r2, #1
 800ef56:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 800ef5a:	687b      	ldr	r3, [r7, #4]
 800ef5c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ef5e:	f043 0204 	orr.w	r2, r3, #4
 800ef62:	687b      	ldr	r3, [r7, #4]
 800ef64:	645a      	str	r2, [r3, #68]	; 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800ef66:	6878      	ldr	r0, [r7, #4]
 800ef68:	f7ff fe4a 	bl	800ec00 <HAL_I2S_ErrorCallback>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 800ef6c:	e089      	b.n	800f082 <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
  }
  /* The I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX Mode is selected */
  else
  {
    /* I2Sext in mode Transmitter ----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2sextcr2 & I2S_IT_TXE) != RESET))
 800ef6e:	69bb      	ldr	r3, [r7, #24]
 800ef70:	f003 0302 	and.w	r3, r3, #2
 800ef74:	2b02      	cmp	r3, #2
 800ef76:	d107      	bne.n	800ef88 <HAL_I2SEx_FullDuplex_IRQHandler+0x1a4>
 800ef78:	693b      	ldr	r3, [r7, #16]
 800ef7a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ef7e:	2b00      	cmp	r3, #0
 800ef80:	d002      	beq.n	800ef88 <HAL_I2SEx_FullDuplex_IRQHandler+0x1a4>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
      the I2Sext TXE interrupt will be generated to manage the full-duplex transmit phase. */
      I2SEx_TxISR_I2SExt(hi2s);
 800ef82:	6878      	ldr	r0, [r7, #4]
 800ef84:	f000 f8be 	bl	800f104 <I2SEx_TxISR_I2SExt>
    }

    /* I2S in mode Receiver --------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2scr2 & I2S_IT_RXNE) != RESET))
 800ef88:	69fb      	ldr	r3, [r7, #28]
 800ef8a:	f003 0301 	and.w	r3, r3, #1
 800ef8e:	2b01      	cmp	r3, #1
 800ef90:	d107      	bne.n	800efa2 <HAL_I2SEx_FullDuplex_IRQHandler+0x1be>
 800ef92:	697b      	ldr	r3, [r7, #20]
 800ef94:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ef98:	2b00      	cmp	r3, #0
 800ef9a:	d002      	beq.n	800efa2 <HAL_I2SEx_FullDuplex_IRQHandler+0x1be>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
      the I2S RXNE interrupt will be generated to manage the full-duplex receive phase. */
      I2SEx_RxISR_I2S(hi2s);
 800ef9c:	6878      	ldr	r0, [r7, #4]
 800ef9e:	f000 f8fd 	bl	800f19c <I2SEx_RxISR_I2S>
    }

    /* I2S Overrun error interrupt occurred -------------------------------------*/
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 800efa2:	69fb      	ldr	r3, [r7, #28]
 800efa4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800efa8:	2b40      	cmp	r3, #64	; 0x40
 800efaa:	d12f      	bne.n	800f00c <HAL_I2SEx_FullDuplex_IRQHandler+0x228>
 800efac:	697b      	ldr	r3, [r7, #20]
 800efae:	f003 0320 	and.w	r3, r3, #32
 800efb2:	2b00      	cmp	r3, #0
 800efb4:	d02a      	beq.n	800f00c <HAL_I2SEx_FullDuplex_IRQHandler+0x228>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800efb6:	687b      	ldr	r3, [r7, #4]
 800efb8:	681b      	ldr	r3, [r3, #0]
 800efba:	685a      	ldr	r2, [r3, #4]
 800efbc:	687b      	ldr	r3, [r7, #4]
 800efbe:	681b      	ldr	r3, [r3, #0]
 800efc0:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800efc4:	605a      	str	r2, [r3, #4]

      /* Disable TXE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800efc6:	687b      	ldr	r3, [r7, #4]
 800efc8:	681b      	ldr	r3, [r3, #0]
 800efca:	4a1e      	ldr	r2, [pc, #120]	; (800f044 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800efcc:	4293      	cmp	r3, r2
 800efce:	d101      	bne.n	800efd4 <HAL_I2SEx_FullDuplex_IRQHandler+0x1f0>
 800efd0:	4b1d      	ldr	r3, [pc, #116]	; (800f048 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800efd2:	e001      	b.n	800efd8 <HAL_I2SEx_FullDuplex_IRQHandler+0x1f4>
 800efd4:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800efd8:	685a      	ldr	r2, [r3, #4]
 800efda:	687b      	ldr	r3, [r7, #4]
 800efdc:	681b      	ldr	r3, [r3, #0]
 800efde:	4919      	ldr	r1, [pc, #100]	; (800f044 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800efe0:	428b      	cmp	r3, r1
 800efe2:	d101      	bne.n	800efe8 <HAL_I2SEx_FullDuplex_IRQHandler+0x204>
 800efe4:	4b18      	ldr	r3, [pc, #96]	; (800f048 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800efe6:	e001      	b.n	800efec <HAL_I2SEx_FullDuplex_IRQHandler+0x208>
 800efe8:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800efec:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800eff0:	605a      	str	r2, [r3, #4]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800eff2:	687b      	ldr	r3, [r7, #4]
 800eff4:	2201      	movs	r2, #1
 800eff6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 800effa:	687b      	ldr	r3, [r7, #4]
 800effc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800effe:	f043 0202 	orr.w	r2, r3, #2
 800f002:	687b      	ldr	r3, [r7, #4]
 800f004:	645a      	str	r2, [r3, #68]	; 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800f006:	6878      	ldr	r0, [r7, #4]
 800f008:	f7ff fdfa 	bl	800ec00 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }

    /* I2Sext Underrun error interrupt occurred -------------------------------*/
    if (((i2sextsr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 800f00c:	69bb      	ldr	r3, [r7, #24]
 800f00e:	f003 0308 	and.w	r3, r3, #8
 800f012:	2b08      	cmp	r3, #8
 800f014:	d136      	bne.n	800f084 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
 800f016:	693b      	ldr	r3, [r7, #16]
 800f018:	f003 0320 	and.w	r3, r3, #32
 800f01c:	2b00      	cmp	r3, #0
 800f01e:	d031      	beq.n	800f084 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800f020:	687b      	ldr	r3, [r7, #4]
 800f022:	681b      	ldr	r3, [r3, #0]
 800f024:	4a07      	ldr	r2, [pc, #28]	; (800f044 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800f026:	4293      	cmp	r3, r2
 800f028:	d101      	bne.n	800f02e <HAL_I2SEx_FullDuplex_IRQHandler+0x24a>
 800f02a:	4b07      	ldr	r3, [pc, #28]	; (800f048 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800f02c:	e001      	b.n	800f032 <HAL_I2SEx_FullDuplex_IRQHandler+0x24e>
 800f02e:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800f032:	685a      	ldr	r2, [r3, #4]
 800f034:	687b      	ldr	r3, [r7, #4]
 800f036:	681b      	ldr	r3, [r3, #0]
 800f038:	4902      	ldr	r1, [pc, #8]	; (800f044 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800f03a:	428b      	cmp	r3, r1
 800f03c:	d106      	bne.n	800f04c <HAL_I2SEx_FullDuplex_IRQHandler+0x268>
 800f03e:	4b02      	ldr	r3, [pc, #8]	; (800f048 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800f040:	e006      	b.n	800f050 <HAL_I2SEx_FullDuplex_IRQHandler+0x26c>
 800f042:	bf00      	nop
 800f044:	40003800 	.word	0x40003800
 800f048:	40003400 	.word	0x40003400
 800f04c:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800f050:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800f054:	605a      	str	r2, [r3, #4]

      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800f056:	687b      	ldr	r3, [r7, #4]
 800f058:	681b      	ldr	r3, [r3, #0]
 800f05a:	685a      	ldr	r2, [r3, #4]
 800f05c:	687b      	ldr	r3, [r7, #4]
 800f05e:	681b      	ldr	r3, [r3, #0]
 800f060:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800f064:	605a      	str	r2, [r3, #4]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800f066:	687b      	ldr	r3, [r7, #4]
 800f068:	2201      	movs	r2, #1
 800f06a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 800f06e:	687b      	ldr	r3, [r7, #4]
 800f070:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f072:	f043 0204 	orr.w	r2, r3, #4
 800f076:	687b      	ldr	r3, [r7, #4]
 800f078:	645a      	str	r2, [r3, #68]	; 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800f07a:	6878      	ldr	r0, [r7, #4]
 800f07c:	f7ff fdc0 	bl	800ec00 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800f080:	e000      	b.n	800f084 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 800f082:	bf00      	nop
}
 800f084:	bf00      	nop
 800f086:	3720      	adds	r7, #32
 800f088:	46bd      	mov	sp, r7
 800f08a:	bd80      	pop	{r7, pc}

0800f08c <HAL_I2SEx_TxRxCpltCallback>:
  * @brief  Tx and Rx Transfer completed callback
  * @param  hi2s I2S handle
  * @retval None
  */
__weak void HAL_I2SEx_TxRxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 800f08c:	b480      	push	{r7}
 800f08e:	b083      	sub	sp, #12
 800f090:	af00      	add	r7, sp, #0
 800f092:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2SEx_TxRxCpltCallback could be implemented in the user file
   */
}
 800f094:	bf00      	nop
 800f096:	370c      	adds	r7, #12
 800f098:	46bd      	mov	sp, r7
 800f09a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f09e:	4770      	bx	lr

0800f0a0 <I2SEx_TxISR_I2S>:
  * @brief  I2S Full-Duplex IT handler transmit function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_TxISR_I2S(I2S_HandleTypeDef *hi2s)
{
 800f0a0:	b580      	push	{r7, lr}
 800f0a2:	b082      	sub	sp, #8
 800f0a4:	af00      	add	r7, sp, #0
 800f0a6:	6078      	str	r0, [r7, #4]
  /* Write Data on DR register */
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr++);
 800f0a8:	687b      	ldr	r3, [r7, #4]
 800f0aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f0ac:	1c99      	adds	r1, r3, #2
 800f0ae:	687a      	ldr	r2, [r7, #4]
 800f0b0:	6251      	str	r1, [r2, #36]	; 0x24
 800f0b2:	881a      	ldrh	r2, [r3, #0]
 800f0b4:	687b      	ldr	r3, [r7, #4]
 800f0b6:	681b      	ldr	r3, [r3, #0]
 800f0b8:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 800f0ba:	687b      	ldr	r3, [r7, #4]
 800f0bc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800f0be:	b29b      	uxth	r3, r3
 800f0c0:	3b01      	subs	r3, #1
 800f0c2:	b29a      	uxth	r2, r3
 800f0c4:	687b      	ldr	r3, [r7, #4]
 800f0c6:	855a      	strh	r2, [r3, #42]	; 0x2a

  if (hi2s->TxXferCount == 0U)
 800f0c8:	687b      	ldr	r3, [r7, #4]
 800f0ca:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800f0cc:	b29b      	uxth	r3, r3
 800f0ce:	2b00      	cmp	r3, #0
 800f0d0:	d113      	bne.n	800f0fa <I2SEx_TxISR_I2S+0x5a>
  {
    /* Disable TXE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800f0d2:	687b      	ldr	r3, [r7, #4]
 800f0d4:	681b      	ldr	r3, [r3, #0]
 800f0d6:	685a      	ldr	r2, [r3, #4]
 800f0d8:	687b      	ldr	r3, [r7, #4]
 800f0da:	681b      	ldr	r3, [r3, #0]
 800f0dc:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800f0e0:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 800f0e2:	687b      	ldr	r3, [r7, #4]
 800f0e4:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800f0e6:	b29b      	uxth	r3, r3
 800f0e8:	2b00      	cmp	r3, #0
 800f0ea:	d106      	bne.n	800f0fa <I2SEx_TxISR_I2S+0x5a>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 800f0ec:	687b      	ldr	r3, [r7, #4]
 800f0ee:	2201      	movs	r2, #1
 800f0f0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800f0f4:	6878      	ldr	r0, [r7, #4]
 800f0f6:	f7ff ffc9 	bl	800f08c <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800f0fa:	bf00      	nop
 800f0fc:	3708      	adds	r7, #8
 800f0fe:	46bd      	mov	sp, r7
 800f100:	bd80      	pop	{r7, pc}
	...

0800f104 <I2SEx_TxISR_I2SExt>:
  * @brief  I2SExt Full-Duplex IT handler transmit function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_TxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
 800f104:	b580      	push	{r7, lr}
 800f106:	b082      	sub	sp, #8
 800f108:	af00      	add	r7, sp, #0
 800f10a:	6078      	str	r0, [r7, #4]
  /* Write Data on DR register */
  I2SxEXT(hi2s->Instance)->DR = (*hi2s->pTxBuffPtr++);
 800f10c:	687b      	ldr	r3, [r7, #4]
 800f10e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f110:	1c99      	adds	r1, r3, #2
 800f112:	687a      	ldr	r2, [r7, #4]
 800f114:	6251      	str	r1, [r2, #36]	; 0x24
 800f116:	8819      	ldrh	r1, [r3, #0]
 800f118:	687b      	ldr	r3, [r7, #4]
 800f11a:	681b      	ldr	r3, [r3, #0]
 800f11c:	4a1d      	ldr	r2, [pc, #116]	; (800f194 <I2SEx_TxISR_I2SExt+0x90>)
 800f11e:	4293      	cmp	r3, r2
 800f120:	d101      	bne.n	800f126 <I2SEx_TxISR_I2SExt+0x22>
 800f122:	4b1d      	ldr	r3, [pc, #116]	; (800f198 <I2SEx_TxISR_I2SExt+0x94>)
 800f124:	e001      	b.n	800f12a <I2SEx_TxISR_I2SExt+0x26>
 800f126:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800f12a:	460a      	mov	r2, r1
 800f12c:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 800f12e:	687b      	ldr	r3, [r7, #4]
 800f130:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800f132:	b29b      	uxth	r3, r3
 800f134:	3b01      	subs	r3, #1
 800f136:	b29a      	uxth	r2, r3
 800f138:	687b      	ldr	r3, [r7, #4]
 800f13a:	855a      	strh	r2, [r3, #42]	; 0x2a

  if (hi2s->TxXferCount == 0U)
 800f13c:	687b      	ldr	r3, [r7, #4]
 800f13e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800f140:	b29b      	uxth	r3, r3
 800f142:	2b00      	cmp	r3, #0
 800f144:	d121      	bne.n	800f18a <I2SEx_TxISR_I2SExt+0x86>
  {
    /* Disable I2Sext TXE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800f146:	687b      	ldr	r3, [r7, #4]
 800f148:	681b      	ldr	r3, [r3, #0]
 800f14a:	4a12      	ldr	r2, [pc, #72]	; (800f194 <I2SEx_TxISR_I2SExt+0x90>)
 800f14c:	4293      	cmp	r3, r2
 800f14e:	d101      	bne.n	800f154 <I2SEx_TxISR_I2SExt+0x50>
 800f150:	4b11      	ldr	r3, [pc, #68]	; (800f198 <I2SEx_TxISR_I2SExt+0x94>)
 800f152:	e001      	b.n	800f158 <I2SEx_TxISR_I2SExt+0x54>
 800f154:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800f158:	685a      	ldr	r2, [r3, #4]
 800f15a:	687b      	ldr	r3, [r7, #4]
 800f15c:	681b      	ldr	r3, [r3, #0]
 800f15e:	490d      	ldr	r1, [pc, #52]	; (800f194 <I2SEx_TxISR_I2SExt+0x90>)
 800f160:	428b      	cmp	r3, r1
 800f162:	d101      	bne.n	800f168 <I2SEx_TxISR_I2SExt+0x64>
 800f164:	4b0c      	ldr	r3, [pc, #48]	; (800f198 <I2SEx_TxISR_I2SExt+0x94>)
 800f166:	e001      	b.n	800f16c <I2SEx_TxISR_I2SExt+0x68>
 800f168:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800f16c:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800f170:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 800f172:	687b      	ldr	r3, [r7, #4]
 800f174:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800f176:	b29b      	uxth	r3, r3
 800f178:	2b00      	cmp	r3, #0
 800f17a:	d106      	bne.n	800f18a <I2SEx_TxISR_I2SExt+0x86>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 800f17c:	687b      	ldr	r3, [r7, #4]
 800f17e:	2201      	movs	r2, #1
 800f180:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800f184:	6878      	ldr	r0, [r7, #4]
 800f186:	f7ff ff81 	bl	800f08c <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800f18a:	bf00      	nop
 800f18c:	3708      	adds	r7, #8
 800f18e:	46bd      	mov	sp, r7
 800f190:	bd80      	pop	{r7, pc}
 800f192:	bf00      	nop
 800f194:	40003800 	.word	0x40003800
 800f198:	40003400 	.word	0x40003400

0800f19c <I2SEx_RxISR_I2S>:
  * @brief  I2S Full-Duplex IT handler receive function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_RxISR_I2S(I2S_HandleTypeDef *hi2s)
{
 800f19c:	b580      	push	{r7, lr}
 800f19e:	b082      	sub	sp, #8
 800f1a0:	af00      	add	r7, sp, #0
 800f1a2:	6078      	str	r0, [r7, #4]
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = hi2s->Instance->DR;
 800f1a4:	687b      	ldr	r3, [r7, #4]
 800f1a6:	681b      	ldr	r3, [r3, #0]
 800f1a8:	68d8      	ldr	r0, [r3, #12]
 800f1aa:	687b      	ldr	r3, [r7, #4]
 800f1ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f1ae:	1c99      	adds	r1, r3, #2
 800f1b0:	687a      	ldr	r2, [r7, #4]
 800f1b2:	62d1      	str	r1, [r2, #44]	; 0x2c
 800f1b4:	b282      	uxth	r2, r0
 800f1b6:	801a      	strh	r2, [r3, #0]
  hi2s->RxXferCount--;
 800f1b8:	687b      	ldr	r3, [r7, #4]
 800f1ba:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800f1bc:	b29b      	uxth	r3, r3
 800f1be:	3b01      	subs	r3, #1
 800f1c0:	b29a      	uxth	r2, r3
 800f1c2:	687b      	ldr	r3, [r7, #4]
 800f1c4:	865a      	strh	r2, [r3, #50]	; 0x32

  if (hi2s->RxXferCount == 0U)
 800f1c6:	687b      	ldr	r3, [r7, #4]
 800f1c8:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800f1ca:	b29b      	uxth	r3, r3
 800f1cc:	2b00      	cmp	r3, #0
 800f1ce:	d113      	bne.n	800f1f8 <I2SEx_RxISR_I2S+0x5c>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800f1d0:	687b      	ldr	r3, [r7, #4]
 800f1d2:	681b      	ldr	r3, [r3, #0]
 800f1d4:	685a      	ldr	r2, [r3, #4]
 800f1d6:	687b      	ldr	r3, [r7, #4]
 800f1d8:	681b      	ldr	r3, [r3, #0]
 800f1da:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800f1de:	605a      	str	r2, [r3, #4]

    if (hi2s->TxXferCount == 0U)
 800f1e0:	687b      	ldr	r3, [r7, #4]
 800f1e2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800f1e4:	b29b      	uxth	r3, r3
 800f1e6:	2b00      	cmp	r3, #0
 800f1e8:	d106      	bne.n	800f1f8 <I2SEx_RxISR_I2S+0x5c>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 800f1ea:	687b      	ldr	r3, [r7, #4]
 800f1ec:	2201      	movs	r2, #1
 800f1ee:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800f1f2:	6878      	ldr	r0, [r7, #4]
 800f1f4:	f7ff ff4a 	bl	800f08c <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800f1f8:	bf00      	nop
 800f1fa:	3708      	adds	r7, #8
 800f1fc:	46bd      	mov	sp, r7
 800f1fe:	bd80      	pop	{r7, pc}

0800f200 <I2SEx_RxISR_I2SExt>:
  * @brief  I2SExt Full-Duplex IT handler receive function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_RxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
 800f200:	b580      	push	{r7, lr}
 800f202:	b082      	sub	sp, #8
 800f204:	af00      	add	r7, sp, #0
 800f206:	6078      	str	r0, [r7, #4]
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = I2SxEXT(hi2s->Instance)->DR;
 800f208:	687b      	ldr	r3, [r7, #4]
 800f20a:	681b      	ldr	r3, [r3, #0]
 800f20c:	4a20      	ldr	r2, [pc, #128]	; (800f290 <I2SEx_RxISR_I2SExt+0x90>)
 800f20e:	4293      	cmp	r3, r2
 800f210:	d101      	bne.n	800f216 <I2SEx_RxISR_I2SExt+0x16>
 800f212:	4b20      	ldr	r3, [pc, #128]	; (800f294 <I2SEx_RxISR_I2SExt+0x94>)
 800f214:	e001      	b.n	800f21a <I2SEx_RxISR_I2SExt+0x1a>
 800f216:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800f21a:	68d8      	ldr	r0, [r3, #12]
 800f21c:	687b      	ldr	r3, [r7, #4]
 800f21e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f220:	1c99      	adds	r1, r3, #2
 800f222:	687a      	ldr	r2, [r7, #4]
 800f224:	62d1      	str	r1, [r2, #44]	; 0x2c
 800f226:	b282      	uxth	r2, r0
 800f228:	801a      	strh	r2, [r3, #0]
  hi2s->RxXferCount--;
 800f22a:	687b      	ldr	r3, [r7, #4]
 800f22c:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800f22e:	b29b      	uxth	r3, r3
 800f230:	3b01      	subs	r3, #1
 800f232:	b29a      	uxth	r2, r3
 800f234:	687b      	ldr	r3, [r7, #4]
 800f236:	865a      	strh	r2, [r3, #50]	; 0x32

  if (hi2s->RxXferCount == 0U)
 800f238:	687b      	ldr	r3, [r7, #4]
 800f23a:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800f23c:	b29b      	uxth	r3, r3
 800f23e:	2b00      	cmp	r3, #0
 800f240:	d121      	bne.n	800f286 <I2SEx_RxISR_I2SExt+0x86>
  {
    /* Disable I2Sext RXNE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800f242:	687b      	ldr	r3, [r7, #4]
 800f244:	681b      	ldr	r3, [r3, #0]
 800f246:	4a12      	ldr	r2, [pc, #72]	; (800f290 <I2SEx_RxISR_I2SExt+0x90>)
 800f248:	4293      	cmp	r3, r2
 800f24a:	d101      	bne.n	800f250 <I2SEx_RxISR_I2SExt+0x50>
 800f24c:	4b11      	ldr	r3, [pc, #68]	; (800f294 <I2SEx_RxISR_I2SExt+0x94>)
 800f24e:	e001      	b.n	800f254 <I2SEx_RxISR_I2SExt+0x54>
 800f250:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800f254:	685a      	ldr	r2, [r3, #4]
 800f256:	687b      	ldr	r3, [r7, #4]
 800f258:	681b      	ldr	r3, [r3, #0]
 800f25a:	490d      	ldr	r1, [pc, #52]	; (800f290 <I2SEx_RxISR_I2SExt+0x90>)
 800f25c:	428b      	cmp	r3, r1
 800f25e:	d101      	bne.n	800f264 <I2SEx_RxISR_I2SExt+0x64>
 800f260:	4b0c      	ldr	r3, [pc, #48]	; (800f294 <I2SEx_RxISR_I2SExt+0x94>)
 800f262:	e001      	b.n	800f268 <I2SEx_RxISR_I2SExt+0x68>
 800f264:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
 800f268:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 800f26c:	605a      	str	r2, [r3, #4]

    if (hi2s->TxXferCount == 0U)
 800f26e:	687b      	ldr	r3, [r7, #4]
 800f270:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800f272:	b29b      	uxth	r3, r3
 800f274:	2b00      	cmp	r3, #0
 800f276:	d106      	bne.n	800f286 <I2SEx_RxISR_I2SExt+0x86>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 800f278:	687b      	ldr	r3, [r7, #4]
 800f27a:	2201      	movs	r2, #1
 800f27c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800f280:	6878      	ldr	r0, [r7, #4]
 800f282:	f7ff ff03 	bl	800f08c <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800f286:	bf00      	nop
 800f288:	3708      	adds	r7, #8
 800f28a:	46bd      	mov	sp, r7
 800f28c:	bd80      	pop	{r7, pc}
 800f28e:	bf00      	nop
 800f290:	40003800 	.word	0x40003800
 800f294:	40003400 	.word	0x40003400

0800f298 <HAL_RCCEx_GetPeriphCLKFreq>:
  *         This parameter can be one of the following values:
  *            @arg RCC_PERIPHCLK_I2S: I2S peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 800f298:	b480      	push	{r7}
 800f29a:	b087      	sub	sp, #28
 800f29c:	af00      	add	r7, sp, #0
 800f29e:	6078      	str	r0, [r7, #4]
  /* This variable used to store the I2S clock frequency (value in Hz) */
  uint32_t frequency = 0U;
 800f2a0:	2300      	movs	r3, #0
 800f2a2:	617b      	str	r3, [r7, #20]
  /* This variable used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0U;
 800f2a4:	2300      	movs	r3, #0
 800f2a6:	613b      	str	r3, [r7, #16]
  uint32_t srcclk = 0U;
 800f2a8:	2300      	movs	r3, #0
 800f2aa:	60fb      	str	r3, [r7, #12]
  /* This variable used to store the VCO Output (value in Hz) */
  uint32_t vcooutput = 0U;
 800f2ac:	2300      	movs	r3, #0
 800f2ae:	60bb      	str	r3, [r7, #8]
  switch (PeriphClk)
 800f2b0:	687b      	ldr	r3, [r7, #4]
 800f2b2:	2b01      	cmp	r3, #1
 800f2b4:	d13e      	bne.n	800f334 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
  {
  case RCC_PERIPHCLK_I2S:
    {
      /* Get the current I2S source */
      srcclk = __HAL_RCC_GET_I2S_SOURCE();
 800f2b6:	4b23      	ldr	r3, [pc, #140]	; (800f344 <HAL_RCCEx_GetPeriphCLKFreq+0xac>)
 800f2b8:	689b      	ldr	r3, [r3, #8]
 800f2ba:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800f2be:	60fb      	str	r3, [r7, #12]
 800f2c0:	68fb      	ldr	r3, [r7, #12]
 800f2c2:	2b00      	cmp	r3, #0
 800f2c4:	d005      	beq.n	800f2d2 <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
 800f2c6:	68fb      	ldr	r3, [r7, #12]
 800f2c8:	2b01      	cmp	r3, #1
 800f2ca:	d12f      	bne.n	800f32c <HAL_RCCEx_GetPeriphCLKFreq+0x94>
      {
      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */
      case RCC_I2SCLKSOURCE_EXT:
        {
          /* Set the I2S clock to the external clock  value */
          frequency = EXTERNAL_CLOCK_VALUE;
 800f2cc:	4b1e      	ldr	r3, [pc, #120]	; (800f348 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>)
 800f2ce:	617b      	str	r3, [r7, #20]
          break;
 800f2d0:	e02f      	b.n	800f332 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
          }
#else
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 800f2d2:	4b1c      	ldr	r3, [pc, #112]	; (800f344 <HAL_RCCEx_GetPeriphCLKFreq+0xac>)
 800f2d4:	685b      	ldr	r3, [r3, #4]
 800f2d6:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800f2da:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800f2de:	d108      	bne.n	800f2f2 <HAL_RCCEx_GetPeriphCLKFreq+0x5a>
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 800f2e0:	4b18      	ldr	r3, [pc, #96]	; (800f344 <HAL_RCCEx_GetPeriphCLKFreq+0xac>)
 800f2e2:	685b      	ldr	r3, [r3, #4]
 800f2e4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f2e8:	4a18      	ldr	r2, [pc, #96]	; (800f34c <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 800f2ea:	fbb2 f3f3 	udiv	r3, r2, r3
 800f2ee:	613b      	str	r3, [r7, #16]
 800f2f0:	e007      	b.n	800f302 <HAL_RCCEx_GetPeriphCLKFreq+0x6a>
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 800f2f2:	4b14      	ldr	r3, [pc, #80]	; (800f344 <HAL_RCCEx_GetPeriphCLKFreq+0xac>)
 800f2f4:	685b      	ldr	r3, [r3, #4]
 800f2f6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f2fa:	4a15      	ldr	r2, [pc, #84]	; (800f350 <HAL_RCCEx_GetPeriphCLKFreq+0xb8>)
 800f2fc:	fbb2 f3f3 	udiv	r3, r2, r3
 800f300:	613b      	str	r3, [r7, #16]
          }
#endif /* STM32F411xE */
          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
 800f302:	4b10      	ldr	r3, [pc, #64]	; (800f344 <HAL_RCCEx_GetPeriphCLKFreq+0xac>)
 800f304:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800f308:	099b      	lsrs	r3, r3, #6
 800f30a:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800f30e:	693b      	ldr	r3, [r7, #16]
 800f310:	fb02 f303 	mul.w	r3, r2, r3
 800f314:	60bb      	str	r3, [r7, #8]
          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
 800f316:	4b0b      	ldr	r3, [pc, #44]	; (800f344 <HAL_RCCEx_GetPeriphCLKFreq+0xac>)
 800f318:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800f31c:	0f1b      	lsrs	r3, r3, #28
 800f31e:	f003 0307 	and.w	r3, r3, #7
 800f322:	68ba      	ldr	r2, [r7, #8]
 800f324:	fbb2 f3f3 	udiv	r3, r2, r3
 800f328:	617b      	str	r3, [r7, #20]
          break;
 800f32a:	e002      	b.n	800f332 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
        }
        /* Clock not enabled for I2S*/
      default:
        {
          frequency = 0U;
 800f32c:	2300      	movs	r3, #0
 800f32e:	617b      	str	r3, [r7, #20]
          break;
 800f330:	bf00      	nop
        }
      }
      break;
 800f332:	bf00      	nop
    }
  }
  return frequency;
 800f334:	697b      	ldr	r3, [r7, #20]
}
 800f336:	4618      	mov	r0, r3
 800f338:	371c      	adds	r7, #28
 800f33a:	46bd      	mov	sp, r7
 800f33c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f340:	4770      	bx	lr
 800f342:	bf00      	nop
 800f344:	40023800 	.word	0x40023800
 800f348:	00bb8000 	.word	0x00bb8000
 800f34c:	007a1200 	.word	0x007a1200
 800f350:	00f42400 	.word	0x00f42400

0800f354 <LL_GPIO_SetPinMode>:
{
 800f354:	b480      	push	{r7}
 800f356:	b089      	sub	sp, #36	; 0x24
 800f358:	af00      	add	r7, sp, #0
 800f35a:	60f8      	str	r0, [r7, #12]
 800f35c:	60b9      	str	r1, [r7, #8]
 800f35e:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 800f360:	68fb      	ldr	r3, [r7, #12]
 800f362:	681a      	ldr	r2, [r3, #0]
 800f364:	68bb      	ldr	r3, [r7, #8]
 800f366:	617b      	str	r3, [r7, #20]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f368:	697b      	ldr	r3, [r7, #20]
 800f36a:	fa93 f3a3 	rbit	r3, r3
 800f36e:	613b      	str	r3, [r7, #16]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 800f370:	693b      	ldr	r3, [r7, #16]
 800f372:	fab3 f383 	clz	r3, r3
 800f376:	b2db      	uxtb	r3, r3
 800f378:	005b      	lsls	r3, r3, #1
 800f37a:	2103      	movs	r1, #3
 800f37c:	fa01 f303 	lsl.w	r3, r1, r3
 800f380:	43db      	mvns	r3, r3
 800f382:	401a      	ands	r2, r3
 800f384:	68bb      	ldr	r3, [r7, #8]
 800f386:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f388:	69fb      	ldr	r3, [r7, #28]
 800f38a:	fa93 f3a3 	rbit	r3, r3
 800f38e:	61bb      	str	r3, [r7, #24]
  return result;
 800f390:	69bb      	ldr	r3, [r7, #24]
 800f392:	fab3 f383 	clz	r3, r3
 800f396:	b2db      	uxtb	r3, r3
 800f398:	005b      	lsls	r3, r3, #1
 800f39a:	6879      	ldr	r1, [r7, #4]
 800f39c:	fa01 f303 	lsl.w	r3, r1, r3
 800f3a0:	431a      	orrs	r2, r3
 800f3a2:	68fb      	ldr	r3, [r7, #12]
 800f3a4:	601a      	str	r2, [r3, #0]
}
 800f3a6:	bf00      	nop
 800f3a8:	3724      	adds	r7, #36	; 0x24
 800f3aa:	46bd      	mov	sp, r7
 800f3ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3b0:	4770      	bx	lr

0800f3b2 <LL_GPIO_SetPinOutputType>:
{
 800f3b2:	b480      	push	{r7}
 800f3b4:	b085      	sub	sp, #20
 800f3b6:	af00      	add	r7, sp, #0
 800f3b8:	60f8      	str	r0, [r7, #12]
 800f3ba:	60b9      	str	r1, [r7, #8]
 800f3bc:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 800f3be:	68fb      	ldr	r3, [r7, #12]
 800f3c0:	685a      	ldr	r2, [r3, #4]
 800f3c2:	68bb      	ldr	r3, [r7, #8]
 800f3c4:	43db      	mvns	r3, r3
 800f3c6:	401a      	ands	r2, r3
 800f3c8:	68bb      	ldr	r3, [r7, #8]
 800f3ca:	6879      	ldr	r1, [r7, #4]
 800f3cc:	fb01 f303 	mul.w	r3, r1, r3
 800f3d0:	431a      	orrs	r2, r3
 800f3d2:	68fb      	ldr	r3, [r7, #12]
 800f3d4:	605a      	str	r2, [r3, #4]
}
 800f3d6:	bf00      	nop
 800f3d8:	3714      	adds	r7, #20
 800f3da:	46bd      	mov	sp, r7
 800f3dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3e0:	4770      	bx	lr

0800f3e2 <LL_GPIO_SetPinSpeed>:
{
 800f3e2:	b480      	push	{r7}
 800f3e4:	b089      	sub	sp, #36	; 0x24
 800f3e6:	af00      	add	r7, sp, #0
 800f3e8:	60f8      	str	r0, [r7, #12]
 800f3ea:	60b9      	str	r1, [r7, #8]
 800f3ec:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 800f3ee:	68fb      	ldr	r3, [r7, #12]
 800f3f0:	689a      	ldr	r2, [r3, #8]
 800f3f2:	68bb      	ldr	r3, [r7, #8]
 800f3f4:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f3f6:	697b      	ldr	r3, [r7, #20]
 800f3f8:	fa93 f3a3 	rbit	r3, r3
 800f3fc:	613b      	str	r3, [r7, #16]
  return result;
 800f3fe:	693b      	ldr	r3, [r7, #16]
 800f400:	fab3 f383 	clz	r3, r3
 800f404:	b2db      	uxtb	r3, r3
 800f406:	005b      	lsls	r3, r3, #1
 800f408:	2103      	movs	r1, #3
 800f40a:	fa01 f303 	lsl.w	r3, r1, r3
 800f40e:	43db      	mvns	r3, r3
 800f410:	401a      	ands	r2, r3
 800f412:	68bb      	ldr	r3, [r7, #8]
 800f414:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f416:	69fb      	ldr	r3, [r7, #28]
 800f418:	fa93 f3a3 	rbit	r3, r3
 800f41c:	61bb      	str	r3, [r7, #24]
  return result;
 800f41e:	69bb      	ldr	r3, [r7, #24]
 800f420:	fab3 f383 	clz	r3, r3
 800f424:	b2db      	uxtb	r3, r3
 800f426:	005b      	lsls	r3, r3, #1
 800f428:	6879      	ldr	r1, [r7, #4]
 800f42a:	fa01 f303 	lsl.w	r3, r1, r3
 800f42e:	431a      	orrs	r2, r3
 800f430:	68fb      	ldr	r3, [r7, #12]
 800f432:	609a      	str	r2, [r3, #8]
}
 800f434:	bf00      	nop
 800f436:	3724      	adds	r7, #36	; 0x24
 800f438:	46bd      	mov	sp, r7
 800f43a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f43e:	4770      	bx	lr

0800f440 <LL_GPIO_SetPinPull>:
{
 800f440:	b480      	push	{r7}
 800f442:	b089      	sub	sp, #36	; 0x24
 800f444:	af00      	add	r7, sp, #0
 800f446:	60f8      	str	r0, [r7, #12]
 800f448:	60b9      	str	r1, [r7, #8]
 800f44a:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 800f44c:	68fb      	ldr	r3, [r7, #12]
 800f44e:	68da      	ldr	r2, [r3, #12]
 800f450:	68bb      	ldr	r3, [r7, #8]
 800f452:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f454:	697b      	ldr	r3, [r7, #20]
 800f456:	fa93 f3a3 	rbit	r3, r3
 800f45a:	613b      	str	r3, [r7, #16]
  return result;
 800f45c:	693b      	ldr	r3, [r7, #16]
 800f45e:	fab3 f383 	clz	r3, r3
 800f462:	b2db      	uxtb	r3, r3
 800f464:	005b      	lsls	r3, r3, #1
 800f466:	2103      	movs	r1, #3
 800f468:	fa01 f303 	lsl.w	r3, r1, r3
 800f46c:	43db      	mvns	r3, r3
 800f46e:	401a      	ands	r2, r3
 800f470:	68bb      	ldr	r3, [r7, #8]
 800f472:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f474:	69fb      	ldr	r3, [r7, #28]
 800f476:	fa93 f3a3 	rbit	r3, r3
 800f47a:	61bb      	str	r3, [r7, #24]
  return result;
 800f47c:	69bb      	ldr	r3, [r7, #24]
 800f47e:	fab3 f383 	clz	r3, r3
 800f482:	b2db      	uxtb	r3, r3
 800f484:	005b      	lsls	r3, r3, #1
 800f486:	6879      	ldr	r1, [r7, #4]
 800f488:	fa01 f303 	lsl.w	r3, r1, r3
 800f48c:	431a      	orrs	r2, r3
 800f48e:	68fb      	ldr	r3, [r7, #12]
 800f490:	60da      	str	r2, [r3, #12]
}
 800f492:	bf00      	nop
 800f494:	3724      	adds	r7, #36	; 0x24
 800f496:	46bd      	mov	sp, r7
 800f498:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f49c:	4770      	bx	lr

0800f49e <LL_GPIO_SetAFPin_0_7>:
{
 800f49e:	b480      	push	{r7}
 800f4a0:	b089      	sub	sp, #36	; 0x24
 800f4a2:	af00      	add	r7, sp, #0
 800f4a4:	60f8      	str	r0, [r7, #12]
 800f4a6:	60b9      	str	r1, [r7, #8]
 800f4a8:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 800f4aa:	68fb      	ldr	r3, [r7, #12]
 800f4ac:	6a1a      	ldr	r2, [r3, #32]
 800f4ae:	68bb      	ldr	r3, [r7, #8]
 800f4b0:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f4b2:	697b      	ldr	r3, [r7, #20]
 800f4b4:	fa93 f3a3 	rbit	r3, r3
 800f4b8:	613b      	str	r3, [r7, #16]
  return result;
 800f4ba:	693b      	ldr	r3, [r7, #16]
 800f4bc:	fab3 f383 	clz	r3, r3
 800f4c0:	b2db      	uxtb	r3, r3
 800f4c2:	009b      	lsls	r3, r3, #2
 800f4c4:	210f      	movs	r1, #15
 800f4c6:	fa01 f303 	lsl.w	r3, r1, r3
 800f4ca:	43db      	mvns	r3, r3
 800f4cc:	401a      	ands	r2, r3
 800f4ce:	68bb      	ldr	r3, [r7, #8]
 800f4d0:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f4d2:	69fb      	ldr	r3, [r7, #28]
 800f4d4:	fa93 f3a3 	rbit	r3, r3
 800f4d8:	61bb      	str	r3, [r7, #24]
  return result;
 800f4da:	69bb      	ldr	r3, [r7, #24]
 800f4dc:	fab3 f383 	clz	r3, r3
 800f4e0:	b2db      	uxtb	r3, r3
 800f4e2:	009b      	lsls	r3, r3, #2
 800f4e4:	6879      	ldr	r1, [r7, #4]
 800f4e6:	fa01 f303 	lsl.w	r3, r1, r3
 800f4ea:	431a      	orrs	r2, r3
 800f4ec:	68fb      	ldr	r3, [r7, #12]
 800f4ee:	621a      	str	r2, [r3, #32]
}
 800f4f0:	bf00      	nop
 800f4f2:	3724      	adds	r7, #36	; 0x24
 800f4f4:	46bd      	mov	sp, r7
 800f4f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f4fa:	4770      	bx	lr

0800f4fc <LL_GPIO_SetAFPin_8_15>:
{
 800f4fc:	b480      	push	{r7}
 800f4fe:	b089      	sub	sp, #36	; 0x24
 800f500:	af00      	add	r7, sp, #0
 800f502:	60f8      	str	r0, [r7, #12]
 800f504:	60b9      	str	r1, [r7, #8]
 800f506:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 800f508:	68fb      	ldr	r3, [r7, #12]
 800f50a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f50c:	68bb      	ldr	r3, [r7, #8]
 800f50e:	0a1b      	lsrs	r3, r3, #8
 800f510:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f512:	697b      	ldr	r3, [r7, #20]
 800f514:	fa93 f3a3 	rbit	r3, r3
 800f518:	613b      	str	r3, [r7, #16]
  return result;
 800f51a:	693b      	ldr	r3, [r7, #16]
 800f51c:	fab3 f383 	clz	r3, r3
 800f520:	b2db      	uxtb	r3, r3
 800f522:	009b      	lsls	r3, r3, #2
 800f524:	210f      	movs	r1, #15
 800f526:	fa01 f303 	lsl.w	r3, r1, r3
 800f52a:	43db      	mvns	r3, r3
 800f52c:	401a      	ands	r2, r3
 800f52e:	68bb      	ldr	r3, [r7, #8]
 800f530:	0a1b      	lsrs	r3, r3, #8
 800f532:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f534:	69fb      	ldr	r3, [r7, #28]
 800f536:	fa93 f3a3 	rbit	r3, r3
 800f53a:	61bb      	str	r3, [r7, #24]
  return result;
 800f53c:	69bb      	ldr	r3, [r7, #24]
 800f53e:	fab3 f383 	clz	r3, r3
 800f542:	b2db      	uxtb	r3, r3
 800f544:	009b      	lsls	r3, r3, #2
 800f546:	6879      	ldr	r1, [r7, #4]
 800f548:	fa01 f303 	lsl.w	r3, r1, r3
 800f54c:	431a      	orrs	r2, r3
 800f54e:	68fb      	ldr	r3, [r7, #12]
 800f550:	625a      	str	r2, [r3, #36]	; 0x24
}
 800f552:	bf00      	nop
 800f554:	3724      	adds	r7, #36	; 0x24
 800f556:	46bd      	mov	sp, r7
 800f558:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f55c:	4770      	bx	lr

0800f55e <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 800f55e:	b580      	push	{r7, lr}
 800f560:	b088      	sub	sp, #32
 800f562:	af00      	add	r7, sp, #0
 800f564:	6078      	str	r0, [r7, #4]
 800f566:	6039      	str	r1, [r7, #0]
  uint32_t pinpos     = 0x00000000U;
 800f568:	2300      	movs	r3, #0
 800f56a:	61fb      	str	r3, [r7, #28]
  uint32_t currentpin = 0x00000000U;
 800f56c:	2300      	movs	r3, #0
 800f56e:	61bb      	str	r3, [r7, #24]
  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));

  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 800f570:	683b      	ldr	r3, [r7, #0]
 800f572:	681b      	ldr	r3, [r3, #0]
 800f574:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f576:	697b      	ldr	r3, [r7, #20]
 800f578:	fa93 f3a3 	rbit	r3, r3
 800f57c:	613b      	str	r3, [r7, #16]
  return result;
 800f57e:	693b      	ldr	r3, [r7, #16]
 800f580:	fab3 f383 	clz	r3, r3
 800f584:	b2db      	uxtb	r3, r3
 800f586:	61fb      	str	r3, [r7, #28]
  
  /* Configure the port pins */
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 800f588:	e050      	b.n	800f62c <LL_GPIO_Init+0xce>
  {
    /* Get current io position */
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);
 800f58a:	683b      	ldr	r3, [r7, #0]
 800f58c:	681a      	ldr	r2, [r3, #0]
 800f58e:	2101      	movs	r1, #1
 800f590:	69fb      	ldr	r3, [r7, #28]
 800f592:	fa01 f303 	lsl.w	r3, r1, r3
 800f596:	4013      	ands	r3, r2
 800f598:	61bb      	str	r3, [r7, #24]
    
    if (currentpin)
 800f59a:	69bb      	ldr	r3, [r7, #24]
 800f59c:	2b00      	cmp	r3, #0
 800f59e:	d042      	beq.n	800f626 <LL_GPIO_Init+0xc8>
    {
      
      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 800f5a0:	683b      	ldr	r3, [r7, #0]
 800f5a2:	685b      	ldr	r3, [r3, #4]
 800f5a4:	2b01      	cmp	r3, #1
 800f5a6:	d003      	beq.n	800f5b0 <LL_GPIO_Init+0x52>
 800f5a8:	683b      	ldr	r3, [r7, #0]
 800f5aa:	685b      	ldr	r3, [r3, #4]
 800f5ac:	2b02      	cmp	r3, #2
 800f5ae:	d10d      	bne.n	800f5cc <LL_GPIO_Init+0x6e>
      {
        /* Check Speed mode parameters */
        assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));
        
        /* Speed mode configuration */
        LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
 800f5b0:	683b      	ldr	r3, [r7, #0]
 800f5b2:	689b      	ldr	r3, [r3, #8]
 800f5b4:	461a      	mov	r2, r3
 800f5b6:	69b9      	ldr	r1, [r7, #24]
 800f5b8:	6878      	ldr	r0, [r7, #4]
 800f5ba:	f7ff ff12 	bl	800f3e2 <LL_GPIO_SetPinSpeed>
        
        /* Check Output mode parameters */
        assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));
        
        /* Output mode configuration*/
        LL_GPIO_SetPinOutputType(GPIOx, currentpin, GPIO_InitStruct->OutputType);
 800f5be:	683b      	ldr	r3, [r7, #0]
 800f5c0:	68db      	ldr	r3, [r3, #12]
 800f5c2:	461a      	mov	r2, r3
 800f5c4:	69b9      	ldr	r1, [r7, #24]
 800f5c6:	6878      	ldr	r0, [r7, #4]
 800f5c8:	f7ff fef3 	bl	800f3b2 <LL_GPIO_SetPinOutputType>
      }
      
      /* Pull-up Pull down resistor configuration*/
      LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
 800f5cc:	683b      	ldr	r3, [r7, #0]
 800f5ce:	691b      	ldr	r3, [r3, #16]
 800f5d0:	461a      	mov	r2, r3
 800f5d2:	69b9      	ldr	r1, [r7, #24]
 800f5d4:	6878      	ldr	r0, [r7, #4]
 800f5d6:	f7ff ff33 	bl	800f440 <LL_GPIO_SetPinPull>
      
      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 800f5da:	683b      	ldr	r3, [r7, #0]
 800f5dc:	685b      	ldr	r3, [r3, #4]
 800f5de:	2b02      	cmp	r3, #2
 800f5e0:	d11a      	bne.n	800f618 <LL_GPIO_Init+0xba>
 800f5e2:	69bb      	ldr	r3, [r7, #24]
 800f5e4:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800f5e6:	68fb      	ldr	r3, [r7, #12]
 800f5e8:	fa93 f3a3 	rbit	r3, r3
 800f5ec:	60bb      	str	r3, [r7, #8]
  return result;
 800f5ee:	68bb      	ldr	r3, [r7, #8]
      {
        /* Check Alternate parameter */
        assert_param(IS_LL_GPIO_ALTERNATE(GPIO_InitStruct->Alternate));
        
        /* Speed mode configuration */
        if (POSITION_VAL(currentpin) < 0x00000008U)
 800f5f0:	fab3 f383 	clz	r3, r3
 800f5f4:	b2db      	uxtb	r3, r3
 800f5f6:	2b07      	cmp	r3, #7
 800f5f8:	d807      	bhi.n	800f60a <LL_GPIO_Init+0xac>
        {
          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 800f5fa:	683b      	ldr	r3, [r7, #0]
 800f5fc:	695b      	ldr	r3, [r3, #20]
 800f5fe:	461a      	mov	r2, r3
 800f600:	69b9      	ldr	r1, [r7, #24]
 800f602:	6878      	ldr	r0, [r7, #4]
 800f604:	f7ff ff4b 	bl	800f49e <LL_GPIO_SetAFPin_0_7>
 800f608:	e006      	b.n	800f618 <LL_GPIO_Init+0xba>
        }
        else
        {
          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 800f60a:	683b      	ldr	r3, [r7, #0]
 800f60c:	695b      	ldr	r3, [r3, #20]
 800f60e:	461a      	mov	r2, r3
 800f610:	69b9      	ldr	r1, [r7, #24]
 800f612:	6878      	ldr	r0, [r7, #4]
 800f614:	f7ff ff72 	bl	800f4fc <LL_GPIO_SetAFPin_8_15>
        }
      }
      
      /* Pin Mode configuration */
      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
 800f618:	683b      	ldr	r3, [r7, #0]
 800f61a:	685b      	ldr	r3, [r3, #4]
 800f61c:	461a      	mov	r2, r3
 800f61e:	69b9      	ldr	r1, [r7, #24]
 800f620:	6878      	ldr	r0, [r7, #4]
 800f622:	f7ff fe97 	bl	800f354 <LL_GPIO_SetPinMode>
    }
    pinpos++;
 800f626:	69fb      	ldr	r3, [r7, #28]
 800f628:	3301      	adds	r3, #1
 800f62a:	61fb      	str	r3, [r7, #28]
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 800f62c:	683b      	ldr	r3, [r7, #0]
 800f62e:	681a      	ldr	r2, [r3, #0]
 800f630:	69fb      	ldr	r3, [r7, #28]
 800f632:	fa22 f303 	lsr.w	r3, r2, r3
 800f636:	2b00      	cmp	r3, #0
 800f638:	d1a7      	bne.n	800f58a <LL_GPIO_Init+0x2c>
  }

  return (SUCCESS);
 800f63a:	2300      	movs	r3, #0
}
 800f63c:	4618      	mov	r0, r3
 800f63e:	3720      	adds	r7, #32
 800f640:	46bd      	mov	sp, r7
 800f642:	bd80      	pop	{r7, pc}

0800f644 <LL_I2C_Enable>:
{
 800f644:	b480      	push	{r7}
 800f646:	b083      	sub	sp, #12
 800f648:	af00      	add	r7, sp, #0
 800f64a:	6078      	str	r0, [r7, #4]
  SET_BIT(I2Cx->CR1, I2C_CR1_PE);
 800f64c:	687b      	ldr	r3, [r7, #4]
 800f64e:	681b      	ldr	r3, [r3, #0]
 800f650:	f043 0201 	orr.w	r2, r3, #1
 800f654:	687b      	ldr	r3, [r7, #4]
 800f656:	601a      	str	r2, [r3, #0]
}
 800f658:	bf00      	nop
 800f65a:	370c      	adds	r7, #12
 800f65c:	46bd      	mov	sp, r7
 800f65e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f662:	4770      	bx	lr

0800f664 <LL_I2C_Disable>:
{
 800f664:	b480      	push	{r7}
 800f666:	b083      	sub	sp, #12
 800f668:	af00      	add	r7, sp, #0
 800f66a:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(I2Cx->CR1, I2C_CR1_PE);
 800f66c:	687b      	ldr	r3, [r7, #4]
 800f66e:	681b      	ldr	r3, [r3, #0]
 800f670:	f023 0201 	bic.w	r2, r3, #1
 800f674:	687b      	ldr	r3, [r7, #4]
 800f676:	601a      	str	r2, [r3, #0]
}
 800f678:	bf00      	nop
 800f67a:	370c      	adds	r7, #12
 800f67c:	46bd      	mov	sp, r7
 800f67e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f682:	4770      	bx	lr

0800f684 <LL_I2C_SetOwnAddress1>:
{
 800f684:	b480      	push	{r7}
 800f686:	b085      	sub	sp, #20
 800f688:	af00      	add	r7, sp, #0
 800f68a:	60f8      	str	r0, [r7, #12]
 800f68c:	60b9      	str	r1, [r7, #8]
 800f68e:	607a      	str	r2, [r7, #4]
  MODIFY_REG(I2Cx->OAR1, I2C_OAR1_ADD0 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD8_9 | I2C_OAR1_ADDMODE, OwnAddress1 | OwnAddrSize);
 800f690:	68fb      	ldr	r3, [r7, #12]
 800f692:	689b      	ldr	r3, [r3, #8]
 800f694:	f423 4303 	bic.w	r3, r3, #33536	; 0x8300
 800f698:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800f69c:	68b9      	ldr	r1, [r7, #8]
 800f69e:	687a      	ldr	r2, [r7, #4]
 800f6a0:	430a      	orrs	r2, r1
 800f6a2:	431a      	orrs	r2, r3
 800f6a4:	68fb      	ldr	r3, [r7, #12]
 800f6a6:	609a      	str	r2, [r3, #8]
}
 800f6a8:	bf00      	nop
 800f6aa:	3714      	adds	r7, #20
 800f6ac:	46bd      	mov	sp, r7
 800f6ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6b2:	4770      	bx	lr

0800f6b4 <LL_I2C_ConfigSpeed>:
  *         @arg @ref LL_I2C_DUTYCYCLE_16_9
  * @retval None
  */
__STATIC_INLINE void LL_I2C_ConfigSpeed(I2C_TypeDef *I2Cx, uint32_t PeriphClock, uint32_t ClockSpeed,
                                        uint32_t DutyCycle)
{
 800f6b4:	b480      	push	{r7}
 800f6b6:	b087      	sub	sp, #28
 800f6b8:	af00      	add	r7, sp, #0
 800f6ba:	60f8      	str	r0, [r7, #12]
 800f6bc:	60b9      	str	r1, [r7, #8]
 800f6be:	607a      	str	r2, [r7, #4]
 800f6c0:	603b      	str	r3, [r7, #0]
  uint32_t freqrange = 0x0U;
 800f6c2:	2300      	movs	r3, #0
 800f6c4:	613b      	str	r3, [r7, #16]
  uint32_t clockconfig = 0x0U;
 800f6c6:	2300      	movs	r3, #0
 800f6c8:	617b      	str	r3, [r7, #20]

  /* Compute frequency range */
  freqrange = __LL_I2C_FREQ_HZ_TO_MHZ(PeriphClock);
 800f6ca:	68bb      	ldr	r3, [r7, #8]
 800f6cc:	4a42      	ldr	r2, [pc, #264]	; (800f7d8 <LL_I2C_ConfigSpeed+0x124>)
 800f6ce:	fba2 2303 	umull	r2, r3, r2, r3
 800f6d2:	0c9b      	lsrs	r3, r3, #18
 800f6d4:	613b      	str	r3, [r7, #16]

  /* Configure I2Cx: Frequency range register */
  MODIFY_REG(I2Cx->CR2, I2C_CR2_FREQ, freqrange);
 800f6d6:	68fb      	ldr	r3, [r7, #12]
 800f6d8:	685b      	ldr	r3, [r3, #4]
 800f6da:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
 800f6de:	693b      	ldr	r3, [r7, #16]
 800f6e0:	431a      	orrs	r2, r3
 800f6e2:	68fb      	ldr	r3, [r7, #12]
 800f6e4:	605a      	str	r2, [r3, #4]

  /* Configure I2Cx: Rise Time register */
  MODIFY_REG(I2Cx->TRISE, I2C_TRISE_TRISE, __LL_I2C_RISE_TIME(freqrange, ClockSpeed));
 800f6e6:	68fb      	ldr	r3, [r7, #12]
 800f6e8:	6a1b      	ldr	r3, [r3, #32]
 800f6ea:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
 800f6ee:	687b      	ldr	r3, [r7, #4]
 800f6f0:	493a      	ldr	r1, [pc, #232]	; (800f7dc <LL_I2C_ConfigSpeed+0x128>)
 800f6f2:	428b      	cmp	r3, r1
 800f6f4:	d802      	bhi.n	800f6fc <LL_I2C_ConfigSpeed+0x48>
 800f6f6:	693b      	ldr	r3, [r7, #16]
 800f6f8:	3301      	adds	r3, #1
 800f6fa:	e009      	b.n	800f710 <LL_I2C_ConfigSpeed+0x5c>
 800f6fc:	693b      	ldr	r3, [r7, #16]
 800f6fe:	f44f 7196 	mov.w	r1, #300	; 0x12c
 800f702:	fb01 f303 	mul.w	r3, r1, r3
 800f706:	4936      	ldr	r1, [pc, #216]	; (800f7e0 <LL_I2C_ConfigSpeed+0x12c>)
 800f708:	fba1 1303 	umull	r1, r3, r1, r3
 800f70c:	099b      	lsrs	r3, r3, #6
 800f70e:	3301      	adds	r3, #1
 800f710:	431a      	orrs	r2, r3
 800f712:	68fb      	ldr	r3, [r7, #12]
 800f714:	621a      	str	r2, [r3, #32]

  /* Configure Speed mode, Duty Cycle and Clock control register value */
  if (ClockSpeed > LL_I2C_MAX_SPEED_STANDARD)
 800f716:	687b      	ldr	r3, [r7, #4]
 800f718:	4a30      	ldr	r2, [pc, #192]	; (800f7dc <LL_I2C_ConfigSpeed+0x128>)
 800f71a:	4293      	cmp	r3, r2
 800f71c:	d939      	bls.n	800f792 <LL_I2C_ConfigSpeed+0xde>
  {
    /* Set Speed mode at fast and duty cycle for Clock Speed request in fast clock range */
    clockconfig = LL_I2C_CLOCK_SPEED_FAST_MODE                                          | \
 800f71e:	683b      	ldr	r3, [r7, #0]
 800f720:	2b00      	cmp	r3, #0
 800f722:	d117      	bne.n	800f754 <LL_I2C_ConfigSpeed+0xa0>
                  __LL_I2C_SPEED_FAST_TO_CCR(PeriphClock, ClockSpeed, DutyCycle)        | \
 800f724:	687a      	ldr	r2, [r7, #4]
 800f726:	4613      	mov	r3, r2
 800f728:	005b      	lsls	r3, r3, #1
 800f72a:	4413      	add	r3, r2
 800f72c:	68ba      	ldr	r2, [r7, #8]
 800f72e:	fbb2 f3f3 	udiv	r3, r2, r3
 800f732:	f3c3 030b 	ubfx	r3, r3, #0, #12
    clockconfig = LL_I2C_CLOCK_SPEED_FAST_MODE                                          | \
 800f736:	2b00      	cmp	r3, #0
 800f738:	d009      	beq.n	800f74e <LL_I2C_ConfigSpeed+0x9a>
                  __LL_I2C_SPEED_FAST_TO_CCR(PeriphClock, ClockSpeed, DutyCycle)        | \
 800f73a:	687a      	ldr	r2, [r7, #4]
 800f73c:	4613      	mov	r3, r2
 800f73e:	005b      	lsls	r3, r3, #1
 800f740:	4413      	add	r3, r2
 800f742:	68ba      	ldr	r2, [r7, #8]
 800f744:	fbb2 f3f3 	udiv	r3, r2, r3
    clockconfig = LL_I2C_CLOCK_SPEED_FAST_MODE                                          | \
 800f748:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f74c:	e01d      	b.n	800f78a <LL_I2C_ConfigSpeed+0xd6>
 800f74e:	f248 0301 	movw	r3, #32769	; 0x8001
 800f752:	e01a      	b.n	800f78a <LL_I2C_ConfigSpeed+0xd6>
                  __LL_I2C_SPEED_FAST_TO_CCR(PeriphClock, ClockSpeed, DutyCycle)        | \
 800f754:	687a      	ldr	r2, [r7, #4]
 800f756:	4613      	mov	r3, r2
 800f758:	009b      	lsls	r3, r3, #2
 800f75a:	4413      	add	r3, r2
 800f75c:	009a      	lsls	r2, r3, #2
 800f75e:	4413      	add	r3, r2
 800f760:	68ba      	ldr	r2, [r7, #8]
 800f762:	fbb2 f3f3 	udiv	r3, r2, r3
 800f766:	f3c3 030b 	ubfx	r3, r3, #0, #12
    clockconfig = LL_I2C_CLOCK_SPEED_FAST_MODE                                          | \
 800f76a:	2b00      	cmp	r3, #0
 800f76c:	d00b      	beq.n	800f786 <LL_I2C_ConfigSpeed+0xd2>
                  __LL_I2C_SPEED_FAST_TO_CCR(PeriphClock, ClockSpeed, DutyCycle)        | \
 800f76e:	687a      	ldr	r2, [r7, #4]
 800f770:	4613      	mov	r3, r2
 800f772:	009b      	lsls	r3, r3, #2
 800f774:	4413      	add	r3, r2
 800f776:	009a      	lsls	r2, r3, #2
 800f778:	4413      	add	r3, r2
 800f77a:	68ba      	ldr	r2, [r7, #8]
 800f77c:	fbb2 f3f3 	udiv	r3, r2, r3
    clockconfig = LL_I2C_CLOCK_SPEED_FAST_MODE                                          | \
 800f780:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f784:	e001      	b.n	800f78a <LL_I2C_ConfigSpeed+0xd6>
 800f786:	f248 0301 	movw	r3, #32769	; 0x8001
 800f78a:	683a      	ldr	r2, [r7, #0]
 800f78c:	4313      	orrs	r3, r2
 800f78e:	617b      	str	r3, [r7, #20]
 800f790:	e011      	b.n	800f7b6 <LL_I2C_ConfigSpeed+0x102>
  }
  else
  {
    /* Set Speed mode at standard for Clock Speed request in standard clock range */
    clockconfig = LL_I2C_CLOCK_SPEED_STANDARD_MODE                                      | \
                  __LL_I2C_SPEED_STANDARD_TO_CCR(PeriphClock, ClockSpeed);
 800f792:	687b      	ldr	r3, [r7, #4]
 800f794:	005b      	lsls	r3, r3, #1
 800f796:	68ba      	ldr	r2, [r7, #8]
 800f798:	fbb2 f2f3 	udiv	r2, r2, r3
 800f79c:	f640 73fc 	movw	r3, #4092	; 0xffc
 800f7a0:	4013      	ands	r3, r2
    clockconfig = LL_I2C_CLOCK_SPEED_STANDARD_MODE                                      | \
 800f7a2:	2b00      	cmp	r3, #0
 800f7a4:	d005      	beq.n	800f7b2 <LL_I2C_ConfigSpeed+0xfe>
                  __LL_I2C_SPEED_STANDARD_TO_CCR(PeriphClock, ClockSpeed);
 800f7a6:	687b      	ldr	r3, [r7, #4]
 800f7a8:	005b      	lsls	r3, r3, #1
    clockconfig = LL_I2C_CLOCK_SPEED_STANDARD_MODE                                      | \
 800f7aa:	68ba      	ldr	r2, [r7, #8]
 800f7ac:	fbb2 f3f3 	udiv	r3, r2, r3
 800f7b0:	e000      	b.n	800f7b4 <LL_I2C_ConfigSpeed+0x100>
 800f7b2:	2304      	movs	r3, #4
 800f7b4:	617b      	str	r3, [r7, #20]
  }

  /* Configure I2Cx: Clock control register */
  MODIFY_REG(I2Cx->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), clockconfig);
 800f7b6:	68fb      	ldr	r3, [r7, #12]
 800f7b8:	69db      	ldr	r3, [r3, #28]
 800f7ba:	f423 434f 	bic.w	r3, r3, #52992	; 0xcf00
 800f7be:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800f7c2:	697a      	ldr	r2, [r7, #20]
 800f7c4:	431a      	orrs	r2, r3
 800f7c6:	68fb      	ldr	r3, [r7, #12]
 800f7c8:	61da      	str	r2, [r3, #28]
}
 800f7ca:	bf00      	nop
 800f7cc:	371c      	adds	r7, #28
 800f7ce:	46bd      	mov	sp, r7
 800f7d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f7d4:	4770      	bx	lr
 800f7d6:	bf00      	nop
 800f7d8:	431bde83 	.word	0x431bde83
 800f7dc:	000186a0 	.word	0x000186a0
 800f7e0:	10624dd3 	.word	0x10624dd3

0800f7e4 <LL_I2C_SetMode>:
  *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE
  *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE_ARP
  * @retval None
  */
__STATIC_INLINE void LL_I2C_SetMode(I2C_TypeDef *I2Cx, uint32_t PeripheralMode)
{
 800f7e4:	b480      	push	{r7}
 800f7e6:	b083      	sub	sp, #12
 800f7e8:	af00      	add	r7, sp, #0
 800f7ea:	6078      	str	r0, [r7, #4]
 800f7ec:	6039      	str	r1, [r7, #0]
  MODIFY_REG(I2Cx->CR1, I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_ENARP, PeripheralMode);
 800f7ee:	687b      	ldr	r3, [r7, #4]
 800f7f0:	681b      	ldr	r3, [r3, #0]
 800f7f2:	f023 021a 	bic.w	r2, r3, #26
 800f7f6:	683b      	ldr	r3, [r7, #0]
 800f7f8:	431a      	orrs	r2, r3
 800f7fa:	687b      	ldr	r3, [r7, #4]
 800f7fc:	601a      	str	r2, [r3, #0]
}
 800f7fe:	bf00      	nop
 800f800:	370c      	adds	r7, #12
 800f802:	46bd      	mov	sp, r7
 800f804:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f808:	4770      	bx	lr

0800f80a <LL_I2C_AcknowledgeNextData>:
  *         @arg @ref LL_I2C_ACK
  *         @arg @ref LL_I2C_NACK
  * @retval None
  */
__STATIC_INLINE void LL_I2C_AcknowledgeNextData(I2C_TypeDef *I2Cx, uint32_t TypeAcknowledge)
{
 800f80a:	b480      	push	{r7}
 800f80c:	b083      	sub	sp, #12
 800f80e:	af00      	add	r7, sp, #0
 800f810:	6078      	str	r0, [r7, #4]
 800f812:	6039      	str	r1, [r7, #0]
  MODIFY_REG(I2Cx->CR1, I2C_CR1_ACK, TypeAcknowledge);
 800f814:	687b      	ldr	r3, [r7, #4]
 800f816:	681b      	ldr	r3, [r3, #0]
 800f818:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 800f81c:	683b      	ldr	r3, [r7, #0]
 800f81e:	431a      	orrs	r2, r3
 800f820:	687b      	ldr	r3, [r7, #4]
 800f822:	601a      	str	r2, [r3, #0]
}
 800f824:	bf00      	nop
 800f826:	370c      	adds	r7, #12
 800f828:	46bd      	mov	sp, r7
 800f82a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f82e:	4770      	bx	lr

0800f830 <LL_I2C_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS  I2C registers are initialized
  *          - ERROR  Not applicable
  */
uint32_t LL_I2C_Init(I2C_TypeDef *I2Cx, LL_I2C_InitTypeDef *I2C_InitStruct)
{
 800f830:	b580      	push	{r7, lr}
 800f832:	b086      	sub	sp, #24
 800f834:	af00      	add	r7, sp, #0
 800f836:	6078      	str	r0, [r7, #4]
 800f838:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_I2C_OWN_ADDRESS1(I2C_InitStruct->OwnAddress1));
  assert_param(IS_LL_I2C_TYPE_ACKNOWLEDGE(I2C_InitStruct->TypeAcknowledge));
  assert_param(IS_LL_I2C_OWN_ADDRSIZE(I2C_InitStruct->OwnAddrSize));

  /* Disable the selected I2Cx Peripheral */
  LL_I2C_Disable(I2Cx);
 800f83a:	6878      	ldr	r0, [r7, #4]
 800f83c:	f7ff ff12 	bl	800f664 <LL_I2C_Disable>

  /* Retrieve Clock frequencies */
  LL_RCC_GetSystemClocksFreq(&rcc_clocks);
 800f840:	f107 0308 	add.w	r3, r7, #8
 800f844:	4618      	mov	r0, r3
 800f846:	f000 f895 	bl	800f974 <LL_RCC_GetSystemClocksFreq>
   * Configure the SCL speed :
   * - ClockSpeed: I2C_CR2_FREQ[5:0], I2C_TRISE_TRISE[5:0], I2C_CCR_FS,
   *           and I2C_CCR_CCR[11:0] bits
   * - DutyCycle: I2C_CCR_DUTY[7:0] bits
   */
  LL_I2C_ConfigSpeed(I2Cx, rcc_clocks.PCLK1_Frequency, I2C_InitStruct->ClockSpeed, I2C_InitStruct->DutyCycle);
 800f84a:	6939      	ldr	r1, [r7, #16]
 800f84c:	683b      	ldr	r3, [r7, #0]
 800f84e:	685a      	ldr	r2, [r3, #4]
 800f850:	683b      	ldr	r3, [r7, #0]
 800f852:	689b      	ldr	r3, [r3, #8]
 800f854:	6878      	ldr	r0, [r7, #4]
 800f856:	f7ff ff2d 	bl	800f6b4 <LL_I2C_ConfigSpeed>
  /*---------------------------- I2Cx OAR1 Configuration -----------------------
   * Disable, Configure and Enable I2Cx device own address 1 with parameters :
   * - OwnAddress1:  I2C_OAR1_ADD[9:8], I2C_OAR1_ADD[7:1] and I2C_OAR1_ADD0 bits
   * - OwnAddrSize:  I2C_OAR1_ADDMODE bit
   */
  LL_I2C_SetOwnAddress1(I2Cx, I2C_InitStruct->OwnAddress1, I2C_InitStruct->OwnAddrSize);
 800f85a:	683b      	ldr	r3, [r7, #0]
 800f85c:	68d9      	ldr	r1, [r3, #12]
 800f85e:	683b      	ldr	r3, [r7, #0]
 800f860:	695b      	ldr	r3, [r3, #20]
 800f862:	461a      	mov	r2, r3
 800f864:	6878      	ldr	r0, [r7, #4]
 800f866:	f7ff ff0d 	bl	800f684 <LL_I2C_SetOwnAddress1>

  /*---------------------------- I2Cx MODE Configuration -----------------------
  * Configure I2Cx peripheral mode with parameter :
   * - PeripheralMode: I2C_CR1_SMBUS, I2C_CR1_SMBTYPE and I2C_CR1_ENARP bits
   */
  LL_I2C_SetMode(I2Cx, I2C_InitStruct->PeripheralMode);
 800f86a:	683b      	ldr	r3, [r7, #0]
 800f86c:	681b      	ldr	r3, [r3, #0]
 800f86e:	4619      	mov	r1, r3
 800f870:	6878      	ldr	r0, [r7, #4]
 800f872:	f7ff ffb7 	bl	800f7e4 <LL_I2C_SetMode>

  /* Enable the selected I2Cx Peripheral */
  LL_I2C_Enable(I2Cx);
 800f876:	6878      	ldr	r0, [r7, #4]
 800f878:	f7ff fee4 	bl	800f644 <LL_I2C_Enable>
  /*---------------------------- I2Cx CR2 Configuration ------------------------
   * Configure the ACKnowledge or Non ACKnowledge condition
   * after the address receive match code or next received byte with parameter :
   * - TypeAcknowledge: I2C_CR2_NACK bit
   */
  LL_I2C_AcknowledgeNextData(I2Cx, I2C_InitStruct->TypeAcknowledge);
 800f87c:	683b      	ldr	r3, [r7, #0]
 800f87e:	691b      	ldr	r3, [r3, #16]
 800f880:	4619      	mov	r1, r3
 800f882:	6878      	ldr	r0, [r7, #4]
 800f884:	f7ff ffc1 	bl	800f80a <LL_I2C_AcknowledgeNextData>

  return SUCCESS;
 800f888:	2300      	movs	r3, #0
}
 800f88a:	4618      	mov	r0, r3
 800f88c:	3718      	adds	r7, #24
 800f88e:	46bd      	mov	sp, r7
 800f890:	bd80      	pop	{r7, pc}
	...

0800f894 <LL_RCC_GetSysClkSource>:
{
 800f894:	b480      	push	{r7}
 800f896:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800f898:	4b04      	ldr	r3, [pc, #16]	; (800f8ac <LL_RCC_GetSysClkSource+0x18>)
 800f89a:	689b      	ldr	r3, [r3, #8]
 800f89c:	f003 030c 	and.w	r3, r3, #12
}
 800f8a0:	4618      	mov	r0, r3
 800f8a2:	46bd      	mov	sp, r7
 800f8a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f8a8:	4770      	bx	lr
 800f8aa:	bf00      	nop
 800f8ac:	40023800 	.word	0x40023800

0800f8b0 <LL_RCC_GetAHBPrescaler>:
{
 800f8b0:	b480      	push	{r7}
 800f8b2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 800f8b4:	4b04      	ldr	r3, [pc, #16]	; (800f8c8 <LL_RCC_GetAHBPrescaler+0x18>)
 800f8b6:	689b      	ldr	r3, [r3, #8]
 800f8b8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 800f8bc:	4618      	mov	r0, r3
 800f8be:	46bd      	mov	sp, r7
 800f8c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f8c4:	4770      	bx	lr
 800f8c6:	bf00      	nop
 800f8c8:	40023800 	.word	0x40023800

0800f8cc <LL_RCC_GetAPB1Prescaler>:
{
 800f8cc:	b480      	push	{r7}
 800f8ce:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 800f8d0:	4b04      	ldr	r3, [pc, #16]	; (800f8e4 <LL_RCC_GetAPB1Prescaler+0x18>)
 800f8d2:	689b      	ldr	r3, [r3, #8]
 800f8d4:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
}
 800f8d8:	4618      	mov	r0, r3
 800f8da:	46bd      	mov	sp, r7
 800f8dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f8e0:	4770      	bx	lr
 800f8e2:	bf00      	nop
 800f8e4:	40023800 	.word	0x40023800

0800f8e8 <LL_RCC_GetAPB2Prescaler>:
{
 800f8e8:	b480      	push	{r7}
 800f8ea:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 800f8ec:	4b04      	ldr	r3, [pc, #16]	; (800f900 <LL_RCC_GetAPB2Prescaler+0x18>)
 800f8ee:	689b      	ldr	r3, [r3, #8]
 800f8f0:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
}
 800f8f4:	4618      	mov	r0, r3
 800f8f6:	46bd      	mov	sp, r7
 800f8f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f8fc:	4770      	bx	lr
 800f8fe:	bf00      	nop
 800f900:	40023800 	.word	0x40023800

0800f904 <LL_RCC_PLL_GetMainSource>:
{
 800f904:	b480      	push	{r7}
 800f906:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800f908:	4b04      	ldr	r3, [pc, #16]	; (800f91c <LL_RCC_PLL_GetMainSource+0x18>)
 800f90a:	685b      	ldr	r3, [r3, #4]
 800f90c:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
}
 800f910:	4618      	mov	r0, r3
 800f912:	46bd      	mov	sp, r7
 800f914:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f918:	4770      	bx	lr
 800f91a:	bf00      	nop
 800f91c:	40023800 	.word	0x40023800

0800f920 <LL_RCC_PLL_GetN>:
{
 800f920:	b480      	push	{r7}
 800f922:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 800f924:	4b04      	ldr	r3, [pc, #16]	; (800f938 <LL_RCC_PLL_GetN+0x18>)
 800f926:	685b      	ldr	r3, [r3, #4]
 800f928:	099b      	lsrs	r3, r3, #6
 800f92a:	f3c3 0308 	ubfx	r3, r3, #0, #9
}
 800f92e:	4618      	mov	r0, r3
 800f930:	46bd      	mov	sp, r7
 800f932:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f936:	4770      	bx	lr
 800f938:	40023800 	.word	0x40023800

0800f93c <LL_RCC_PLL_GetP>:
{
 800f93c:	b480      	push	{r7}
 800f93e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP));
 800f940:	4b04      	ldr	r3, [pc, #16]	; (800f954 <LL_RCC_PLL_GetP+0x18>)
 800f942:	685b      	ldr	r3, [r3, #4]
 800f944:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
}
 800f948:	4618      	mov	r0, r3
 800f94a:	46bd      	mov	sp, r7
 800f94c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f950:	4770      	bx	lr
 800f952:	bf00      	nop
 800f954:	40023800 	.word	0x40023800

0800f958 <LL_RCC_PLL_GetDivider>:
{
 800f958:	b480      	push	{r7}
 800f95a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 800f95c:	4b04      	ldr	r3, [pc, #16]	; (800f970 <LL_RCC_PLL_GetDivider+0x18>)
 800f95e:	685b      	ldr	r3, [r3, #4]
 800f960:	f003 033f 	and.w	r3, r3, #63	; 0x3f
}
 800f964:	4618      	mov	r0, r3
 800f966:	46bd      	mov	sp, r7
 800f968:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f96c:	4770      	bx	lr
 800f96e:	bf00      	nop
 800f970:	40023800 	.word	0x40023800

0800f974 <LL_RCC_GetSystemClocksFreq>:
  *         configuration based on this function will be incorrect.
  * @param  RCC_Clocks pointer to a @ref LL_RCC_ClocksTypeDef structure which will hold the clocks frequencies
  * @retval None
  */
void LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks)
{
 800f974:	b580      	push	{r7, lr}
 800f976:	b082      	sub	sp, #8
 800f978:	af00      	add	r7, sp, #0
 800f97a:	6078      	str	r0, [r7, #4]
  /* Get SYSCLK frequency */
  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
 800f97c:	f000 f820 	bl	800f9c0 <RCC_GetSystemClockFreq>
 800f980:	4602      	mov	r2, r0
 800f982:	687b      	ldr	r3, [r7, #4]
 800f984:	601a      	str	r2, [r3, #0]

  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
 800f986:	687b      	ldr	r3, [r7, #4]
 800f988:	681b      	ldr	r3, [r3, #0]
 800f98a:	4618      	mov	r0, r3
 800f98c:	f000 f840 	bl	800fa10 <RCC_GetHCLKClockFreq>
 800f990:	4602      	mov	r2, r0
 800f992:	687b      	ldr	r3, [r7, #4]
 800f994:	605a      	str	r2, [r3, #4]

  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
 800f996:	687b      	ldr	r3, [r7, #4]
 800f998:	685b      	ldr	r3, [r3, #4]
 800f99a:	4618      	mov	r0, r3
 800f99c:	f000 f84e 	bl	800fa3c <RCC_GetPCLK1ClockFreq>
 800f9a0:	4602      	mov	r2, r0
 800f9a2:	687b      	ldr	r3, [r7, #4]
 800f9a4:	609a      	str	r2, [r3, #8]

  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
 800f9a6:	687b      	ldr	r3, [r7, #4]
 800f9a8:	685b      	ldr	r3, [r3, #4]
 800f9aa:	4618      	mov	r0, r3
 800f9ac:	f000 f85a 	bl	800fa64 <RCC_GetPCLK2ClockFreq>
 800f9b0:	4602      	mov	r2, r0
 800f9b2:	687b      	ldr	r3, [r7, #4]
 800f9b4:	60da      	str	r2, [r3, #12]
}
 800f9b6:	bf00      	nop
 800f9b8:	3708      	adds	r7, #8
 800f9ba:	46bd      	mov	sp, r7
 800f9bc:	bd80      	pop	{r7, pc}
	...

0800f9c0 <RCC_GetSystemClockFreq>:
/**
  * @brief  Return SYSTEM clock frequency
  * @retval SYSTEM clock frequency (in Hz)
  */
uint32_t RCC_GetSystemClockFreq(void)
{
 800f9c0:	b580      	push	{r7, lr}
 800f9c2:	b082      	sub	sp, #8
 800f9c4:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
 800f9c6:	2300      	movs	r3, #0
 800f9c8:	607b      	str	r3, [r7, #4]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
 800f9ca:	f7ff ff63 	bl	800f894 <LL_RCC_GetSysClkSource>
 800f9ce:	4603      	mov	r3, r0
 800f9d0:	2b08      	cmp	r3, #8
 800f9d2:	d00c      	beq.n	800f9ee <RCC_GetSystemClockFreq+0x2e>
 800f9d4:	2b08      	cmp	r3, #8
 800f9d6:	d80f      	bhi.n	800f9f8 <RCC_GetSystemClockFreq+0x38>
 800f9d8:	2b00      	cmp	r3, #0
 800f9da:	d002      	beq.n	800f9e2 <RCC_GetSystemClockFreq+0x22>
 800f9dc:	2b04      	cmp	r3, #4
 800f9de:	d003      	beq.n	800f9e8 <RCC_GetSystemClockFreq+0x28>
 800f9e0:	e00a      	b.n	800f9f8 <RCC_GetSystemClockFreq+0x38>
  {
    case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */
      frequency = HSI_VALUE;
 800f9e2:	4b09      	ldr	r3, [pc, #36]	; (800fa08 <RCC_GetSystemClockFreq+0x48>)
 800f9e4:	607b      	str	r3, [r7, #4]
      break;
 800f9e6:	e00a      	b.n	800f9fe <RCC_GetSystemClockFreq+0x3e>

    case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
      frequency = HSE_VALUE;
 800f9e8:	4b08      	ldr	r3, [pc, #32]	; (800fa0c <RCC_GetSystemClockFreq+0x4c>)
 800f9ea:	607b      	str	r3, [r7, #4]
      break;
 800f9ec:	e007      	b.n	800f9fe <RCC_GetSystemClockFreq+0x3e>

    case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
      frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLL);
 800f9ee:	2008      	movs	r0, #8
 800f9f0:	f000 f84c 	bl	800fa8c <RCC_PLL_GetFreqDomain_SYS>
 800f9f4:	6078      	str	r0, [r7, #4]
      break;
 800f9f6:	e002      	b.n	800f9fe <RCC_GetSystemClockFreq+0x3e>
      frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLLR);
      break;
#endif /* RCC_PLLR_SYSCLK_SUPPORT */

    default:
      frequency = HSI_VALUE;
 800f9f8:	4b03      	ldr	r3, [pc, #12]	; (800fa08 <RCC_GetSystemClockFreq+0x48>)
 800f9fa:	607b      	str	r3, [r7, #4]
      break;
 800f9fc:	bf00      	nop
  }

  return frequency;
 800f9fe:	687b      	ldr	r3, [r7, #4]
}
 800fa00:	4618      	mov	r0, r3
 800fa02:	3708      	adds	r7, #8
 800fa04:	46bd      	mov	sp, r7
 800fa06:	bd80      	pop	{r7, pc}
 800fa08:	00f42400 	.word	0x00f42400
 800fa0c:	007a1200 	.word	0x007a1200

0800fa10 <RCC_GetHCLKClockFreq>:
  * @brief  Return HCLK clock frequency
  * @param  SYSCLK_Frequency SYSCLK clock frequency
  * @retval HCLK clock frequency (in Hz)
  */
uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
{
 800fa10:	b580      	push	{r7, lr}
 800fa12:	b082      	sub	sp, #8
 800fa14:	af00      	add	r7, sp, #0
 800fa16:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 800fa18:	f7ff ff4a 	bl	800f8b0 <LL_RCC_GetAHBPrescaler>
 800fa1c:	4603      	mov	r3, r0
 800fa1e:	091b      	lsrs	r3, r3, #4
 800fa20:	f003 030f 	and.w	r3, r3, #15
 800fa24:	4a04      	ldr	r2, [pc, #16]	; (800fa38 <RCC_GetHCLKClockFreq+0x28>)
 800fa26:	5cd3      	ldrb	r3, [r2, r3]
 800fa28:	461a      	mov	r2, r3
 800fa2a:	687b      	ldr	r3, [r7, #4]
 800fa2c:	40d3      	lsrs	r3, r2
}
 800fa2e:	4618      	mov	r0, r3
 800fa30:	3708      	adds	r7, #8
 800fa32:	46bd      	mov	sp, r7
 800fa34:	bd80      	pop	{r7, pc}
 800fa36:	bf00      	nop
 800fa38:	08010250 	.word	0x08010250

0800fa3c <RCC_GetPCLK1ClockFreq>:
  * @brief  Return PCLK1 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK1 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
 800fa3c:	b580      	push	{r7, lr}
 800fa3e:	b082      	sub	sp, #8
 800fa40:	af00      	add	r7, sp, #0
 800fa42:	6078      	str	r0, [r7, #4]
  /* PCLK1 clock frequency */
  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 800fa44:	f7ff ff42 	bl	800f8cc <LL_RCC_GetAPB1Prescaler>
 800fa48:	4603      	mov	r3, r0
 800fa4a:	0a9b      	lsrs	r3, r3, #10
 800fa4c:	4a04      	ldr	r2, [pc, #16]	; (800fa60 <RCC_GetPCLK1ClockFreq+0x24>)
 800fa4e:	5cd3      	ldrb	r3, [r2, r3]
 800fa50:	461a      	mov	r2, r3
 800fa52:	687b      	ldr	r3, [r7, #4]
 800fa54:	40d3      	lsrs	r3, r2
}
 800fa56:	4618      	mov	r0, r3
 800fa58:	3708      	adds	r7, #8
 800fa5a:	46bd      	mov	sp, r7
 800fa5c:	bd80      	pop	{r7, pc}
 800fa5e:	bf00      	nop
 800fa60:	08010260 	.word	0x08010260

0800fa64 <RCC_GetPCLK2ClockFreq>:
  * @brief  Return PCLK2 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK2 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
{
 800fa64:	b580      	push	{r7, lr}
 800fa66:	b082      	sub	sp, #8
 800fa68:	af00      	add	r7, sp, #0
 800fa6a:	6078      	str	r0, [r7, #4]
  /* PCLK2 clock frequency */
  return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
 800fa6c:	f7ff ff3c 	bl	800f8e8 <LL_RCC_GetAPB2Prescaler>
 800fa70:	4603      	mov	r3, r0
 800fa72:	0b5b      	lsrs	r3, r3, #13
 800fa74:	4a04      	ldr	r2, [pc, #16]	; (800fa88 <RCC_GetPCLK2ClockFreq+0x24>)
 800fa76:	5cd3      	ldrb	r3, [r2, r3]
 800fa78:	461a      	mov	r2, r3
 800fa7a:	687b      	ldr	r3, [r7, #4]
 800fa7c:	40d3      	lsrs	r3, r2
}
 800fa7e:	4618      	mov	r0, r3
 800fa80:	3708      	adds	r7, #8
 800fa82:	46bd      	mov	sp, r7
 800fa84:	bd80      	pop	{r7, pc}
 800fa86:	bf00      	nop
 800fa88:	08010260 	.word	0x08010260

0800fa8c <RCC_PLL_GetFreqDomain_SYS>:
  * @brief  Return PLL clock frequency used for system domain
  * @param  SYSCLK_Source System clock source
  * @retval PLL clock frequency (in Hz)
  */
uint32_t RCC_PLL_GetFreqDomain_SYS(uint32_t SYSCLK_Source)
{
 800fa8c:	b590      	push	{r4, r7, lr}
 800fa8e:	b087      	sub	sp, #28
 800fa90:	af00      	add	r7, sp, #0
 800fa92:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = 0U, pllsource = 0U, plloutputfreq = 0U;
 800fa94:	2300      	movs	r3, #0
 800fa96:	617b      	str	r3, [r7, #20]
 800fa98:	2300      	movs	r3, #0
 800fa9a:	60fb      	str	r3, [r7, #12]
 800fa9c:	2300      	movs	r3, #0
 800fa9e:	613b      	str	r3, [r7, #16]

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
     SYSCLK = PLL_VCO / (PLLP or PLLR)
  */
  pllsource = LL_RCC_PLL_GetMainSource();
 800faa0:	f7ff ff30 	bl	800f904 <LL_RCC_PLL_GetMainSource>
 800faa4:	60f8      	str	r0, [r7, #12]

  switch (pllsource)
 800faa6:	68fb      	ldr	r3, [r7, #12]
 800faa8:	2b00      	cmp	r3, #0
 800faaa:	d004      	beq.n	800fab6 <RCC_PLL_GetFreqDomain_SYS+0x2a>
 800faac:	68fb      	ldr	r3, [r7, #12]
 800faae:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800fab2:	d003      	beq.n	800fabc <RCC_PLL_GetFreqDomain_SYS+0x30>
 800fab4:	e005      	b.n	800fac2 <RCC_PLL_GetFreqDomain_SYS+0x36>
  {
    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllinputfreq = HSI_VALUE;
 800fab6:	4b12      	ldr	r3, [pc, #72]	; (800fb00 <RCC_PLL_GetFreqDomain_SYS+0x74>)
 800fab8:	617b      	str	r3, [r7, #20]
      break;
 800faba:	e005      	b.n	800fac8 <RCC_PLL_GetFreqDomain_SYS+0x3c>

    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllinputfreq = HSE_VALUE;
 800fabc:	4b11      	ldr	r3, [pc, #68]	; (800fb04 <RCC_PLL_GetFreqDomain_SYS+0x78>)
 800fabe:	617b      	str	r3, [r7, #20]
      break;
 800fac0:	e002      	b.n	800fac8 <RCC_PLL_GetFreqDomain_SYS+0x3c>

    default:
      pllinputfreq = HSI_VALUE;
 800fac2:	4b0f      	ldr	r3, [pc, #60]	; (800fb00 <RCC_PLL_GetFreqDomain_SYS+0x74>)
 800fac4:	617b      	str	r3, [r7, #20]
      break;
 800fac6:	bf00      	nop
  }

  if (SYSCLK_Source == LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
 800fac8:	687b      	ldr	r3, [r7, #4]
 800faca:	2b08      	cmp	r3, #8
 800facc:	d113      	bne.n	800faf6 <RCC_PLL_GetFreqDomain_SYS+0x6a>
  {
    plloutputfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 800face:	f7ff ff43 	bl	800f958 <LL_RCC_PLL_GetDivider>
 800fad2:	4602      	mov	r2, r0
 800fad4:	697b      	ldr	r3, [r7, #20]
 800fad6:	fbb3 f4f2 	udiv	r4, r3, r2
 800fada:	f7ff ff21 	bl	800f920 <LL_RCC_PLL_GetN>
 800fade:	4603      	mov	r3, r0
 800fae0:	fb03 f404 	mul.w	r4, r3, r4
 800fae4:	f7ff ff2a 	bl	800f93c <LL_RCC_PLL_GetP>
 800fae8:	4603      	mov	r3, r0
 800faea:	0c1b      	lsrs	r3, r3, #16
 800faec:	3301      	adds	r3, #1
 800faee:	005b      	lsls	r3, r3, #1
 800faf0:	fbb4 f3f3 	udiv	r3, r4, r3
 800faf4:	613b      	str	r3, [r7, #16]
    plloutputfreq = __LL_RCC_CALC_PLLRCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }
#endif /* RCC_PLLR_SYSCLK_SUPPORT */

  return plloutputfreq;
 800faf6:	693b      	ldr	r3, [r7, #16]
}
 800faf8:	4618      	mov	r0, r3
 800fafa:	371c      	adds	r7, #28
 800fafc:	46bd      	mov	sp, r7
 800fafe:	bd90      	pop	{r4, r7, pc}
 800fb00:	00f42400 	.word	0x00f42400
 800fb04:	007a1200 	.word	0x007a1200

0800fb08 <LL_TIM_SetPrescaler>:
{
 800fb08:	b480      	push	{r7}
 800fb0a:	b083      	sub	sp, #12
 800fb0c:	af00      	add	r7, sp, #0
 800fb0e:	6078      	str	r0, [r7, #4]
 800fb10:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->PSC, Prescaler);
 800fb12:	687b      	ldr	r3, [r7, #4]
 800fb14:	683a      	ldr	r2, [r7, #0]
 800fb16:	629a      	str	r2, [r3, #40]	; 0x28
}
 800fb18:	bf00      	nop
 800fb1a:	370c      	adds	r7, #12
 800fb1c:	46bd      	mov	sp, r7
 800fb1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb22:	4770      	bx	lr

0800fb24 <LL_TIM_SetAutoReload>:
{
 800fb24:	b480      	push	{r7}
 800fb26:	b083      	sub	sp, #12
 800fb28:	af00      	add	r7, sp, #0
 800fb2a:	6078      	str	r0, [r7, #4]
 800fb2c:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->ARR, AutoReload);
 800fb2e:	687b      	ldr	r3, [r7, #4]
 800fb30:	683a      	ldr	r2, [r7, #0]
 800fb32:	62da      	str	r2, [r3, #44]	; 0x2c
}
 800fb34:	bf00      	nop
 800fb36:	370c      	adds	r7, #12
 800fb38:	46bd      	mov	sp, r7
 800fb3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb3e:	4770      	bx	lr

0800fb40 <LL_TIM_SetRepetitionCounter>:
{
 800fb40:	b480      	push	{r7}
 800fb42:	b083      	sub	sp, #12
 800fb44:	af00      	add	r7, sp, #0
 800fb46:	6078      	str	r0, [r7, #4]
 800fb48:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 800fb4a:	687b      	ldr	r3, [r7, #4]
 800fb4c:	683a      	ldr	r2, [r7, #0]
 800fb4e:	631a      	str	r2, [r3, #48]	; 0x30
}
 800fb50:	bf00      	nop
 800fb52:	370c      	adds	r7, #12
 800fb54:	46bd      	mov	sp, r7
 800fb56:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb5a:	4770      	bx	lr

0800fb5c <LL_TIM_OC_SetCompareCH1>:
{
 800fb5c:	b480      	push	{r7}
 800fb5e:	b083      	sub	sp, #12
 800fb60:	af00      	add	r7, sp, #0
 800fb62:	6078      	str	r0, [r7, #4]
 800fb64:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800fb66:	687b      	ldr	r3, [r7, #4]
 800fb68:	683a      	ldr	r2, [r7, #0]
 800fb6a:	635a      	str	r2, [r3, #52]	; 0x34
}
 800fb6c:	bf00      	nop
 800fb6e:	370c      	adds	r7, #12
 800fb70:	46bd      	mov	sp, r7
 800fb72:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb76:	4770      	bx	lr

0800fb78 <LL_TIM_OC_SetCompareCH2>:
{
 800fb78:	b480      	push	{r7}
 800fb7a:	b083      	sub	sp, #12
 800fb7c:	af00      	add	r7, sp, #0
 800fb7e:	6078      	str	r0, [r7, #4]
 800fb80:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->CCR2, CompareValue);
 800fb82:	687b      	ldr	r3, [r7, #4]
 800fb84:	683a      	ldr	r2, [r7, #0]
 800fb86:	639a      	str	r2, [r3, #56]	; 0x38
}
 800fb88:	bf00      	nop
 800fb8a:	370c      	adds	r7, #12
 800fb8c:	46bd      	mov	sp, r7
 800fb8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb92:	4770      	bx	lr

0800fb94 <LL_TIM_OC_SetCompareCH3>:
{
 800fb94:	b480      	push	{r7}
 800fb96:	b083      	sub	sp, #12
 800fb98:	af00      	add	r7, sp, #0
 800fb9a:	6078      	str	r0, [r7, #4]
 800fb9c:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->CCR3, CompareValue);
 800fb9e:	687b      	ldr	r3, [r7, #4]
 800fba0:	683a      	ldr	r2, [r7, #0]
 800fba2:	63da      	str	r2, [r3, #60]	; 0x3c
}
 800fba4:	bf00      	nop
 800fba6:	370c      	adds	r7, #12
 800fba8:	46bd      	mov	sp, r7
 800fbaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbae:	4770      	bx	lr

0800fbb0 <LL_TIM_OC_SetCompareCH4>:
{
 800fbb0:	b480      	push	{r7}
 800fbb2:	b083      	sub	sp, #12
 800fbb4:	af00      	add	r7, sp, #0
 800fbb6:	6078      	str	r0, [r7, #4]
 800fbb8:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->CCR4, CompareValue);
 800fbba:	687b      	ldr	r3, [r7, #4]
 800fbbc:	683a      	ldr	r2, [r7, #0]
 800fbbe:	641a      	str	r2, [r3, #64]	; 0x40
}
 800fbc0:	bf00      	nop
 800fbc2:	370c      	adds	r7, #12
 800fbc4:	46bd      	mov	sp, r7
 800fbc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbca:	4770      	bx	lr

0800fbcc <LL_TIM_GenerateEvent_UPDATE>:
  * @rmtoll EGR          UG            LL_TIM_GenerateEvent_UPDATE
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
{
 800fbcc:	b480      	push	{r7}
 800fbce:	b083      	sub	sp, #12
 800fbd0:	af00      	add	r7, sp, #0
 800fbd2:	6078      	str	r0, [r7, #4]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 800fbd4:	687b      	ldr	r3, [r7, #4]
 800fbd6:	695b      	ldr	r3, [r3, #20]
 800fbd8:	f043 0201 	orr.w	r2, r3, #1
 800fbdc:	687b      	ldr	r3, [r7, #4]
 800fbde:	615a      	str	r2, [r3, #20]
}
 800fbe0:	bf00      	nop
 800fbe2:	370c      	adds	r7, #12
 800fbe4:	46bd      	mov	sp, r7
 800fbe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbea:	4770      	bx	lr

0800fbec <LL_TIM_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
ErrorStatus LL_TIM_Init(TIM_TypeDef *TIMx, LL_TIM_InitTypeDef *TIM_InitStruct)
{
 800fbec:	b580      	push	{r7, lr}
 800fbee:	b084      	sub	sp, #16
 800fbf0:	af00      	add	r7, sp, #0
 800fbf2:	6078      	str	r0, [r7, #4]
 800fbf4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(TIMx));
  assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
  assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));

  tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
 800fbf6:	687b      	ldr	r3, [r7, #4]
 800fbf8:	681b      	ldr	r3, [r3, #0]
 800fbfa:	60fb      	str	r3, [r7, #12]

  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800fbfc:	687b      	ldr	r3, [r7, #4]
 800fbfe:	4a3d      	ldr	r2, [pc, #244]	; (800fcf4 <LL_TIM_Init+0x108>)
 800fc00:	4293      	cmp	r3, r2
 800fc02:	d013      	beq.n	800fc2c <LL_TIM_Init+0x40>
 800fc04:	687b      	ldr	r3, [r7, #4]
 800fc06:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800fc0a:	d00f      	beq.n	800fc2c <LL_TIM_Init+0x40>
 800fc0c:	687b      	ldr	r3, [r7, #4]
 800fc0e:	4a3a      	ldr	r2, [pc, #232]	; (800fcf8 <LL_TIM_Init+0x10c>)
 800fc10:	4293      	cmp	r3, r2
 800fc12:	d00b      	beq.n	800fc2c <LL_TIM_Init+0x40>
 800fc14:	687b      	ldr	r3, [r7, #4]
 800fc16:	4a39      	ldr	r2, [pc, #228]	; (800fcfc <LL_TIM_Init+0x110>)
 800fc18:	4293      	cmp	r3, r2
 800fc1a:	d007      	beq.n	800fc2c <LL_TIM_Init+0x40>
 800fc1c:	687b      	ldr	r3, [r7, #4]
 800fc1e:	4a38      	ldr	r2, [pc, #224]	; (800fd00 <LL_TIM_Init+0x114>)
 800fc20:	4293      	cmp	r3, r2
 800fc22:	d003      	beq.n	800fc2c <LL_TIM_Init+0x40>
 800fc24:	687b      	ldr	r3, [r7, #4]
 800fc26:	4a37      	ldr	r2, [pc, #220]	; (800fd04 <LL_TIM_Init+0x118>)
 800fc28:	4293      	cmp	r3, r2
 800fc2a:	d106      	bne.n	800fc3a <LL_TIM_Init+0x4e>
  {
    /* Select the Counter Mode */
    MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
 800fc2c:	68fb      	ldr	r3, [r7, #12]
 800fc2e:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 800fc32:	683b      	ldr	r3, [r7, #0]
 800fc34:	685b      	ldr	r3, [r3, #4]
 800fc36:	4313      	orrs	r3, r2
 800fc38:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800fc3a:	687b      	ldr	r3, [r7, #4]
 800fc3c:	4a2d      	ldr	r2, [pc, #180]	; (800fcf4 <LL_TIM_Init+0x108>)
 800fc3e:	4293      	cmp	r3, r2
 800fc40:	d02b      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc42:	687b      	ldr	r3, [r7, #4]
 800fc44:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800fc48:	d027      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc4a:	687b      	ldr	r3, [r7, #4]
 800fc4c:	4a2a      	ldr	r2, [pc, #168]	; (800fcf8 <LL_TIM_Init+0x10c>)
 800fc4e:	4293      	cmp	r3, r2
 800fc50:	d023      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc52:	687b      	ldr	r3, [r7, #4]
 800fc54:	4a29      	ldr	r2, [pc, #164]	; (800fcfc <LL_TIM_Init+0x110>)
 800fc56:	4293      	cmp	r3, r2
 800fc58:	d01f      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc5a:	687b      	ldr	r3, [r7, #4]
 800fc5c:	4a28      	ldr	r2, [pc, #160]	; (800fd00 <LL_TIM_Init+0x114>)
 800fc5e:	4293      	cmp	r3, r2
 800fc60:	d01b      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc62:	687b      	ldr	r3, [r7, #4]
 800fc64:	4a27      	ldr	r2, [pc, #156]	; (800fd04 <LL_TIM_Init+0x118>)
 800fc66:	4293      	cmp	r3, r2
 800fc68:	d017      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc6a:	687b      	ldr	r3, [r7, #4]
 800fc6c:	4a26      	ldr	r2, [pc, #152]	; (800fd08 <LL_TIM_Init+0x11c>)
 800fc6e:	4293      	cmp	r3, r2
 800fc70:	d013      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc72:	687b      	ldr	r3, [r7, #4]
 800fc74:	4a25      	ldr	r2, [pc, #148]	; (800fd0c <LL_TIM_Init+0x120>)
 800fc76:	4293      	cmp	r3, r2
 800fc78:	d00f      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc7a:	687b      	ldr	r3, [r7, #4]
 800fc7c:	4a24      	ldr	r2, [pc, #144]	; (800fd10 <LL_TIM_Init+0x124>)
 800fc7e:	4293      	cmp	r3, r2
 800fc80:	d00b      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc82:	687b      	ldr	r3, [r7, #4]
 800fc84:	4a23      	ldr	r2, [pc, #140]	; (800fd14 <LL_TIM_Init+0x128>)
 800fc86:	4293      	cmp	r3, r2
 800fc88:	d007      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc8a:	687b      	ldr	r3, [r7, #4]
 800fc8c:	4a22      	ldr	r2, [pc, #136]	; (800fd18 <LL_TIM_Init+0x12c>)
 800fc8e:	4293      	cmp	r3, r2
 800fc90:	d003      	beq.n	800fc9a <LL_TIM_Init+0xae>
 800fc92:	687b      	ldr	r3, [r7, #4]
 800fc94:	4a21      	ldr	r2, [pc, #132]	; (800fd1c <LL_TIM_Init+0x130>)
 800fc96:	4293      	cmp	r3, r2
 800fc98:	d106      	bne.n	800fca8 <LL_TIM_Init+0xbc>
  {
    /* Set the clock division */
    MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
 800fc9a:	68fb      	ldr	r3, [r7, #12]
 800fc9c:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 800fca0:	683b      	ldr	r3, [r7, #0]
 800fca2:	68db      	ldr	r3, [r3, #12]
 800fca4:	4313      	orrs	r3, r2
 800fca6:	60fb      	str	r3, [r7, #12]
  }

  /* Write to TIMx CR1 */
  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
 800fca8:	687b      	ldr	r3, [r7, #4]
 800fcaa:	68fa      	ldr	r2, [r7, #12]
 800fcac:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
 800fcae:	683b      	ldr	r3, [r7, #0]
 800fcb0:	689b      	ldr	r3, [r3, #8]
 800fcb2:	4619      	mov	r1, r3
 800fcb4:	6878      	ldr	r0, [r7, #4]
 800fcb6:	f7ff ff35 	bl	800fb24 <LL_TIM_SetAutoReload>

  /* Set the Prescaler value */
  LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
 800fcba:	683b      	ldr	r3, [r7, #0]
 800fcbc:	881b      	ldrh	r3, [r3, #0]
 800fcbe:	4619      	mov	r1, r3
 800fcc0:	6878      	ldr	r0, [r7, #4]
 800fcc2:	f7ff ff21 	bl	800fb08 <LL_TIM_SetPrescaler>

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800fcc6:	687b      	ldr	r3, [r7, #4]
 800fcc8:	4a0a      	ldr	r2, [pc, #40]	; (800fcf4 <LL_TIM_Init+0x108>)
 800fcca:	4293      	cmp	r3, r2
 800fccc:	d003      	beq.n	800fcd6 <LL_TIM_Init+0xea>
 800fcce:	687b      	ldr	r3, [r7, #4]
 800fcd0:	4a0c      	ldr	r2, [pc, #48]	; (800fd04 <LL_TIM_Init+0x118>)
 800fcd2:	4293      	cmp	r3, r2
 800fcd4:	d105      	bne.n	800fce2 <LL_TIM_Init+0xf6>
  {
    /* Set the Repetition Counter value */
    LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
 800fcd6:	683b      	ldr	r3, [r7, #0]
 800fcd8:	691b      	ldr	r3, [r3, #16]
 800fcda:	4619      	mov	r1, r3
 800fcdc:	6878      	ldr	r0, [r7, #4]
 800fcde:	f7ff ff2f 	bl	800fb40 <LL_TIM_SetRepetitionCounter>
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter value (if applicable) immediately */
  LL_TIM_GenerateEvent_UPDATE(TIMx);
 800fce2:	6878      	ldr	r0, [r7, #4]
 800fce4:	f7ff ff72 	bl	800fbcc <LL_TIM_GenerateEvent_UPDATE>

  return SUCCESS;
 800fce8:	2300      	movs	r3, #0
}
 800fcea:	4618      	mov	r0, r3
 800fcec:	3710      	adds	r7, #16
 800fcee:	46bd      	mov	sp, r7
 800fcf0:	bd80      	pop	{r7, pc}
 800fcf2:	bf00      	nop
 800fcf4:	40010000 	.word	0x40010000
 800fcf8:	40000400 	.word	0x40000400
 800fcfc:	40000800 	.word	0x40000800
 800fd00:	40000c00 	.word	0x40000c00
 800fd04:	40010400 	.word	0x40010400
 800fd08:	40014000 	.word	0x40014000
 800fd0c:	40014400 	.word	0x40014400
 800fd10:	40014800 	.word	0x40014800
 800fd14:	40001800 	.word	0x40001800
 800fd18:	40001c00 	.word	0x40001c00
 800fd1c:	40002000 	.word	0x40002000

0800fd20 <LL_TIM_OC_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx output channel is initialized
  *          - ERROR: TIMx output channel is not initialized
  */
ErrorStatus LL_TIM_OC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
{
 800fd20:	b580      	push	{r7, lr}
 800fd22:	b086      	sub	sp, #24
 800fd24:	af00      	add	r7, sp, #0
 800fd26:	60f8      	str	r0, [r7, #12]
 800fd28:	60b9      	str	r1, [r7, #8]
 800fd2a:	607a      	str	r2, [r7, #4]
  ErrorStatus result = ERROR;
 800fd2c:	2301      	movs	r3, #1
 800fd2e:	75fb      	strb	r3, [r7, #23]

  switch (Channel)
 800fd30:	68bb      	ldr	r3, [r7, #8]
 800fd32:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800fd36:	d027      	beq.n	800fd88 <LL_TIM_OC_Init+0x68>
 800fd38:	68bb      	ldr	r3, [r7, #8]
 800fd3a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800fd3e:	d82a      	bhi.n	800fd96 <LL_TIM_OC_Init+0x76>
 800fd40:	68bb      	ldr	r3, [r7, #8]
 800fd42:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800fd46:	d018      	beq.n	800fd7a <LL_TIM_OC_Init+0x5a>
 800fd48:	68bb      	ldr	r3, [r7, #8]
 800fd4a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800fd4e:	d822      	bhi.n	800fd96 <LL_TIM_OC_Init+0x76>
 800fd50:	68bb      	ldr	r3, [r7, #8]
 800fd52:	2b01      	cmp	r3, #1
 800fd54:	d003      	beq.n	800fd5e <LL_TIM_OC_Init+0x3e>
 800fd56:	68bb      	ldr	r3, [r7, #8]
 800fd58:	2b10      	cmp	r3, #16
 800fd5a:	d007      	beq.n	800fd6c <LL_TIM_OC_Init+0x4c>
      break;
    case LL_TIM_CHANNEL_CH4:
      result = OC4Config(TIMx, TIM_OC_InitStruct);
      break;
    default:
      break;
 800fd5c:	e01b      	b.n	800fd96 <LL_TIM_OC_Init+0x76>
      result = OC1Config(TIMx, TIM_OC_InitStruct);
 800fd5e:	6879      	ldr	r1, [r7, #4]
 800fd60:	68f8      	ldr	r0, [r7, #12]
 800fd62:	f000 f81f 	bl	800fda4 <OC1Config>
 800fd66:	4603      	mov	r3, r0
 800fd68:	75fb      	strb	r3, [r7, #23]
      break;
 800fd6a:	e015      	b.n	800fd98 <LL_TIM_OC_Init+0x78>
      result = OC2Config(TIMx, TIM_OC_InitStruct);
 800fd6c:	6879      	ldr	r1, [r7, #4]
 800fd6e:	68f8      	ldr	r0, [r7, #12]
 800fd70:	f000 f884 	bl	800fe7c <OC2Config>
 800fd74:	4603      	mov	r3, r0
 800fd76:	75fb      	strb	r3, [r7, #23]
      break;
 800fd78:	e00e      	b.n	800fd98 <LL_TIM_OC_Init+0x78>
      result = OC3Config(TIMx, TIM_OC_InitStruct);
 800fd7a:	6879      	ldr	r1, [r7, #4]
 800fd7c:	68f8      	ldr	r0, [r7, #12]
 800fd7e:	f000 f8ed 	bl	800ff5c <OC3Config>
 800fd82:	4603      	mov	r3, r0
 800fd84:	75fb      	strb	r3, [r7, #23]
      break;
 800fd86:	e007      	b.n	800fd98 <LL_TIM_OC_Init+0x78>
      result = OC4Config(TIMx, TIM_OC_InitStruct);
 800fd88:	6879      	ldr	r1, [r7, #4]
 800fd8a:	68f8      	ldr	r0, [r7, #12]
 800fd8c:	f000 f956 	bl	801003c <OC4Config>
 800fd90:	4603      	mov	r3, r0
 800fd92:	75fb      	strb	r3, [r7, #23]
      break;
 800fd94:	e000      	b.n	800fd98 <LL_TIM_OC_Init+0x78>
      break;
 800fd96:	bf00      	nop
  }

  return result;
 800fd98:	7dfb      	ldrb	r3, [r7, #23]
}
 800fd9a:	4618      	mov	r0, r3
 800fd9c:	3718      	adds	r7, #24
 800fd9e:	46bd      	mov	sp, r7
 800fda0:	bd80      	pop	{r7, pc}
	...

0800fda4 <OC1Config>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
static ErrorStatus OC1Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
{
 800fda4:	b580      	push	{r7, lr}
 800fda6:	b086      	sub	sp, #24
 800fda8:	af00      	add	r7, sp, #0
 800fdaa:	6078      	str	r0, [r7, #4]
 800fdac:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));

  /* Disable the Channel 1: Reset the CC1E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
 800fdae:	687b      	ldr	r3, [r7, #4]
 800fdb0:	6a1b      	ldr	r3, [r3, #32]
 800fdb2:	f023 0201 	bic.w	r2, r3, #1
 800fdb6:	687b      	ldr	r3, [r7, #4]
 800fdb8:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
 800fdba:	687b      	ldr	r3, [r7, #4]
 800fdbc:	6a1b      	ldr	r3, [r3, #32]
 800fdbe:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CR2 register value */
  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 800fdc0:	687b      	ldr	r3, [r7, #4]
 800fdc2:	685b      	ldr	r3, [r3, #4]
 800fdc4:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
 800fdc6:	687b      	ldr	r3, [r7, #4]
 800fdc8:	699b      	ldr	r3, [r3, #24]
 800fdca:	60fb      	str	r3, [r7, #12]

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
 800fdcc:	68fb      	ldr	r3, [r7, #12]
 800fdce:	f023 0303 	bic.w	r3, r3, #3
 800fdd2:	60fb      	str	r3, [r7, #12]

  /* Set the Output Compare Mode */
  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
 800fdd4:	68fb      	ldr	r3, [r7, #12]
 800fdd6:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 800fdda:	683b      	ldr	r3, [r7, #0]
 800fddc:	681b      	ldr	r3, [r3, #0]
 800fdde:	4313      	orrs	r3, r2
 800fde0:	60fb      	str	r3, [r7, #12]

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
 800fde2:	697b      	ldr	r3, [r7, #20]
 800fde4:	f023 0202 	bic.w	r2, r3, #2
 800fde8:	683b      	ldr	r3, [r7, #0]
 800fdea:	691b      	ldr	r3, [r3, #16]
 800fdec:	4313      	orrs	r3, r2
 800fdee:	617b      	str	r3, [r7, #20]

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
 800fdf0:	697b      	ldr	r3, [r7, #20]
 800fdf2:	f023 0201 	bic.w	r2, r3, #1
 800fdf6:	683b      	ldr	r3, [r7, #0]
 800fdf8:	685b      	ldr	r3, [r3, #4]
 800fdfa:	4313      	orrs	r3, r2
 800fdfc:	617b      	str	r3, [r7, #20]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800fdfe:	687b      	ldr	r3, [r7, #4]
 800fe00:	4a1c      	ldr	r2, [pc, #112]	; (800fe74 <OC1Config+0xd0>)
 800fe02:	4293      	cmp	r3, r2
 800fe04:	d003      	beq.n	800fe0e <OC1Config+0x6a>
 800fe06:	687b      	ldr	r3, [r7, #4]
 800fe08:	4a1b      	ldr	r2, [pc, #108]	; (800fe78 <OC1Config+0xd4>)
 800fe0a:	4293      	cmp	r3, r2
 800fe0c:	d11e      	bne.n	800fe4c <OC1Config+0xa8>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the complementary output Polarity */
    MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
 800fe0e:	697b      	ldr	r3, [r7, #20]
 800fe10:	f023 0208 	bic.w	r2, r3, #8
 800fe14:	683b      	ldr	r3, [r7, #0]
 800fe16:	695b      	ldr	r3, [r3, #20]
 800fe18:	009b      	lsls	r3, r3, #2
 800fe1a:	4313      	orrs	r3, r2
 800fe1c:	617b      	str	r3, [r7, #20]

    /* Set the complementary output State */
    MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
 800fe1e:	697b      	ldr	r3, [r7, #20]
 800fe20:	f023 0204 	bic.w	r2, r3, #4
 800fe24:	683b      	ldr	r3, [r7, #0]
 800fe26:	689b      	ldr	r3, [r3, #8]
 800fe28:	009b      	lsls	r3, r3, #2
 800fe2a:	4313      	orrs	r3, r2
 800fe2c:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
 800fe2e:	693b      	ldr	r3, [r7, #16]
 800fe30:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 800fe34:	683b      	ldr	r3, [r7, #0]
 800fe36:	699b      	ldr	r3, [r3, #24]
 800fe38:	4313      	orrs	r3, r2
 800fe3a:	613b      	str	r3, [r7, #16]

    /* Set the complementary output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
 800fe3c:	693b      	ldr	r3, [r7, #16]
 800fe3e:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 800fe42:	683b      	ldr	r3, [r7, #0]
 800fe44:	69db      	ldr	r3, [r3, #28]
 800fe46:	005b      	lsls	r3, r3, #1
 800fe48:	4313      	orrs	r3, r2
 800fe4a:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 800fe4c:	687b      	ldr	r3, [r7, #4]
 800fe4e:	693a      	ldr	r2, [r7, #16]
 800fe50:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
 800fe52:	687b      	ldr	r3, [r7, #4]
 800fe54:	68fa      	ldr	r2, [r7, #12]
 800fe56:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
 800fe58:	683b      	ldr	r3, [r7, #0]
 800fe5a:	68db      	ldr	r3, [r3, #12]
 800fe5c:	4619      	mov	r1, r3
 800fe5e:	6878      	ldr	r0, [r7, #4]
 800fe60:	f7ff fe7c 	bl	800fb5c <LL_TIM_OC_SetCompareCH1>

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 800fe64:	687b      	ldr	r3, [r7, #4]
 800fe66:	697a      	ldr	r2, [r7, #20]
 800fe68:	621a      	str	r2, [r3, #32]

  return SUCCESS;
 800fe6a:	2300      	movs	r3, #0
}
 800fe6c:	4618      	mov	r0, r3
 800fe6e:	3718      	adds	r7, #24
 800fe70:	46bd      	mov	sp, r7
 800fe72:	bd80      	pop	{r7, pc}
 800fe74:	40010000 	.word	0x40010000
 800fe78:	40010400 	.word	0x40010400

0800fe7c <OC2Config>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
static ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
{
 800fe7c:	b580      	push	{r7, lr}
 800fe7e:	b086      	sub	sp, #24
 800fe80:	af00      	add	r7, sp, #0
 800fe82:	6078      	str	r0, [r7, #4]
 800fe84:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));

  /* Disable the Channel 2: Reset the CC2E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
 800fe86:	687b      	ldr	r3, [r7, #4]
 800fe88:	6a1b      	ldr	r3, [r3, #32]
 800fe8a:	f023 0210 	bic.w	r2, r3, #16
 800fe8e:	687b      	ldr	r3, [r7, #4]
 800fe90:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
 800fe92:	687b      	ldr	r3, [r7, #4]
 800fe94:	6a1b      	ldr	r3, [r3, #32]
 800fe96:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CR2 register value */
  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 800fe98:	687b      	ldr	r3, [r7, #4]
 800fe9a:	685b      	ldr	r3, [r3, #4]
 800fe9c:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
 800fe9e:	687b      	ldr	r3, [r7, #4]
 800fea0:	699b      	ldr	r3, [r3, #24]
 800fea2:	60fb      	str	r3, [r7, #12]

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
 800fea4:	68fb      	ldr	r3, [r7, #12]
 800fea6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800feaa:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
 800feac:	68fb      	ldr	r3, [r7, #12]
 800feae:	f423 42e0 	bic.w	r2, r3, #28672	; 0x7000
 800feb2:	683b      	ldr	r3, [r7, #0]
 800feb4:	681b      	ldr	r3, [r3, #0]
 800feb6:	021b      	lsls	r3, r3, #8
 800feb8:	4313      	orrs	r3, r2
 800feba:	60fb      	str	r3, [r7, #12]

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
 800febc:	697b      	ldr	r3, [r7, #20]
 800febe:	f023 0220 	bic.w	r2, r3, #32
 800fec2:	683b      	ldr	r3, [r7, #0]
 800fec4:	691b      	ldr	r3, [r3, #16]
 800fec6:	011b      	lsls	r3, r3, #4
 800fec8:	4313      	orrs	r3, r2
 800feca:	617b      	str	r3, [r7, #20]

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
 800fecc:	697b      	ldr	r3, [r7, #20]
 800fece:	f023 0210 	bic.w	r2, r3, #16
 800fed2:	683b      	ldr	r3, [r7, #0]
 800fed4:	685b      	ldr	r3, [r3, #4]
 800fed6:	011b      	lsls	r3, r3, #4
 800fed8:	4313      	orrs	r3, r2
 800feda:	617b      	str	r3, [r7, #20]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800fedc:	687b      	ldr	r3, [r7, #4]
 800fede:	4a1d      	ldr	r2, [pc, #116]	; (800ff54 <OC2Config+0xd8>)
 800fee0:	4293      	cmp	r3, r2
 800fee2:	d003      	beq.n	800feec <OC2Config+0x70>
 800fee4:	687b      	ldr	r3, [r7, #4]
 800fee6:	4a1c      	ldr	r2, [pc, #112]	; (800ff58 <OC2Config+0xdc>)
 800fee8:	4293      	cmp	r3, r2
 800feea:	d11f      	bne.n	800ff2c <OC2Config+0xb0>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the complementary output Polarity */
    MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
 800feec:	697b      	ldr	r3, [r7, #20]
 800feee:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800fef2:	683b      	ldr	r3, [r7, #0]
 800fef4:	695b      	ldr	r3, [r3, #20]
 800fef6:	019b      	lsls	r3, r3, #6
 800fef8:	4313      	orrs	r3, r2
 800fefa:	617b      	str	r3, [r7, #20]

    /* Set the complementary output State */
    MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
 800fefc:	697b      	ldr	r3, [r7, #20]
 800fefe:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 800ff02:	683b      	ldr	r3, [r7, #0]
 800ff04:	689b      	ldr	r3, [r3, #8]
 800ff06:	019b      	lsls	r3, r3, #6
 800ff08:	4313      	orrs	r3, r2
 800ff0a:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
 800ff0c:	693b      	ldr	r3, [r7, #16]
 800ff0e:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 800ff12:	683b      	ldr	r3, [r7, #0]
 800ff14:	699b      	ldr	r3, [r3, #24]
 800ff16:	009b      	lsls	r3, r3, #2
 800ff18:	4313      	orrs	r3, r2
 800ff1a:	613b      	str	r3, [r7, #16]

    /* Set the complementary output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
 800ff1c:	693b      	ldr	r3, [r7, #16]
 800ff1e:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 800ff22:	683b      	ldr	r3, [r7, #0]
 800ff24:	69db      	ldr	r3, [r3, #28]
 800ff26:	00db      	lsls	r3, r3, #3
 800ff28:	4313      	orrs	r3, r2
 800ff2a:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 800ff2c:	687b      	ldr	r3, [r7, #4]
 800ff2e:	693a      	ldr	r2, [r7, #16]
 800ff30:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
 800ff32:	687b      	ldr	r3, [r7, #4]
 800ff34:	68fa      	ldr	r2, [r7, #12]
 800ff36:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
 800ff38:	683b      	ldr	r3, [r7, #0]
 800ff3a:	68db      	ldr	r3, [r3, #12]
 800ff3c:	4619      	mov	r1, r3
 800ff3e:	6878      	ldr	r0, [r7, #4]
 800ff40:	f7ff fe1a 	bl	800fb78 <LL_TIM_OC_SetCompareCH2>

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 800ff44:	687b      	ldr	r3, [r7, #4]
 800ff46:	697a      	ldr	r2, [r7, #20]
 800ff48:	621a      	str	r2, [r3, #32]

  return SUCCESS;
 800ff4a:	2300      	movs	r3, #0
}
 800ff4c:	4618      	mov	r0, r3
 800ff4e:	3718      	adds	r7, #24
 800ff50:	46bd      	mov	sp, r7
 800ff52:	bd80      	pop	{r7, pc}
 800ff54:	40010000 	.word	0x40010000
 800ff58:	40010400 	.word	0x40010400

0800ff5c <OC3Config>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
static ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
{
 800ff5c:	b580      	push	{r7, lr}
 800ff5e:	b086      	sub	sp, #24
 800ff60:	af00      	add	r7, sp, #0
 800ff62:	6078      	str	r0, [r7, #4]
 800ff64:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));

  /* Disable the Channel 3: Reset the CC3E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
 800ff66:	687b      	ldr	r3, [r7, #4]
 800ff68:	6a1b      	ldr	r3, [r3, #32]
 800ff6a:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 800ff6e:	687b      	ldr	r3, [r7, #4]
 800ff70:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
 800ff72:	687b      	ldr	r3, [r7, #4]
 800ff74:	6a1b      	ldr	r3, [r3, #32]
 800ff76:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CR2 register value */
  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 800ff78:	687b      	ldr	r3, [r7, #4]
 800ff7a:	685b      	ldr	r3, [r3, #4]
 800ff7c:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
 800ff7e:	687b      	ldr	r3, [r7, #4]
 800ff80:	69db      	ldr	r3, [r3, #28]
 800ff82:	60fb      	str	r3, [r7, #12]

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
 800ff84:	68fb      	ldr	r3, [r7, #12]
 800ff86:	f023 0303 	bic.w	r3, r3, #3
 800ff8a:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
 800ff8c:	68fb      	ldr	r3, [r7, #12]
 800ff8e:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 800ff92:	683b      	ldr	r3, [r7, #0]
 800ff94:	681b      	ldr	r3, [r3, #0]
 800ff96:	4313      	orrs	r3, r2
 800ff98:	60fb      	str	r3, [r7, #12]

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
 800ff9a:	697b      	ldr	r3, [r7, #20]
 800ff9c:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 800ffa0:	683b      	ldr	r3, [r7, #0]
 800ffa2:	691b      	ldr	r3, [r3, #16]
 800ffa4:	021b      	lsls	r3, r3, #8
 800ffa6:	4313      	orrs	r3, r2
 800ffa8:	617b      	str	r3, [r7, #20]

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
 800ffaa:	697b      	ldr	r3, [r7, #20]
 800ffac:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 800ffb0:	683b      	ldr	r3, [r7, #0]
 800ffb2:	685b      	ldr	r3, [r3, #4]
 800ffb4:	021b      	lsls	r3, r3, #8
 800ffb6:	4313      	orrs	r3, r2
 800ffb8:	617b      	str	r3, [r7, #20]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ffba:	687b      	ldr	r3, [r7, #4]
 800ffbc:	4a1d      	ldr	r2, [pc, #116]	; (8010034 <OC3Config+0xd8>)
 800ffbe:	4293      	cmp	r3, r2
 800ffc0:	d003      	beq.n	800ffca <OC3Config+0x6e>
 800ffc2:	687b      	ldr	r3, [r7, #4]
 800ffc4:	4a1c      	ldr	r2, [pc, #112]	; (8010038 <OC3Config+0xdc>)
 800ffc6:	4293      	cmp	r3, r2
 800ffc8:	d11f      	bne.n	801000a <OC3Config+0xae>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the complementary output Polarity */
    MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
 800ffca:	697b      	ldr	r3, [r7, #20]
 800ffcc:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 800ffd0:	683b      	ldr	r3, [r7, #0]
 800ffd2:	695b      	ldr	r3, [r3, #20]
 800ffd4:	029b      	lsls	r3, r3, #10
 800ffd6:	4313      	orrs	r3, r2
 800ffd8:	617b      	str	r3, [r7, #20]

    /* Set the complementary output State */
    MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
 800ffda:	697b      	ldr	r3, [r7, #20]
 800ffdc:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 800ffe0:	683b      	ldr	r3, [r7, #0]
 800ffe2:	689b      	ldr	r3, [r3, #8]
 800ffe4:	029b      	lsls	r3, r3, #10
 800ffe6:	4313      	orrs	r3, r2
 800ffe8:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
 800ffea:	693b      	ldr	r3, [r7, #16]
 800ffec:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 800fff0:	683b      	ldr	r3, [r7, #0]
 800fff2:	699b      	ldr	r3, [r3, #24]
 800fff4:	011b      	lsls	r3, r3, #4
 800fff6:	4313      	orrs	r3, r2
 800fff8:	613b      	str	r3, [r7, #16]

    /* Set the complementary output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
 800fffa:	693b      	ldr	r3, [r7, #16]
 800fffc:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
 8010000:	683b      	ldr	r3, [r7, #0]
 8010002:	69db      	ldr	r3, [r3, #28]
 8010004:	015b      	lsls	r3, r3, #5
 8010006:	4313      	orrs	r3, r2
 8010008:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 801000a:	687b      	ldr	r3, [r7, #4]
 801000c:	693a      	ldr	r2, [r7, #16]
 801000e:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
 8010010:	687b      	ldr	r3, [r7, #4]
 8010012:	68fa      	ldr	r2, [r7, #12]
 8010014:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
 8010016:	683b      	ldr	r3, [r7, #0]
 8010018:	68db      	ldr	r3, [r3, #12]
 801001a:	4619      	mov	r1, r3
 801001c:	6878      	ldr	r0, [r7, #4]
 801001e:	f7ff fdb9 	bl	800fb94 <LL_TIM_OC_SetCompareCH3>

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 8010022:	687b      	ldr	r3, [r7, #4]
 8010024:	697a      	ldr	r2, [r7, #20]
 8010026:	621a      	str	r2, [r3, #32]

  return SUCCESS;
 8010028:	2300      	movs	r3, #0
}
 801002a:	4618      	mov	r0, r3
 801002c:	3718      	adds	r7, #24
 801002e:	46bd      	mov	sp, r7
 8010030:	bd80      	pop	{r7, pc}
 8010032:	bf00      	nop
 8010034:	40010000 	.word	0x40010000
 8010038:	40010400 	.word	0x40010400

0801003c <OC4Config>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
static ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
{
 801003c:	b580      	push	{r7, lr}
 801003e:	b086      	sub	sp, #24
 8010040:	af00      	add	r7, sp, #0
 8010042:	6078      	str	r0, [r7, #4]
 8010044:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));

  /* Disable the Channel 4: Reset the CC4E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
 8010046:	687b      	ldr	r3, [r7, #4]
 8010048:	6a1b      	ldr	r3, [r3, #32]
 801004a:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 801004e:	687b      	ldr	r3, [r7, #4]
 8010050:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
 8010052:	687b      	ldr	r3, [r7, #4]
 8010054:	6a1b      	ldr	r3, [r3, #32]
 8010056:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
 8010058:	687b      	ldr	r3, [r7, #4]
 801005a:	685b      	ldr	r3, [r3, #4]
 801005c:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
 801005e:	687b      	ldr	r3, [r7, #4]
 8010060:	69db      	ldr	r3, [r3, #28]
 8010062:	60fb      	str	r3, [r7, #12]

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
 8010064:	68fb      	ldr	r3, [r7, #12]
 8010066:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 801006a:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
 801006c:	68fb      	ldr	r3, [r7, #12]
 801006e:	f423 42e0 	bic.w	r2, r3, #28672	; 0x7000
 8010072:	683b      	ldr	r3, [r7, #0]
 8010074:	681b      	ldr	r3, [r3, #0]
 8010076:	021b      	lsls	r3, r3, #8
 8010078:	4313      	orrs	r3, r2
 801007a:	60fb      	str	r3, [r7, #12]

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
 801007c:	693b      	ldr	r3, [r7, #16]
 801007e:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
 8010082:	683b      	ldr	r3, [r7, #0]
 8010084:	691b      	ldr	r3, [r3, #16]
 8010086:	031b      	lsls	r3, r3, #12
 8010088:	4313      	orrs	r3, r2
 801008a:	613b      	str	r3, [r7, #16]

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
 801008c:	693b      	ldr	r3, [r7, #16]
 801008e:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8010092:	683b      	ldr	r3, [r7, #0]
 8010094:	685b      	ldr	r3, [r3, #4]
 8010096:	031b      	lsls	r3, r3, #12
 8010098:	4313      	orrs	r3, r2
 801009a:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 801009c:	687b      	ldr	r3, [r7, #4]
 801009e:	4a11      	ldr	r2, [pc, #68]	; (80100e4 <OC4Config+0xa8>)
 80100a0:	4293      	cmp	r3, r2
 80100a2:	d003      	beq.n	80100ac <OC4Config+0x70>
 80100a4:	687b      	ldr	r3, [r7, #4]
 80100a6:	4a10      	ldr	r2, [pc, #64]	; (80100e8 <OC4Config+0xac>)
 80100a8:	4293      	cmp	r3, r2
 80100aa:	d107      	bne.n	80100bc <OC4Config+0x80>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the Output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
 80100ac:	697b      	ldr	r3, [r7, #20]
 80100ae:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
 80100b2:	683b      	ldr	r3, [r7, #0]
 80100b4:	699b      	ldr	r3, [r3, #24]
 80100b6:	019b      	lsls	r3, r3, #6
 80100b8:	4313      	orrs	r3, r2
 80100ba:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 80100bc:	687b      	ldr	r3, [r7, #4]
 80100be:	697a      	ldr	r2, [r7, #20]
 80100c0:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
 80100c2:	687b      	ldr	r3, [r7, #4]
 80100c4:	68fa      	ldr	r2, [r7, #12]
 80100c6:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
 80100c8:	683b      	ldr	r3, [r7, #0]
 80100ca:	68db      	ldr	r3, [r3, #12]
 80100cc:	4619      	mov	r1, r3
 80100ce:	6878      	ldr	r0, [r7, #4]
 80100d0:	f7ff fd6e 	bl	800fbb0 <LL_TIM_OC_SetCompareCH4>

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 80100d4:	687b      	ldr	r3, [r7, #4]
 80100d6:	693a      	ldr	r2, [r7, #16]
 80100d8:	621a      	str	r2, [r3, #32]

  return SUCCESS;
 80100da:	2300      	movs	r3, #0
}
 80100dc:	4618      	mov	r0, r3
 80100de:	3718      	adds	r7, #24
 80100e0:	46bd      	mov	sp, r7
 80100e2:	bd80      	pop	{r7, pc}
 80100e4:	40010000 	.word	0x40010000
 80100e8:	40010400 	.word	0x40010400

080100ec <LL_SetSystemCoreClock>:
  * @note   Variable can be calculated also through SystemCoreClockUpdate function.
  * @param  HCLKFrequency HCLK frequency in Hz (can be calculated thanks to RCC helper macro)
  * @retval None
  */
void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
{
 80100ec:	b480      	push	{r7}
 80100ee:	b083      	sub	sp, #12
 80100f0:	af00      	add	r7, sp, #0
 80100f2:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  SystemCoreClock = HCLKFrequency;
 80100f4:	4a04      	ldr	r2, [pc, #16]	; (8010108 <LL_SetSystemCoreClock+0x1c>)
 80100f6:	687b      	ldr	r3, [r7, #4]
 80100f8:	6013      	str	r3, [r2, #0]
}
 80100fa:	bf00      	nop
 80100fc:	370c      	adds	r7, #12
 80100fe:	46bd      	mov	sp, r7
 8010100:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010104:	4770      	bx	lr
 8010106:	bf00      	nop
 8010108:	20000004 	.word	0x20000004

0801010c <memset>:
 801010c:	4402      	add	r2, r0
 801010e:	4603      	mov	r3, r0
 8010110:	4293      	cmp	r3, r2
 8010112:	d100      	bne.n	8010116 <memset+0xa>
 8010114:	4770      	bx	lr
 8010116:	f803 1b01 	strb.w	r1, [r3], #1
 801011a:	e7f9      	b.n	8010110 <memset+0x4>

0801011c <__libc_init_array>:
 801011c:	b570      	push	{r4, r5, r6, lr}
 801011e:	4d0d      	ldr	r5, [pc, #52]	; (8010154 <__libc_init_array+0x38>)
 8010120:	4c0d      	ldr	r4, [pc, #52]	; (8010158 <__libc_init_array+0x3c>)
 8010122:	1b64      	subs	r4, r4, r5
 8010124:	10a4      	asrs	r4, r4, #2
 8010126:	2600      	movs	r6, #0
 8010128:	42a6      	cmp	r6, r4
 801012a:	d109      	bne.n	8010140 <__libc_init_array+0x24>
 801012c:	4d0b      	ldr	r5, [pc, #44]	; (801015c <__libc_init_array+0x40>)
 801012e:	4c0c      	ldr	r4, [pc, #48]	; (8010160 <__libc_init_array+0x44>)
 8010130:	f000 f818 	bl	8010164 <_init>
 8010134:	1b64      	subs	r4, r4, r5
 8010136:	10a4      	asrs	r4, r4, #2
 8010138:	2600      	movs	r6, #0
 801013a:	42a6      	cmp	r6, r4
 801013c:	d105      	bne.n	801014a <__libc_init_array+0x2e>
 801013e:	bd70      	pop	{r4, r5, r6, pc}
 8010140:	f855 3b04 	ldr.w	r3, [r5], #4
 8010144:	4798      	blx	r3
 8010146:	3601      	adds	r6, #1
 8010148:	e7ee      	b.n	8010128 <__libc_init_array+0xc>
 801014a:	f855 3b04 	ldr.w	r3, [r5], #4
 801014e:	4798      	blx	r3
 8010150:	3601      	adds	r6, #1
 8010152:	e7f2      	b.n	801013a <__libc_init_array+0x1e>
 8010154:	08010270 	.word	0x08010270
 8010158:	08010270 	.word	0x08010270
 801015c:	08010270 	.word	0x08010270
 8010160:	08010274 	.word	0x08010274

08010164 <_init>:
 8010164:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010166:	bf00      	nop
 8010168:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801016a:	bc08      	pop	{r3}
 801016c:	469e      	mov	lr, r3
 801016e:	4770      	bx	lr

08010170 <_fini>:
 8010170:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010172:	bf00      	nop
 8010174:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8010176:	bc08      	pop	{r3}
 8010178:	469e      	mov	lr, r3
 801017a:	4770      	bx	lr
